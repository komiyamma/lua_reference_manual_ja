<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3 リファレンスマニュアル</TITLE>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=shift_jis">
</HEAD>

<BODY>


<div class="body">
<H1>
Lua 5.3 リファレンスマニュアル
</H1>

<P>
このリファレンスマニュアルはLua言語の公式の定義です。
<BR>
Luaプログラミングの完全な入門には書籍
<A HREF="http://www.lua.org/pil/">Programming in Lua</A>
を参照してください。

<DIV CLASS="menubar">
<A HREF="#start">スタート</A>
&middot;
<A HREF="#contents">目次</A>
&middot;
<A HREF="#index">索引</A>
&middot;
<A HREF="http://www.lua.org/manual/">他のバージョン</A>
</DIV>

<P>
<SMALL>
Copyright &copy; 2015 Lua.org, PUC-Rio.
Freely available under the terms of the
<A HREF="http://www.lua.org/license.html">Lua license</A>.
</SMALL>

<H2 class="index"><A NAME="contents">目次</A></H2>
<UL CLASS="contents menubar">
<LI><A HREF="#0">0 &ndash; 日本語訳について</A>
<P>
<LI><A HREF="#1">1 &ndash; 序文</A>
<P>
<LI><A HREF="#2">2 &ndash; 基本コンセプト</A>
<UL>
<LI><A HREF="#2.1">2.1 &ndash; 値と型</A>
<LI><A HREF="#2.2">2.2 &ndash; 環境とグローバル環境</A>
<LI><A HREF="#2.3">2.3 &ndash; エラー処理</A>
<LI><A HREF="#2.4">2.4 &ndash; メタテーブルとメタメソッド</A>
<LI><A HREF="#2.5">2.5 &ndash; ガベージコレクション</A>
<UL>
<LI><A HREF="#2.5.1">2.5.1 &ndash; ガベージコレクションメタメソッド</A>
<LI><A HREF="#2.5.2">2.5.2 &ndash; 弱参照テーブル</A>
</UL>
<LI><A HREF="#2.6">2.6 &ndash; コルーチン</A>
</UL>
<P>
<LI><A HREF="#3">3 &ndash; 言語</A>
<UL>
<LI><A HREF="#3.1">3.1 &ndash; 字句規約</A>
<LI><A HREF="#3.2">3.2 &ndash; 変数</A>
<LI><A HREF="#3.3">3.3 &ndash; 文</A>
<UL>
<LI><A HREF="#3.3.1">3.3.1 &ndash; ブロック</A>
<LI><A HREF="#3.3.2">3.3.2 &ndash; チャンク</A>
<LI><A HREF="#3.3.3">3.3.3 &ndash; 代入</A>
<LI><A HREF="#3.3.4">3.3.4 &ndash; 制御構造</A>
<LI><A HREF="#3.3.5">3.3.5 &ndash; for文</A>
<LI><A HREF="#3.3.6">3.3.6 &ndash; 文としての関数呼び出し</A>
<LI><A HREF="#3.3.7">3.3.7 &ndash; ローカル宣言</A>
</UL>
<LI><A HREF="#3.4">3.4 &ndash; 式</A>
<UL>
<LI><A HREF="#3.4.1">3.4.1 &ndash; 算術演算子</A>
<LI><A HREF="#3.4.2">3.4.2 &ndash; ビット演算子</A>
<LI><A HREF="#3.4.3">3.4.3 &ndash; 強制型変換</A>
<LI><A HREF="#3.4.4">3.4.4 &ndash; 関係演算子</A>
<LI><A HREF="#3.4.5">3.4.5 &ndash; 論理演算子</A>
<LI><A HREF="#3.4.6">3.4.6 &ndash; 連結</A>
<LI><A HREF="#3.4.7">3.4.7 &ndash; 長さ演算子</A>
<LI><A HREF="#3.4.8">3.4.8 &ndash; 優先順位</A>
<LI><A HREF="#3.4.9">3.4.9 &ndash; テーブルコンストラクタ</A>
<LI><A HREF="#3.4.10">3.4.10 &ndash; 関数呼び出し</A>
<LI><A HREF="#3.4.11">3.4.11 &ndash; 関数定義</A>
</UL>
<LI><A HREF="#3.5">3.5 &ndash; 可視性ルール</A>
</UL>
<P>
<LI><A HREF="#4">4 &ndash; API</A>
<UL>
<LI><A HREF="#4.1">4.1 &ndash; スタック</A>
<LI><A HREF="#4.2">4.2 &ndash; スタックサイズ</A>
<LI><A HREF="#4.3">4.3 &ndash; 有効なインデックスと受け入れ可能なインデックス</A>
<LI><A HREF="#4.4">4.4 &ndash; Cのクロージャ</A>
<LI><A HREF="#4.5">4.5 &ndash; レジストリ</A>
<LI><A HREF="#4.6">4.6 &ndash; Cでのエラー処理</A>
<LI><A HREF="#4.7">4.7 &ndash; Cでのyield処理</A>
<LI><A HREF="#4.8">4.8 &ndash; 関数と型</A>
<LI><A HREF="#4.9">4.9 &ndash; デバッグインタフェース</A>
</UL>
<P>
<LI><A HREF="#5">5 &ndash; 補助ライブラリ</A>
<UL>
<LI><A HREF="#5.1">5.1 &ndash; 関数と型</A>
</UL>
<P>
<LI><A HREF="#6">6 &ndash; 標準ライブラリ</A>
<UL>
<LI><A HREF="#6.1">6.1 &ndash; 基本機能</A>
<LI><A HREF="#6.2">6.2 &ndash; コルーチン操作</A>
<LI><A HREF="#6.3">6.3 &ndash; モジュール</A>
<LI><A HREF="#6.4">6.4 &ndash; 文字列操作</A>
<UL>
<LI><A HREF="#6.4.1">6.4.1 &ndash; パターン</A>
<LI><A HREF="#6.4.2">6.4.2 &ndash; packとunpackの書式文字列</A>
</UL>
<LI><A HREF="#6.5">6.5 &ndash; UTF-8サポート</A>
<LI><A HREF="#6.6">6.6 &ndash; テーブル操作</A>
<LI><A HREF="#6.7">6.7 &ndash; 数学関数</A>
<LI><A HREF="#6.8">6.8 &ndash; 入出力機能</A>
<LI><A HREF="#6.9">6.9 &ndash; OS機能</A>
<LI><A HREF="#6.10">6.10 &ndash; デバッグライブラリ</A>
</UL>
<P>
<LI><A HREF="#7">7 &ndash; スタンドアロンのLua</A>
<P>
<LI><A HREF="#8">8 &ndash; 前バージョンとの非互換な点</A>
<UL>
<LI><A HREF="#8.1">8.1 &ndash; 言語の変更</A>
<LI><A HREF="#8.2">8.2 &ndash; ライブラリの変更</A>
<LI><A HREF="#8.3">8.3 &ndash; APIの変更</A>
</UL>
<P>
<LI><A HREF="#9">9 &ndash; Luaの完全な構文</A>
</UL>

<H2 class="index"><A NAME="index">索引</A></H2>
<TABLE CLASS="menubar" WIDTH="100%">
<TR>
<TD style="vertical-align:top">
<H3><A NAME="functions">Lua の関数</A></H3>
<P>
<A HREF="#6.1">基本</A><BR>
<A HREF="#pdf-_G">_G</A><BR>
<A HREF="#pdf-_VERSION">_VERSION</A><BR>
<A HREF="#pdf-assert">assert</A><BR>
<A HREF="#pdf-collectgarbage">collectgarbage</A><BR>
<A HREF="#pdf-dofile">dofile</A><BR>
<A HREF="#pdf-error">error</A><BR>
<A HREF="#pdf-getmetatable">getmetatable</A><BR>
<A HREF="#pdf-ipairs">ipairs</A><BR>
<A HREF="#pdf-load">load</A><BR>
<A HREF="#pdf-loadfile">loadfile</A><BR>
<A HREF="#pdf-next">next</A><BR>
<A HREF="#pdf-pairs">pairs</A><BR>
<A HREF="#pdf-pcall">pcall</A><BR>
<A HREF="#pdf-print">print</A><BR>
<A HREF="#pdf-rawequal">rawequal</A><BR>
<A HREF="#pdf-rawget">rawget</A><BR>
<A HREF="#pdf-rawlen">rawlen</A><BR>
<A HREF="#pdf-rawset">rawset</A><BR>
<A HREF="#pdf-require">require</A><BR>
<A HREF="#pdf-select">select</A><BR>
<A HREF="#pdf-setmetatable">setmetatable</A><BR>
<A HREF="#pdf-tonumber">tonumber</A><BR>
<A HREF="#pdf-tostring">tostring</A><BR>
<A HREF="#pdf-type">type</A><BR>
<A HREF="#pdf-xpcall">xpcall</A><BR>

<P>
<A HREF="#6.2">コルーチン</A><BR>
<A HREF="#pdf-coroutine.create">coroutine.create</A><BR>
<A HREF="#pdf-coroutine.isyieldable">coroutine.isyieldable</A><BR>
<A HREF="#pdf-coroutine.resume">coroutine.resume</A><BR>
<A HREF="#pdf-coroutine.running">coroutine.running</A><BR>
<A HREF="#pdf-coroutine.status">coroutine.status</A><BR>
<A HREF="#pdf-coroutine.wrap">coroutine.wrap</A><BR>
<A HREF="#pdf-coroutine.yield">coroutine.yield</A><BR>

<P>
<A HREF="#6.10">デバッグ</A><BR>
<A HREF="#pdf-debug.debug">debug.debug</A><BR>
<A HREF="#pdf-debug.gethook">debug.gethook</A><BR>
<A HREF="#pdf-debug.getinfo">debug.getinfo</A><BR>
<A HREF="#pdf-debug.getlocal">debug.getlocal</A><BR>
<A HREF="#pdf-debug.getmetatable">debug.getmetatable</A><BR>
<A HREF="#pdf-debug.getregistry">debug.getregistry</A><BR>
<A HREF="#pdf-debug.getupvalue">debug.getupvalue</A><BR>
<A HREF="#pdf-debug.getuservalue">debug.getuservalue</A><BR>
<A HREF="#pdf-debug.sethook">debug.sethook</A><BR>
<A HREF="#pdf-debug.setlocal">debug.setlocal</A><BR>
<A HREF="#pdf-debug.setmetatable">debug.setmetatable</A><BR>
<A HREF="#pdf-debug.setupvalue">debug.setupvalue</A><BR>
<A HREF="#pdf-debug.setuservalue">debug.setuservalue</A><BR>
<A HREF="#pdf-debug.traceback">debug.traceback</A><BR>
<A HREF="#pdf-debug.upvalueid">debug.upvalueid</A><BR>
<A HREF="#pdf-debug.upvaluejoin">debug.upvaluejoin</A><BR>

<P>
<A HREF="#6.8">入出力</A><BR>
<A HREF="#pdf-io.close">io.close</A><BR>
<A HREF="#pdf-io.flush">io.flush</A><BR>
<A HREF="#pdf-io.input">io.input</A><BR>
<A HREF="#pdf-io.lines">io.lines</A><BR>
<A HREF="#pdf-io.open">io.open</A><BR>
<A HREF="#pdf-io.output">io.output</A><BR>
<A HREF="#pdf-io.popen">io.popen</A><BR>
<A HREF="#pdf-io.read">io.read</A><BR>
<A HREF="#pdf-io.stderr">io.stderr</A><BR>
<A HREF="#pdf-io.stdin">io.stdin</A><BR>
<A HREF="#pdf-io.stdout">io.stdout</A><BR>
<A HREF="#pdf-io.tmpfile">io.tmpfile</A><BR>
<A HREF="#pdf-io.type">io.type</A><BR>
<A HREF="#pdf-io.write">io.write</A><BR>

<A HREF="#pdf-file:close">file:close</A><BR>
<A HREF="#pdf-file:flush">file:flush</A><BR>
<A HREF="#pdf-file:lines">file:lines</A><BR>
<A HREF="#pdf-file:read">file:read</A><BR>
<A HREF="#pdf-file:seek">file:seek</A><BR>
<A HREF="#pdf-file:setvbuf">file:setvbuf</A><BR>
<A HREF="#pdf-file:write">file:write</A><BR>

</TD>
<TD style="vertical-align:top">
<H3>&nbsp;</H3>
<P>
<A HREF="#6.7">数学</A><BR>
<A HREF="#pdf-math.abs">math.abs</A><BR>
<A HREF="#pdf-math.acos">math.acos</A><BR>
<A HREF="#pdf-math.asin">math.asin</A><BR>
<A HREF="#pdf-math.atan">math.atan</A><BR>
<A HREF="#pdf-math.ceil">math.ceil</A><BR>
<A HREF="#pdf-math.cos">math.cos</A><BR>
<A HREF="#pdf-math.deg">math.deg</A><BR>
<A HREF="#pdf-math.exp">math.exp</A><BR>
<A HREF="#pdf-math.floor">math.floor</A><BR>
<A HREF="#pdf-math.fmod">math.fmod</A><BR>
<A HREF="#pdf-math.huge">math.huge</A><BR>
<A HREF="#pdf-math.log">math.log</A><BR>
<A HREF="#pdf-math.max">math.max</A><BR>
<A HREF="#pdf-math.maxinteger">math.maxinteger</A><BR>
<A HREF="#pdf-math.min">math.min</A><BR>
<A HREF="#pdf-math.mininteger">math.mininteger</A><BR>
<A HREF="#pdf-math.modf">math.modf</A><BR>
<A HREF="#pdf-math.pi">math.pi</A><BR>
<A HREF="#pdf-math.rad">math.rad</A><BR>
<A HREF="#pdf-math.random">math.random</A><BR>
<A HREF="#pdf-math.randomseed">math.randomseed</A><BR>
<A HREF="#pdf-math.sin">math.sin</A><BR>
<A HREF="#pdf-math.sqrt">math.sqrt</A><BR>
<A HREF="#pdf-math.tan">math.tan</A><BR>
<A HREF="#pdf-math.tointeger">math.tointeger</A><BR>
<A HREF="#pdf-math.type">math.type</A><BR>
<A HREF="#pdf-math.ult">math.ult</A><BR>

<P>
<A HREF="#6.9">OS</A><BR>
<A HREF="#pdf-os.clock">os.clock</A><BR>
<A HREF="#pdf-os.date">os.date</A><BR>
<A HREF="#pdf-os.difftime">os.difftime</A><BR>
<A HREF="#pdf-os.execute">os.execute</A><BR>
<A HREF="#pdf-os.exit">os.exit</A><BR>
<A HREF="#pdf-os.getenv">os.getenv</A><BR>
<A HREF="#pdf-os.remove">os.remove</A><BR>
<A HREF="#pdf-os.rename">os.rename</A><BR>
<A HREF="#pdf-os.setlocale">os.setlocale</A><BR>
<A HREF="#pdf-os.time">os.time</A><BR>
<A HREF="#pdf-os.tmpname">os.tmpname</A><BR>

<P>
<A HREF="#6.3">パッケージ</A><BR>
<A HREF="#pdf-package.config">package.config</A><BR>
<A HREF="#pdf-package.cpath">package.cpath</A><BR>
<A HREF="#pdf-package.loaded">package.loaded</A><BR>
<A HREF="#pdf-package.loadlib">package.loadlib</A><BR>
<A HREF="#pdf-package.path">package.path</A><BR>
<A HREF="#pdf-package.preload">package.preload</A><BR>
<A HREF="#pdf-package.searchers">package.searchers</A><BR>
<A HREF="#pdf-package.searchpath">package.searchpath</A><BR>

<P>
<A HREF="#6.4">文字列</A><BR>
<A HREF="#pdf-string.byte">string.byte</A><BR>
<A HREF="#pdf-string.char">string.char</A><BR>
<A HREF="#pdf-string.dump">string.dump</A><BR>
<A HREF="#pdf-string.find">string.find</A><BR>
<A HREF="#pdf-string.format">string.format</A><BR>
<A HREF="#pdf-string.gmatch">string.gmatch</A><BR>
<A HREF="#pdf-string.gsub">string.gsub</A><BR>
<A HREF="#pdf-string.len">string.len</A><BR>
<A HREF="#pdf-string.lower">string.lower</A><BR>
<A HREF="#pdf-string.match">string.match</A><BR>
<A HREF="#pdf-string.pack">string.pack</A><BR>
<A HREF="#pdf-string.packsize">string.packsize</A><BR>
<A HREF="#pdf-string.rep">string.rep</A><BR>
<A HREF="#pdf-string.reverse">string.reverse</A><BR>
<A HREF="#pdf-string.sub">string.sub</A><BR>
<A HREF="#pdf-string.unpack">string.unpack</A><BR>
<A HREF="#pdf-string.upper">string.upper</A><BR>

<P>
<A HREF="#6.6">テーブル</A><BR>
<A HREF="#pdf-table.concat">table.concat</A><BR>
<A HREF="#pdf-table.insert">table.insert</A><BR>
<A HREF="#pdf-table.move">table.move</A><BR>
<A HREF="#pdf-table.pack">table.pack</A><BR>
<A HREF="#pdf-table.remove">table.remove</A><BR>
<A HREF="#pdf-table.sort">table.sort</A><BR>
<A HREF="#pdf-table.unpack">table.unpack</A><BR>

<P>
<A HREF="#6.5">UTF-8</A><BR>
<A HREF="#pdf-utf8.char">utf8.char</A><BR>
<A HREF="#pdf-utf8.charpattern">utf8.charpattern</A><BR>
<A HREF="#pdf-utf8.codepoint">utf8.codepoint</A><BR>
<A HREF="#pdf-utf8.codes">utf8.codes</A><BR>
<A HREF="#pdf-utf8.len">utf8.len</A><BR>
<A HREF="#pdf-utf8.offset">utf8.offset</A><BR>

<H3><A NAME="env">環境変数</A></H3>
<P>
<A HREF="#pdf-LUA_CPATH">LUA_CPATH</A><BR>
<A HREF="#pdf-LUA_CPATH_5_3">LUA_CPATH_5_3</A><BR>
<A HREF="#pdf-LUA_INIT">LUA_INIT</A><BR>
<A HREF="#pdf-LUA_INIT_5_3">LUA_INIT_5_3</A><BR>
<A HREF="#pdf-LUA_PATH">LUA_PATH</A><BR>
<A HREF="#pdf-LUA_PATH_5_3">LUA_PATH_5_3</A><BR>

</TD>
<TD style="vertical-align:top">
<H3><A NAME="api">C の API</A></H3>
<P>
<A HREF="#lua_Alloc">lua_Alloc</A><BR>
<A HREF="#lua_CFunction">lua_CFunction</A><BR>
<A HREF="#lua_Debug">lua_Debug</A><BR>
<A HREF="#lua_Hook">lua_Hook</A><BR>
<A HREF="#lua_Integer">lua_Integer</A><BR>
<A HREF="#lua_KContext">lua_KContext</A><BR>
<A HREF="#lua_KFunction">lua_KFunction</A><BR>
<A HREF="#lua_Number">lua_Number</A><BR>
<A HREF="#lua_Reader">lua_Reader</A><BR>
<A HREF="#lua_State">lua_State</A><BR>
<A HREF="#lua_Unsigned">lua_Unsigned</A><BR>
<A HREF="#lua_Writer">lua_Writer</A><BR>

<P>
<A HREF="#lua_absindex">lua_absindex</A><BR>
<A HREF="#lua_arith">lua_arith</A><BR>
<A HREF="#lua_atpanic">lua_atpanic</A><BR>
<A HREF="#lua_call">lua_call</A><BR>
<A HREF="#lua_callk">lua_callk</A><BR>
<A HREF="#lua_checkstack">lua_checkstack</A><BR>
<A HREF="#lua_close">lua_close</A><BR>
<A HREF="#lua_compare">lua_compare</A><BR>
<A HREF="#lua_concat">lua_concat</A><BR>
<A HREF="#lua_copy">lua_copy</A><BR>
<A HREF="#lua_createtable">lua_createtable</A><BR>
<A HREF="#lua_dump">lua_dump</A><BR>
<A HREF="#lua_error">lua_error</A><BR>
<A HREF="#lua_gc">lua_gc</A><BR>
<A HREF="#lua_getallocf">lua_getallocf</A><BR>
<A HREF="#lua_getextraspace">lua_getextraspace</A><BR>
<A HREF="#lua_getfield">lua_getfield</A><BR>
<A HREF="#lua_getglobal">lua_getglobal</A><BR>
<A HREF="#lua_gethook">lua_gethook</A><BR>
<A HREF="#lua_gethookcount">lua_gethookcount</A><BR>
<A HREF="#lua_gethookmask">lua_gethookmask</A><BR>
<A HREF="#lua_geti">lua_geti</A><BR>
<A HREF="#lua_getinfo">lua_getinfo</A><BR>
<A HREF="#lua_getlocal">lua_getlocal</A><BR>
<A HREF="#lua_getmetatable">lua_getmetatable</A><BR>
<A HREF="#lua_getstack">lua_getstack</A><BR>
<A HREF="#lua_gettable">lua_gettable</A><BR>
<A HREF="#lua_gettop">lua_gettop</A><BR>
<A HREF="#lua_getupvalue">lua_getupvalue</A><BR>
<A HREF="#lua_getuservalue">lua_getuservalue</A><BR>
<A HREF="#lua_insert">lua_insert</A><BR>
<A HREF="#lua_isboolean">lua_isboolean</A><BR>
<A HREF="#lua_iscfunction">lua_iscfunction</A><BR>
<A HREF="#lua_isfunction">lua_isfunction</A><BR>
<A HREF="#lua_isinteger">lua_isinteger</A><BR>
<A HREF="#lua_islightuserdata">lua_islightuserdata</A><BR>
<A HREF="#lua_isnil">lua_isnil</A><BR>
<A HREF="#lua_isnone">lua_isnone</A><BR>
<A HREF="#lua_isnoneornil">lua_isnoneornil</A><BR>
<A HREF="#lua_isnumber">lua_isnumber</A><BR>
<A HREF="#lua_isstring">lua_isstring</A><BR>
<A HREF="#lua_istable">lua_istable</A><BR>
<A HREF="#lua_isthread">lua_isthread</A><BR>
<A HREF="#lua_isuserdata">lua_isuserdata</A><BR>
<A HREF="#lua_isyieldable">lua_isyieldable</A><BR>
<A HREF="#lua_len">lua_len</A><BR>
<A HREF="#lua_load">lua_load</A><BR>
<A HREF="#lua_newstate">lua_newstate</A><BR>
<A HREF="#lua_newtable">lua_newtable</A><BR>
<A HREF="#lua_newthread">lua_newthread</A><BR>
<A HREF="#lua_newuserdata">lua_newuserdata</A><BR>
<A HREF="#lua_next">lua_next</A><BR>
<A HREF="#lua_numbertointeger">lua_numbertointeger</A><BR>
<A HREF="#lua_pcall">lua_pcall</A><BR>
<A HREF="#lua_pcallk">lua_pcallk</A><BR>
<A HREF="#lua_pop">lua_pop</A><BR>
<A HREF="#lua_pushboolean">lua_pushboolean</A><BR>
<A HREF="#lua_pushcclosure">lua_pushcclosure</A><BR>
<A HREF="#lua_pushcfunction">lua_pushcfunction</A><BR>
<A HREF="#lua_pushfstring">lua_pushfstring</A><BR>
<A HREF="#lua_pushglobaltable">lua_pushglobaltable</A><BR>
<A HREF="#lua_pushinteger">lua_pushinteger</A><BR>
<A HREF="#lua_pushlightuserdata">lua_pushlightuserdata</A><BR>
<A HREF="#lua_pushliteral">lua_pushliteral</A><BR>
<A HREF="#lua_pushlstring">lua_pushlstring</A><BR>
<A HREF="#lua_pushnil">lua_pushnil</A><BR>
<A HREF="#lua_pushnumber">lua_pushnumber</A><BR>
<A HREF="#lua_pushstring">lua_pushstring</A><BR>
<A HREF="#lua_pushthread">lua_pushthread</A><BR>
<A HREF="#lua_pushvalue">lua_pushvalue</A><BR>
<A HREF="#lua_pushvfstring">lua_pushvfstring</A><BR>
<A HREF="#lua_rawequal">lua_rawequal</A><BR>
<A HREF="#lua_rawget">lua_rawget</A><BR>
<A HREF="#lua_rawgeti">lua_rawgeti</A><BR>
<A HREF="#lua_rawgetp">lua_rawgetp</A><BR>
<A HREF="#lua_rawlen">lua_rawlen</A><BR>
<A HREF="#lua_rawset">lua_rawset</A><BR>
<A HREF="#lua_rawseti">lua_rawseti</A><BR>
<A HREF="#lua_rawsetp">lua_rawsetp</A><BR>
<A HREF="#lua_register">lua_register</A><BR>
<A HREF="#lua_remove">lua_remove</A><BR>
<A HREF="#lua_replace">lua_replace</A><BR>
<A HREF="#lua_resume">lua_resume</A><BR>
<A HREF="#lua_rotate">lua_rotate</A><BR>
<A HREF="#lua_setallocf">lua_setallocf</A><BR>
<A HREF="#lua_setfield">lua_setfield</A><BR>
<A HREF="#lua_setglobal">lua_setglobal</A><BR>
<A HREF="#lua_sethook">lua_sethook</A><BR>
<A HREF="#lua_seti">lua_seti</A><BR>
<A HREF="#lua_setlocal">lua_setlocal</A><BR>
<A HREF="#lua_setmetatable">lua_setmetatable</A><BR>
<A HREF="#lua_settable">lua_settable</A><BR>
<A HREF="#lua_settop">lua_settop</A><BR>
<A HREF="#lua_setupvalue">lua_setupvalue</A><BR>
<A HREF="#lua_setuservalue">lua_setuservalue</A><BR>
<A HREF="#lua_status">lua_status</A><BR>
<A HREF="#lua_stringtonumber">lua_stringtonumber</A><BR>
<A HREF="#lua_toboolean">lua_toboolean</A><BR>
<A HREF="#lua_tocfunction">lua_tocfunction</A><BR>
<A HREF="#lua_tointeger">lua_tointeger</A><BR>
<A HREF="#lua_tointegerx">lua_tointegerx</A><BR>
<A HREF="#lua_tolstring">lua_tolstring</A><BR>
<A HREF="#lua_tonumber">lua_tonumber</A><BR>
<A HREF="#lua_tonumberx">lua_tonumberx</A><BR>
<A HREF="#lua_topointer">lua_topointer</A><BR>
<A HREF="#lua_tostring">lua_tostring</A><BR>
<A HREF="#lua_tothread">lua_tothread</A><BR>
<A HREF="#lua_touserdata">lua_touserdata</A><BR>
<A HREF="#lua_type">lua_type</A><BR>
<A HREF="#lua_typename">lua_typename</A><BR>
<A HREF="#lua_upvalueid">lua_upvalueid</A><BR>
<A HREF="#lua_upvalueindex">lua_upvalueindex</A><BR>
<A HREF="#lua_upvaluejoin">lua_upvaluejoin</A><BR>
<A HREF="#lua_version">lua_version</A><BR>
<A HREF="#lua_xmove">lua_xmove</A><BR>
<A HREF="#lua_yield">lua_yield</A><BR>
<A HREF="#lua_yieldk">lua_yieldk</A><BR>

</TD>
<TD style="vertical-align:top">
<H3><A NAME="auxlib">補助ライブラリ</A></H3>
<P>
<A HREF="#luaL_Buffer">luaL_Buffer</A><BR>
<A HREF="#luaL_Reg">luaL_Reg</A><BR>
<A HREF="#luaL_Stream">luaL_Stream</A><BR>

<P>
<A HREF="#luaL_addchar">luaL_addchar</A><BR>
<A HREF="#luaL_addlstring">luaL_addlstring</A><BR>
<A HREF="#luaL_addsize">luaL_addsize</A><BR>
<A HREF="#luaL_addstring">luaL_addstring</A><BR>
<A HREF="#luaL_addvalue">luaL_addvalue</A><BR>
<A HREF="#luaL_argcheck">luaL_argcheck</A><BR>
<A HREF="#luaL_argerror">luaL_argerror</A><BR>
<A HREF="#luaL_buffinit">luaL_buffinit</A><BR>
<A HREF="#luaL_buffinitsize">luaL_buffinitsize</A><BR>
<A HREF="#luaL_callmeta">luaL_callmeta</A><BR>
<A HREF="#luaL_checkany">luaL_checkany</A><BR>
<A HREF="#luaL_checkinteger">luaL_checkinteger</A><BR>
<A HREF="#luaL_checklstring">luaL_checklstring</A><BR>
<A HREF="#luaL_checknumber">luaL_checknumber</A><BR>
<A HREF="#luaL_checkoption">luaL_checkoption</A><BR>
<A HREF="#luaL_checkstack">luaL_checkstack</A><BR>
<A HREF="#luaL_checkstring">luaL_checkstring</A><BR>
<A HREF="#luaL_checktype">luaL_checktype</A><BR>
<A HREF="#luaL_checkudata">luaL_checkudata</A><BR>
<A HREF="#luaL_checkversion">luaL_checkversion</A><BR>
<A HREF="#luaL_dofile">luaL_dofile</A><BR>
<A HREF="#luaL_dostring">luaL_dostring</A><BR>
<A HREF="#luaL_error">luaL_error</A><BR>
<A HREF="#luaL_execresult">luaL_execresult</A><BR>
<A HREF="#luaL_fileresult">luaL_fileresult</A><BR>
<A HREF="#luaL_getmetafield">luaL_getmetafield</A><BR>
<A HREF="#luaL_getmetatable">luaL_getmetatable</A><BR>
<A HREF="#luaL_getsubtable">luaL_getsubtable</A><BR>
<A HREF="#luaL_gsub">luaL_gsub</A><BR>
<A HREF="#luaL_len">luaL_len</A><BR>
<A HREF="#luaL_loadbuffer">luaL_loadbuffer</A><BR>
<A HREF="#luaL_loadbufferx">luaL_loadbufferx</A><BR>
<A HREF="#luaL_loadfile">luaL_loadfile</A><BR>
<A HREF="#luaL_loadfilex">luaL_loadfilex</A><BR>
<A HREF="#luaL_loadstring">luaL_loadstring</A><BR>
<A HREF="#luaL_newlib">luaL_newlib</A><BR>
<A HREF="#luaL_newlibtable">luaL_newlibtable</A><BR>
<A HREF="#luaL_newmetatable">luaL_newmetatable</A><BR>
<A HREF="#luaL_newstate">luaL_newstate</A><BR>
<A HREF="#luaL_openlibs">luaL_openlibs</A><BR>
<A HREF="#luaL_optinteger">luaL_optinteger</A><BR>
<A HREF="#luaL_optlstring">luaL_optlstring</A><BR>
<A HREF="#luaL_optnumber">luaL_optnumber</A><BR>
<A HREF="#luaL_optstring">luaL_optstring</A><BR>
<A HREF="#luaL_prepbuffer">luaL_prepbuffer</A><BR>
<A HREF="#luaL_prepbuffsize">luaL_prepbuffsize</A><BR>
<A HREF="#luaL_pushresult">luaL_pushresult</A><BR>
<A HREF="#luaL_pushresultsize">luaL_pushresultsize</A><BR>
<A HREF="#luaL_ref">luaL_ref</A><BR>
<A HREF="#luaL_requiref">luaL_requiref</A><BR>
<A HREF="#luaL_setfuncs">luaL_setfuncs</A><BR>
<A HREF="#luaL_setmetatable">luaL_setmetatable</A><BR>
<A HREF="#luaL_testudata">luaL_testudata</A><BR>
<A HREF="#luaL_tolstring">luaL_tolstring</A><BR>
<A HREF="#luaL_traceback">luaL_traceback</A><BR>
<A HREF="#luaL_typename">luaL_typename</A><BR>
<A HREF="#luaL_unref">luaL_unref</A><BR>
<A HREF="#luaL_where">luaL_where</A><BR>

<H3><A NAME="library">標準ライブラリ</A></H3>
<P>
<A HREF="#pdf-luaopen_base">luaopen_base</A><BR>
<A HREF="#pdf-luaopen_coroutine">luaopen_coroutine</A><BR>
<A HREF="#pdf-luaopen_debug">luaopen_debug</A><BR>
<A HREF="#pdf-luaopen_io">luaopen_io</A><BR>
<A HREF="#pdf-luaopen_math">luaopen_math</A><BR>
<A HREF="#pdf-luaopen_os">luaopen_os</A><BR>
<A HREF="#pdf-luaopen_package">luaopen_package</A><BR>
<A HREF="#pdf-luaopen_string">luaopen_string</A><BR>
<A HREF="#pdf-luaopen_table">luaopen_table</A><BR>
<A HREF="#pdf-luaopen_utf8">luaopen_utf8</A><BR>

<H3><A NAME="constants">定数</A></H3>
<P>
<A HREF="#pdf-LUA_ERRERR">LUA_ERRERR</A><BR>
<A HREF="#pdf-LUA_ERRFILE">LUA_ERRFILE</A><BR>
<A HREF="#pdf-LUA_ERRGCMM">LUA_ERRGCMM</A><BR>
<A HREF="#pdf-LUA_ERRMEM">LUA_ERRMEM</A><BR>
<A HREF="#pdf-LUA_ERRRUN">LUA_ERRRUN</A><BR>
<A HREF="#pdf-LUA_ERRSYNTAX">LUA_ERRSYNTAX</A><BR>
<A HREF="#pdf-LUA_HOOKCALL">LUA_HOOKCALL</A><BR>
<A HREF="#pdf-LUA_HOOKCOUNT">LUA_HOOKCOUNT</A><BR>
<A HREF="#pdf-LUA_HOOKLINE">LUA_HOOKLINE</A><BR>
<A HREF="#pdf-LUA_HOOKRET">LUA_HOOKRET</A><BR>
<A HREF="#pdf-LUA_HOOKTAILCALL">LUA_HOOKTAILCALL</A><BR>
<A HREF="#pdf-LUA_MASKCALL">LUA_MASKCALL</A><BR>
<A HREF="#pdf-LUA_MASKCOUNT">LUA_MASKCOUNT</A><BR>
<A HREF="#pdf-LUA_MASKLINE">LUA_MASKLINE</A><BR>
<A HREF="#pdf-LUA_MASKRET">LUA_MASKRET</A><BR>
<A HREF="#pdf-LUA_MAXINTEGER">LUA_MAXINTEGER</A><BR>
<A HREF="#pdf-LUA_MININTEGER">LUA_MININTEGER</A><BR>
<A HREF="#pdf-LUA_MINSTACK">LUA_MINSTACK</A><BR>
<A HREF="#pdf-LUA_MULTRET">LUA_MULTRET</A><BR>
<A HREF="#pdf-LUA_NOREF">LUA_NOREF</A><BR>
<A HREF="#pdf-LUA_OK">LUA_OK</A><BR>
<A HREF="#pdf-LUA_OPADD">LUA_OPADD</A><BR>
<A HREF="#pdf-LUA_OPBAND">LUA_OPBAND</A><BR>
<A HREF="#pdf-LUA_OPBNOT">LUA_OPBNOT</A><BR>
<A HREF="#pdf-LUA_OPBOR">LUA_OPBOR</A><BR>
<A HREF="#pdf-LUA_OPBXOR">LUA_OPBXOR</A><BR>
<A HREF="#pdf-LUA_OPDIV">LUA_OPDIV</A><BR>
<A HREF="#pdf-LUA_OPEQ">LUA_OPEQ</A><BR>
<A HREF="#pdf-LUA_OPIDIV">LUA_OPIDIV</A><BR>
<A HREF="#pdf-LUA_OPLE">LUA_OPLE</A><BR>
<A HREF="#pdf-LUA_OPLT">LUA_OPLT</A><BR>
<A HREF="#pdf-LUA_OPMOD">LUA_OPMOD</A><BR>
<A HREF="#pdf-LUA_OPMUL">LUA_OPMUL</A><BR>
<A HREF="#pdf-LUA_OPPOW">LUA_OPPOW</A><BR>
<A HREF="#pdf-LUA_OPSHL">LUA_OPSHL</A><BR>
<A HREF="#pdf-LUA_OPSHR">LUA_OPSHR</A><BR>
<A HREF="#pdf-LUA_OPSUB">LUA_OPSUB</A><BR>
<A HREF="#pdf-LUA_OPUNM">LUA_OPUNM</A><BR>
<A HREF="#pdf-LUA_REFNIL">LUA_REFNIL</A><BR>
<A HREF="#pdf-LUA_REGISTRYINDEX">LUA_REGISTRYINDEX</A><BR>
<A HREF="#pdf-LUA_RIDX_GLOBALS">LUA_RIDX_GLOBALS</A><BR>
<A HREF="#pdf-LUA_RIDX_MAINTHREAD">LUA_RIDX_MAINTHREAD</A><BR>
<A HREF="#pdf-LUA_TBOOLEAN">LUA_TBOOLEAN</A><BR>
<A HREF="#pdf-LUA_TFUNCTION">LUA_TFUNCTION</A><BR>
<A HREF="#pdf-LUA_TLIGHTUSERDATA">LUA_TLIGHTUSERDATA</A><BR>
<A HREF="#pdf-LUA_TNIL">LUA_TNIL</A><BR>
<A HREF="#pdf-LUA_TNONE">LUA_TNONE</A><BR>
<A HREF="#pdf-LUA_TNUMBER">LUA_TNUMBER</A><BR>
<A HREF="#pdf-LUA_TSTRING">LUA_TSTRING</A><BR>
<A HREF="#pdf-LUA_TTABLE">LUA_TTABLE</A><BR>
<A HREF="#pdf-LUA_TTHREAD">LUA_TTHREAD</A><BR>
<A HREF="#pdf-LUA_TUSERDATA">LUA_TUSERDATA</A><BR>
<A HREF="#pdf-LUA_USE_APICHECK">LUA_USE_APICHECK</A><BR>
<A HREF="#pdf-LUA_YIELD">LUA_YIELD</A><BR>
<A HREF="#pdf-LUAL_BUFFERSIZE">LUAL_BUFFERSIZE</A><BR>

</TD>
</TR>
</TABLE>

<P CLASS="footer">
Last update:
Wed Jun 17 08:30:41 BRT 2015
</P>
<!--
Last change: revised for Lua 5.3.1
-->
</div>

<a name="start"></a>
<div class="body">
<H1>
Lua 5.3 リファレンスマニュアル
</H1>

<P>
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes

<P>
<SMALL>
Copyright &copy; 2015 Lua.org, PUC-Rio.
Freely available under the terms of the
<a href="http://www.lua.org/license.html">Lua license</a>.
</SMALL>

<DIV CLASS="menubar">
<A HREF="#contents">目次</A>
&middot;
<A HREF="#index">索引</A>
&middot;
<A HREF="http://www.lua.org/manual/">他のバージョン</A>
</DIV>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.151 2015/06/10 21:08:57 roberto Exp $ -->




<h1>0 &ndash; <a name="0">日本語訳について</a></h1>

<p>
この文章は
<a href="http://www.lua.org/manual/5.3/">Lua 5.3 Reference Manual</a>
を原著者に無断で日本語に訳した非公式のLua 5.3リファレンスマニュアルです。

<h1>1 &ndash; <a name="1">序文</a></h1>

<p>
Luaは拡張プログラミング言語です。
データ記述機能を持ち、汎用的な手続き型プログラミングをサポートするよう設計されています。
またオブジェクト指向プログラミング、関数型プログラミング、データ駆動型プログラミングもサポートしています。
Luaはパワフルで軽量な組み込み型のスクリプト言語として、そういったものが必要なあらゆるプログラムで使われることを意図しています。
Luaはライブラリとして実装されており、<em>クリーンなC</em>、つまり標準規格のCとC++の共通のサブセットで書かれています。


<p>
拡張言語であるため、Luaには「メイン」プログラムの概念がありません。
ホストクライアント
(<em>エンベッディングプログラム</em>または単に<em>ホスト</em>と呼ばれることもあります)
に<em>組み込まれて</em>動作するだけです。
ホストプログラムからLuaのコード片を実行する関数を呼んだり、Luaの変数を読み書きしたり、Luaのコードから呼ばれるCの関数を登録したりできます。
Cの関数を用いることで様々な領域に幅広く対応することができ、同じ構文的な枠組みを共有しながらもカスタマイズしたプログラミング言語を作ることができます。
Luaの配布物には <code>lua</code> という名前のサンプルホストプログラムが含まれています。
これはLuaのライブラリを使用した完全なスタンドアロンのLuaインタプリタで、対話的な用途やバッチ処理のために使うことができます。


<p>
ライセンスにも述べられているように、Luaはフリーソフトウェアであり、慣例により無保証で提供されます。
このマニュアルで述べられている実装はLuaの公式ウェブサイト
<code>www.lua.org</code>
から入手可能です。


<p>
他のあらゆるリファレンスマニュアル同様、この文章も無味乾燥です。
Luaの設計に関する議論はLuaのウェブサイトで入手可能な技術論文を参照してください。
Luaによるプログラミングの詳細な入門にはRobertoの著書
<em>Programming in Lua</em> を参照してください。



<h1>2 &ndash; <a name="2">基本コンセプト</a></h1>

<p>
この節ではLuaの基本コンセプトについて説明します。



<h2>2.1 &ndash; <a name="2.1">値と型</a></h2>

<p>
Luaは<em>動的型付き言語</em>です。
つまり変数は型を持たず、値のみが型を持ちます。
Luaには型定義がありません。
すべての値はそれ自身が型を保持しています。


<p>
Luaの値はすべて<em>ファーストクラスの値</em>です。
つまりすべての値は変数に格納することができ、他の関数に渡すことができ、戻り値として返すことができます。


<p>
Luaには8つの基本型があります。
<ul>
<li><em>nil</em>
<li><em>ブーリアン</em>
<li><em>数値</em>
<li><em>文字列</em>
<li><em>関数</em>
<li><em>ユーザーデータ</em>
<li><em>スレッド</em>
<li><em>テーブル</em>
</ul>
<p>
<em>nil</em>型にはひとつの値 <b>nil</b> だけがあります。
その主な性質は他のいかなる値とも異なることであり、通常、役に立つ値がないことを表します。
<em>ブーリアン</em>型にはふたつの値 <b>false</b> と <b>true</b> があります。
条件判断においては <b>nil</b> と <b>false</b> は両方とも偽であり、それ以外の値はすべて真です。
<em>数値</em>型は整数と実数 (浮動小数点数) の両方を表します。
<em>文字列</em>型は不変のバイト列を表します。

Luaは8ビットクリーンです。
つまり文字列は任意の8ビット値
(ゼロ ('<code>\0</code>') を含む)
を持つことができます。
またLuaはエンコーディングについて関知しません。
つまり文字列の内容について何の仮定も設けていません。


<p>
<em>数値</em>型には2種類の内部表現 (あるいは2つのサブタイプ) があります。
ひとつは<em>整数</em>で、もうひとつは<em>浮動小数点数</em>です。
それぞれの表現がいつ使われるかについては明確なルールがありますが、両者は必要に応じて自動的に変換されます
(<a href="#3.4.3">&sect;3.4.3</a> を参照)。
そのためプログラマは整数と浮動小数点数の違いをほとんど無視することもできますし、各数値の表現について完全に制御を握ることもできます。
標準のLuaでは64ビットの整数と倍精度 (64ビット) の浮動小数点数を使用しますが、
32ビットの整数や単精度 (32ビット) の浮動小数点数を使用するようにLuaをコンパイルすることもできます。
整数と浮動小数点数の両方に32ビットを用いるオプションは、小さなマシンや組み込みシステムでは特に魅力的でしょう。
(ファイル <code>luaconf.h</code> のマクロ <code>LUA_32BITS</code> を参照してください。)


<p>
LuaはLuaで書かれた関数もCで書かれた関数も呼ぶ (そして操作する) ことができます
(<a href="#3.4.10">&sect;3.4.10</a> を参照)。
これらはどちらも<em>関数</em>型として表されます。


<p>
<em>ユーザーデータ</em>型は任意のCのデータをLuaの変数に格納するために用意されています。
ユーザーデータの値は生のメモリブロックを表します。
ユーザーデータには2種類あります。
<em>フルユーザーデータ</em>はLuaによって管理されるメモリブロックを持つオブジェクトで、<em>ライトユーザーデータ</em>は単なるCのポインタ値です。
ユーザーデータには等値比較以外の定義済みの演算はありません。
<em>メタテーブル</em>を使うとフルユーザーデータの値に対してプログラマが演算を定義することができます
(<a href="#2.4">&sect;2.4</a> を参照)。
ユーザーデータの値はLuaで作成したり変更することはできず、CのAPIを使ってのみ可能です。
これによりホストプログラムによって所有されるデータの整合性が保証されます。


<p>
<em>スレッド</em>型は独立した実行のスレッドを表し、コルーチンを実装するために使われます
(<a href="#2.6">&sect;2.6</a> を参照)。
LuaのスレッドはOSのスレッドとは無関係です。
スレッドがネイティブにサポートされていないシステムも含め、すべてのシステム上でLuaはコルーチンをサポートしています。


<p>
<em>テーブル</em>型は連想配列を実装しています。
つまり数値だけでなく <b>nil</b>
とNaN以外のあらゆるLuaの値をインデックスとして使える配列です。
(<em>NaN</em>、すなわちNot a Numberとは、 <code>0/0</code>
のような未定義または表現不可能な数値演算の結果を表すために使われる特殊な値です。)
テーブルは<em>異種混合</em>できます。
つまりあらゆる型の値 (<b>nil</b> を除く) を格納することができます。
<b>nil</b> 値を持つキーはテーブルに格納されているとみなされません。
逆に言うと、テーブルに格納されていないキーには <b>nil</b> 値が関連付けられています。


<p>
テーブルはLuaで唯一のデータを構造化する仕組みです。
通常の配列のほか、シーケンス、記号表、集合、レコード、グラフ、ツリーなどを表現するために使うことができます。
レコードを表現する場合、Luaではフィールド名をインデックスとして使います。
この表現をサポートするため、 <code>a.name</code> が
<code>a["name"]</code> のシンタックスシュガーとして用意されています。
Luaにはテーブルを作成する便利な方法がいくつかあります
(<a href="#3.4.9">&sect;3.4.9</a> を参照)。


<p>
すべての正の数値キーの集合が {1..<em>n</em>}
であるようなテーブルを<em>シーケンス</em>と言います。
ただし<em>n</em>は何らかの負でない整数であり、そのシーケンスの長さと言います
(<a href="#3.4.7">&sect;3.4.7</a> を参照)。


<p>
インデックスと同様、テーブルフィールドの値にも任意の型を格納できます。
特に、関数がファーストクラスの値であるため、テーブルフィールドには関数を格納できます。
そのためテーブルは<em>メソッド</em>を持つことができます
(<a href="#3.4.11">&sect;3.4.11</a> を参照)。


<p>
テーブルのインデックス検索はLuaの生の等値比較の定義に従います。
<code>i</code> と <code>j</code> が生の等値
(つまりメタメソッドなしで等しい) である場合に限り、式
<code>a[i]</code> と <code>a[j]</code> は同じテーブル要素を指します。
特に、小数点以下の端数のない浮動小数点数は、対応する整数と等値です
(例えば <code>1.0 == 1</code>)。
曖昧さを避けるため、端数のない浮動小数点数をキーとして使用すると、対応する整数に変換されます。
例えば、
<code>a[2.0] = true</code>
と書くと、テーブルに挿入される実際のキーは整数の <code>2</code> になります。
(それに対して、 2 と "<code>2</code>"
は異なる値なので、異なるテーブルエントリを指します。)


<p>
テーブル、関数、スレッド、および (フル) ユーザーデータの値は<em>オブジェクト</em>です。
変数はこれらの値を実際には<em>格納</em>せず、それらを<em>参照</em>するだけです。
代入、引数渡し、関数の戻り値の受け取りは、常にそれらの参照を扱います。
これらの操作はいかなる意味でも値のコピーを行いません。


<p>
ライブラリ関数 <a href="#pdf-type"><code>type</code></a>
は指定された値の型を表す文字列を返します
(<a href="#6.1">&sect;6.1</a> を参照)。





<h2>2.2 &ndash; <a name="2.2">環境とグローバル環境</a></h2>

<p>
<a href="#3.2">&sect;3.2</a> および <a href="#3.3.3">&sect;3.3.3</a>
で述べるように、自由名 <code>var</code> への参照はすべて構文的に <code>_ENV.var</code> に変換されます
(自由名とはいかなる宣言にも束縛されていない名前のことです)。
またすべてのチャンクは <code>_ENV</code>
という名前の外部ローカル変数のスコープ内でコンパイルされます
(<a href="#3.3.2">&sect;3.3.2</a> を参照)。
そのため <code>_ENV</code> 自身はチャンク内で自由名となることはありません。


<p>
この外部変数 <code>_ENV</code> の存在と自由名の変換にもかかわらず、
<code>_ENV</code> は完全に正規の名前です。
例えばそのような名前の新しい変数や引数を定義しても構いません。
自由名への参照はすべて、Luaの通常の可視性ルール
(<a href="#3.5">&sect;3.5</a> を参照)
に従い、プログラム内のその地点で可視な <code>_ENV</code> が使われます。


<p>
<code>_ENV</code> の値として使われるテーブルは<em>環境</em>と言います。


<p>
Luaには<em>グローバル環境</em>と呼ばれる特別な環境があります。
この値はCのレジストリの特別なインデックスに配置されています
(<a href="#4.5">&sect;4.5</a> を参照)。
Luaでは、グローバル変数 <a href="#pdf-_G"><code>_G</code></a>
がこの値で初期化されます。
(<a href="#pdf-_G"><code>_G</code></a> は内部的に使われることはありません。)


<p>
チャンクがロードされるとき、
その <code>_ENV</code> 上位値のデフォルト値はグローバル環境になります
(<a href="#pdf-load"><code>load</code></a> を参照)。
そのため、デフォルトではLuaコード内の自由名はグローバル環境のエントリを参照します
(それらは<em>グローバル変数</em>と言います)。
さらに、すべての標準ライブラリはグローバル環境にロードされ、その関数のいくつかはその環境を操作します。
<a href="#pdf-load"><code>load</code></a>
(または <a href="#pdf-loadfile"><code>loadfile</code></a>)
を使うとチャンクを異なる環境にロードすることができます。
(Cではチャンクをロードしてからその最初の上位値の値を変更する必要があります。)





<h2>2.3 &ndash; <a name="2.3">エラー処理</a></h2>

<p>
Luaは組み込み型の拡張言語なので、Luaのすべての活動はホストプログラム内のCのコードがLuaのライブラリ関数を呼ぶことから始まります。
(スタンドアロンのLuaを使うときは
<code>lua</code> アプリケーションがホストプログラムです。)
Luaのチャンクのコンパイル中や実行中にエラーが発生すると、制御がホストに戻り、適切な処置を取ることができます
(例えばエラーメッセージを表示するなど)。


<p>
Luaのコードからは <a href="#pdf-error"><code>error</code></a>
関数を呼ぶことでエラーを明示的に発生できます。
Luaでエラーをキャッチする必要がある場合は、
<a href="#pdf-pcall"><code>pcall</code></a>
または
<a href="#pdf-xpcall"><code>xpcall</code></a>
を使って<em>保護モード</em>で関数を呼びます。


<p>
エラーが発生すると、<em>エラーオブジェクト</em>
(<em>エラーメッセージ</em>とも言います)
がそのエラーに関する情報とともに伝播されます。
Lua自身からエラーが発生するときは、エラーオブジェクトは必ず文字列ですが、プログラムからは任意の値をエラーオブジェクトとしてエラーを発生させることができます。
それらのエラーオブジェクトをどう扱うかは、そのLuaのプログラムやホスト次第です。


<p>
<a href="#pdf-xpcall"><code>xpcall</code></a> や
<a href="#lua_pcall"><code>lua_pcall</code></a> を使うと、エラーが発生した場合に呼ばれる<em>メッセージハンドラ</em>を指定できます。
この関数は、元のエラーメッセージを受け取って新しいエラーメッセージを返します。
メッセージハンドラはエラーでスタックが巻き戻される前に呼ばれるので、エラーに関する情報をより多く集めることができます。
例えばスタックを調査してスタックトレースを作成するなどです。
このメッセージハンドラは、保護された呼び出しによって保護された状態のまま呼ばれるので、メッセージハンドラ内でエラーが発生すると、そのメッセージハンドラが再度呼ばれます。
あまりに長くこれが繰り返された場合は、あきらめて適当なメッセージが返されます。





<h2>2.4 &ndash; <a name="2.4">メタテーブルとメタメソッド</a></h2>

<p>
Luaの値はすべて<em>メタテーブル</em>を持つことができます。
<em>メタテーブル</em>は通常のLuaのテーブルですが、いくつかの特別な演算に対する、その値の動作を定義します。
メタテーブルの特定のフィールドを設定すると、値に対する演算の動作をいくつかの面で変更できます。
例えば、数値でない値を加算すると、その値のメタテーブルの "<code>__add</code>"
フィールドに格納されている関数が調べられます。
もしあれば、加算を実行するためにその関数が呼ばれます。


<p>
メタテーブルのキーは<em>イベント</em>の名前から取られています。
対応する値は<em>メタメソッド</em>と言います。
先程の例では <code>"add"</code>
がイベントで、加算を実行する関数がメタメソッドです。


<p>
<a href="#pdf-getmetatable"><code>getmetatable</code></a>
関数を使うと任意の値のメタテーブルを検索することができます。


<p>
<a href="#pdf-setmetatable"><code>setmetatable</code></a>
関数を使うとテーブルのメタテーブルを変更できます。
それ以外の型のメタテーブルをLuaのコードから変更することはできません
(デバッグライブラリ (<a href="#6.10">&sect;6.10</a>) を使った場合を除く)。
そのためにはCのAPIを使う必要があります。


<p>
テーブルとフルユーザーデータは個々に独立したメタテーブルを持ちます
(複数のテーブルやユーザーデータの間で、同じメタテーブルを共有することもできます)。
それ以外の型の値は、型ごとにひとつのメタテーブルを共有します。
つまり、すべての数値に対してひとつのメタテーブルがあり、すべての文字列に対してひとつのメタテーブルがあり、以下同様です。
デフォルトでは値はメタテーブルを持ちません。
しかし文字列ライブラリによって文字列型に対するメタテーブルが設定されます
(<a href="#6.4">&sect;6.4</a> を参照)。


<p>
メタテーブルを使うと、算術演算、ビット演算、順序比較、連結、長さ演算、呼び出し、インデックス検索において、オブジェクトがどのように振る舞うかを制御できます。
またユーザーデータやテーブルがガベージコレクタに回収されたときに呼ばれる関数も定義できます
(<a href="#2.5">&sect;2.5</a>)。


<p>
メタテーブルによって制御されるイベントの詳細な一覧を以下に示します。
それぞれの演算は対応するイベント名で識別されます。
それぞれのイベントに対するキーは、その名前の前に2個のアンダースコア
'<code>__</code>' を付けた文字列です。
例えば "add" 演算に対するキーは文字列 "<code>__add</code>" です。
メタメソッドに対する検索は常に生であることに注意してください。
つまりメタメソッドへのアクセスによって他のメタメソッドが呼ばれることはありません。


<p>
単項演算子 (反数、長さ、ビット否定)
の場合、メタメソッドには第1引数と同じ値の第2引数がダミーで渡されます。
この余分な引数は
(これらの演算子を二項演算子のように動作させることによって)
Luaの内部構造を単純化するためだけのものであり、将来のバージョンでは削除される可能性があります。
(ほとんどの場合、この余分な引数は無意味です。)



<ul>

<li><b>"add": </b>
<code>+</code> 演算。

加算のいずれかの引数が数値
(または数値に変換可能な文字列)
でなければ、メタメソッドの呼び出しが試みられます。
まず第1引数が調べられます (それが有効な場合であっても)。
それが "<code>__add</code>"
イベントのメタメソッドを定義していなければ、第2引数が調べられます。
メタメソッドが見つかれば、そのメタメソッドにその2つの引数が渡され、その呼び出しの戻り値
(1個の値に調節されます) が演算の結果になります。
メタメソッドが見つからなければエラーが発生します。
</li>

<li><b>"sub": </b>
<code>-</code> 演算。

"add" 演算と同様の動作をします。
</li>

<li><b>"mul": </b>
<code>*</code> 演算。

"add" 演算と同様の動作をします。
</li>

<li><b>"div": </b>
<code>/</code> 演算。

"add" 演算と同様の動作をします。
</li>

<li><b>"mod": </b>
<code>%</code> 演算。

"add" 演算と同様の動作をします。
</li>

<li><b>"pow": </b>
<code>^</code> (累乗) 演算。

"add" 演算と同様の動作をします。
</li>

<li><b>"unm": </b>
<code>-</code> (単項マイナス) 演算。

"add" 演算と同様の動作をします。
</li>

<li><b>"idiv": </b>
<code>//</code> (切り捨て除算) 演算。

"add" 演算と同様の動作をします。
</li>

<li><b>"band": </b>
<code>&amp;</code> (ビットごとの論理積) 演算。

"add" 演算と同様の動作をしますが、メタメソッドが試みられるのはいずれかの引数が整数でなく、整数に変換可能な値でもない場合です
(<a href="#3.4.3">&sect;3.4.3</a> を参照)。
</li>

<li><b>"bor": </b>
<code>|</code> (ビットごとの論理和) 演算。

"band" 演算と同様の動作をします。
</li>

<li><b>"bxor": </b>
<code>~</code> (ビットごとの排他的論理和) 演算。

"band" 演算と同様の動作をします。
</li>

<li><b>"bnot": </b>
<code>~</code> (ビットごとの単項否定) 演算。

"band" 演算と同様の動作をします。
</li>

<li><b>"shl": </b>
<code>&lt;&lt;</code> (ビットごとの左シフト) 演算。

"band" 演算と同様の動作をします。
</li>

<li><b>"shr": </b>
<code>&gt;&gt;</code> (ビットごとの右シフト) 演算。

"band" 演算と同様の動作をします。
</li>

<li><b>"concat": </b>
<code>..</code> (連結) 演算。

"add" 演算と同様の動作をしますが、メタメソッドが試みられるのはいずれかの引数が文字列でも数値でもない場合です
(数値は常に文字列に変換可能です)
</li>

<li><b>"len": </b>
<code>#</code> (長さ) 演算。

オブジェクトが文字列でなければメタメソッドが試みられます。
メタメソッドがあれば、そのメタメソッドにそのオブジェクトが引数として渡され、その呼び出しの戻り値
(常に1個の値に調節されます) が演算の結果になります。
メタメソッドがなく、オブジェクトがテーブルであれば、テーブルの長さ演算が使われます
(<a href="#3.4.7">&sect;3.4.7</a> を参照)。
それ以外の場合はエラーが発生します。
</li>

<li><b>"eq": </b>
<code>==</code> (等値比較) 演算。

"add" 演算と同様の動作をしますが、メタメソッドが試みられるのは比較する値が両方ともテーブルであるか両方ともフルユーザーデータであり、それらが生で等しくない場合です。
呼び出しの結果は常にブーリアンに変換されます。
</li>

<li><b>"lt": </b>
<code>&lt;</code> (より小さい) 演算。

"add" と同様の動作をしますが、メタメソッドが試みられるのは比較する値が両方とも数値でなく両方とも文字列でない場合です。
呼び出しの結果は常にブーリアンに変換されます。
</li>

<li><b>"le": </b>
<code>&lt;=</code> (小さいまたは等しい) 演算。

他の演算と異なり、小さいまたは等しい演算は2種類のイベントを用います。
まず "lt" 演算と同様に、両方の引数の "<code>__le</code>" メタメソッドが検索されます。
それが見つからなければ、
<code>a &lt;= b</code> は <code>not (b &lt; a)</code>
と同等であるという仮定によって
"<code>__lt</code>" イベントが試みられます。
他の比較演算同様、結果は常にブーリアンです。
("<code>__lt</code>" イベントのこの使われ方は将来のバージョンでは削除される可能性があります。
また、本当の "<code>__le</code>" メタメソッドよりも性能的に不利です。)
</li>

<li><b>"index": </b>
インデックス付きアクセス <code>table[key]</code>。

このイベントは
<code>table</code> がテーブルでないか、
<code>table</code> に <code>key</code> が存在しない場合に発生します。
メタメソッドは <code>table</code> に対して検索されます。


<p>
このイベントのメタメソッドは、メタメソッドという名前にもかかわらず、テーブルであっても構いません。
メタメソッドが関数であれば、
<code>table</code> と <code>key</code> を引数としてその関数が呼ばれます。
メタメソッドがテーブルであれば、そのテーブルを
<code>key</code> で検索した結果が最終結果になります。
(この検索は生ではなく正規のものであり、さらなるメタメソッドが呼ばれる場合があります。)
</li>

<li><b>"newindex": </b>
インデックス付き代入 <code>table[key] = value</code>。

indexイベント同様、このイベントは <code>table</code> がテーブルでないか、
<code>table</code> に <code>key</code> が存在しない場合に発生します。
メタメソッドは <code>table</code> に対して検索されます。


<p>
indexイベント同様、このイベントのメタメソッドは関数とテーブルのどちらでも構いません。
メタメソッドが関数であれば、
<code>table</code>、
<code>key</code>、
<code>value</code>
を引数としてその関数が呼ばれます。
メタメソッドがテーブルであれば、そのテーブルに対して同じ
<code>key</code> と <code>value</code> でインデックス付き代入を行います。
(この代入は生ではなく正規のものであり、さらなるメタメソッドが呼ばれる場合があります。)


<p>
"newindex" メタメソッドが存在する場合、本来の代入は実行されません
(もし必要であれば、メタメソッド内で
<a href="#pdf-rawset"><code>rawset</code></a>
を呼んで自分で代入を実行してください。)
</li>

<li><b>"call": </b>
呼び出し演算 <code>func(args)</code>。

このイベントは関数でない値を呼ぼうとしたときに発生します
(つまり <code>func</code> が関数でない場合です)。
メタメソッドは <code>func</code> に対して検索されます。
もしあれば、そのメタメソッドが呼ばれます。
そのとき第1引数に <code>func</code> が渡され、第2引数以降に元の呼び出しの引数
(<code>args</code>) が渡されます。
</li>

</ul>

<p>
テーブルをオブジェクトのメタテーブルとして設定する前に必要なすべてのメタメソッドをそのテーブルに追加しておくのは良い習慣です。
特に "<code>__gc</code>" メタメソッドはこの順序に従った場合に限り動作します
(<a href="#2.5.1">&sect;2.5.1</a> を参照)。





<h2>2.5 &ndash; <a name="2.5">ガベージコレクション</a></h2>

<p>
Luaは自動メモリ管理を行います。
つまり新しいオブジェクトのためのメモリ確保や使わなくなったオブジェクトの解放について悩まなくていいということです。
<em>死んだオブジェクト</em>
(つまりLuaからアクセス可能でなくなったオブジェクト)
を回収する<em>ガベージコレクタ</em>により、Luaのメモリは自動的に管理されます。
Luaが使うメモリ
(文字列、テーブル、ユーザーデータ、関数、スレッド、内部構造体など)
はすべて自動管理の対象です。


<p>
Luaにはインクリメンタルマークアンドスイープコレクタが実装されています。
ガベージコレクションのサイクルを制御するために<em>ガベージコレクタ停止期間</em>および<em>ガベージコレクタステップ係数</em>という2つの数値が使われます。
両方とも単位はパーセントです
(つまり値100が内部的な値の1を表します)。


<p>
ガベージコレクタ停止期間はコレクタが新しいサイクルを開始するまでに待機する時間の長さを制御します。
大きな値ほどコレクタが消極的になります。
100より小さな値を指定すると待機せずに新しいサイクルを開始するという意味になります。
200の値を指定すると使用中の合計メモリが2倍になるまで待機してから新しいサイクルを開始するという意味になります。


<p>
ガベージコレクタステップ係数はメモリ確保に対するコレクタの相対速度を制御します。
大きな値ほどコレクタは積極的になりますが、各インクリメンタルステップのサイズも増加します。
100より小さな値は指定するべきではありません。
コレクタが非常に遅くなり、サイクルを完了できなくなる可能性があります。
デフォルトは200です。
これはメモリ確保の「2倍」の速度でコレクタを動作させるという意味になります。


<p>
ステップ係数を非常に大きな値
(使用する可能性のあるバイト数の最大値より10%以上大きな値)
にするとストップザワールドコレクタのように動作します。
さらに停止期間を200に設定すると昔のバージョンのLuaのように動作します。
つまりメモリ使用量が2倍になるたびに完全なコレクションを実行します。


<p>
これらの数値を変更するには、Cで
<a href="#lua_gc"><code>lua_gc</code></a> を呼ぶか、Luaで
<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>
を呼びます。
また。これらの関数を使うとコレクタを直接制御 (停止、再開など) することができます。



<h3>2.5.1 &ndash; <a name="2.5.1">ガベージコレクションメタメソッド</a></h3>

<p>
ガベージコレクタメタメソッドをテーブルに対して設定することができます
(<a href="#2.4">&sect;2.4</a> を参照)。
CのAPIを使えばフルユーザーデータに対しても設定することができます。
このメタメソッドは<em>ファイナライザ</em>とも言います。
ファイナライザを使うと、Luaのガベージコレクションを外部リソースの管理と連携させることができます
(ファイルやネットワーク接続、データベース接続を閉じたり、独自に確保したメモリを解放するなど)。


<p>
オブジェクト (テーブルまたはユーザーデータ)
が回収されるときにファイナライズするためには、それをファイナライズ用に<em>マーク</em>しなければなりません。

オブジェクトにメタテーブルを設定したとき、そのメタテーブルに文字列
"<code>__gc</code>" をキーとするフィールドがあれば、そのオブジェクトはファイナライズ用にマークされます。
<code>__gc</code> フィールドを持たないメタテーブルを設定し、後にそのメタテーブルにそのフィールドを作成した場合、そのオブジェクトはファイナライズ用にマークされません。


<p>
マークしたオブジェクトがゴミになったとき、そのオブジェクトは直ちにはガベージコレクタに回収されません。
代わりに、あるリストに格納されます。
ガベージコレクションの後、そのリストが走査され、リスト内の各オブジェクトに対して
<code>__gc</code> メタメソッドが検索されます。
それが関数であれば、そのオブジェクトを引数としてその関数が呼ばれます。
そのメタメソッドが関数でなければ、単に無視されます。


<p>
各ガベージコレクションサイクルの終わりに、そのサイクルで回収されたオブジェクトのファイナライザが、ファイナライズ用にマークされたのと逆の順序で呼ばれます。
つまり最後にマークされたオブジェクトのファイナライザが最初に呼ばれるファイナライザになります。
ファイナライザの呼び出しは通常のコードの実行中に任意の地点で発生する可能性があります。


<p>
回収されたオブジェクトは、まだファイナライザで使われるので、<em>蘇生</em>されます。
通常、この蘇生は一時的なものであり、そのオブジェクトのメモリは次のガベージコレクションサイクルで解放されます。
しかし、もしファイナライザがそのオブジェクトをどこかグローバルな場所
(例えばグローバル変数) に格納すると、その蘇生は永続的なものになります。
そのオブジェクトが再びファイナライズ用にマークされると、オブジェクトが到達不可能になった次のサイクルに再びファイナライザが呼ばれます。
いずれの場合でも、オブジェクトのメモリはそのオブジェクトが到達不可能かつファイナライズ用にマークされていない場合にだけ解放されます。


<p>
ステートを閉じると (<a href="#lua_close"><code>lua_close</code></a>
を参照)、ファイナライズ用にマークされたすべてのオブジェクトのファイナライザがマークされたのと逆の順序で呼ばれます。
このフェーズ中にファイナライザ内でオブジェクトをマークしても、そのマークには効果がありません。





<h3>2.5.2 &ndash; <a name="2.5.2">弱参照テーブル</a></h3>

<p>
<em>弱参照テーブル</em>は要素が<em>弱参照</em>であるテーブルです。
弱参照はガベージコレクタから無視されます。
別の言い方をすると、あるオブジェクトへの参照が弱参照のみであれば、そのオブジェクトはガベージコレクタによって回収されます。


<p>
弱参照テーブルは、キー、値、またはその両方が弱参照です。
値が弱参照なテーブルでは、値は回収されますが、 キーは回収されません。
キーと値の両方が弱参照なテーブルでは、キーと値の両方が回収されます。
いずれの場合でも、キーと値のどちらかが回収されると、そのペア全体がテーブルから削除されます。
テーブルの弱参照の性質は、そのメタテーブルの
<code>__mode</code> フィールドで制御されます。
<code>__mode</code> フィールドが文字列であり、その文字列に
'<code>k</code>' の文字が含まれていれば、そのテーブルのキーは弱参照になります。
<code>__mode</code> に
'<code>v</code>' が含まれていれば、そのテーブルの値は弱参照になります。


<p>
キーが弱参照で値が強参照なテーブルは<em>短命テーブル</em>と言います。
短命テーブルでは、キーが到達可能な場合に限り、値が到達可能とみなされます。
つまり、キーへの参照が値を経由するものしかない場合、そのペアは削除されます。


<p>
テーブルの弱参照の性質を変更した場合、その効果は次の回収サイクルまで現れない場合があります。
例えば弱参照から強参照に変更した場合、変更の効果が現れるまでの間に、そのテーブルからいくつかの項目が回収されてしまう可能性があります。


<p>
明示的に生成するタイプのオブジェクトだけが弱参照テーブルから削除されます。
数値や軽量C関数のような値はガベージコレクションの対象ではなく、弱参照テーブルから削除されません
(対応する値が回収された場合を除きます)。
文字列はガベージコレクションの対象ですが、明示的に生成するものではないので弱参照テーブルからは削除されません。


<p>
蘇生されたオブジェクト
(つまりファイナライズされたオブジェクトと、ファイナライズされたオブジェクトを経由してのみアクセス可能なオブジェクト)
は、弱参照テーブルでは特殊な動作をします。
値が弱参照の場合はファイナライザが実行される前に削除されますが、キーが弱参照の場合はファイナライザが実行された後、次のコレクションで、それらのオブジェクトが実際に解放された時にのみ削除されます。
この動作は、ファイナライザから弱参照テーブルを参照して、そのオブジェクトに関連付けられた値にアクセスできるようにするためのものです。


<p>
弱参照テーブルが蘇生された場合、その要素は次のサイクルまで正しくクリアされない場合があります。







<h2>2.6 &ndash; <a name="2.6">コルーチン</a></h2>

<p>
Luaはコルーチンをサポートしています。
<em>協調的マルチスレッド</em>とも言います。
Luaのコルーチンは独立した実行のスレッドを表します。
しかしマルチスレッドシステムのスレッドと異なり、コルーチンは明示的にyield関数を呼んだときだけ実行が中断されます。


<p>
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
を呼ぶとコルーチンを作成できます。
その唯一の引数は作成するコルーチンのメイン関数です。
<code>create</code> 関数はコルーチンを作成し、そのハンドル
(<em>スレッド</em>型のオブジェクト)
を返すだけで、コルーチンの実行は開始しません。


<p>
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
を呼ぶとコルーチンを実行できます。
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
から返されたスレッドを最初の引数に指定した
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
の初回の呼び出しでそのコルーチンの実行が開始され、そのメイン関数が呼ばれます。
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
に渡した残りの引数は、その関数に引数として渡されます。
コルーチンが実行を開始すると、終了するか<em>yield</em>するまで実行が続けられます。


<p>
コルーチンの実行終了には2通りの場合があります。
コルーチンのメイン関数が
(明示的に、または最後の命令が終わって暗黙的に)
リターンすると、正常終了になります。
保護されていないエラーが発生すると、異常終了になります。
正常終了の場合、
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
は <b>true</b> と、そのコルーチンのメイン関数から返されたすべての値を返します。
エラーの場合、
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
は <b>false</b> とエラーメッセージを返します。


<p>
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
を呼ぶとコルーチンをyieldできます。
コルーチンをyieldすると、対応する
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
から直ちに戻ります。
ネストした関数呼び出しの中
(つまり、メイン関数でなく、メイン関数から直接または間接的に呼ばれた関数の中)
でyieldが発生した場合でも同様です。
yieldした場合、
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
は <b>true</b> に加えて、
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
に渡された値をすべて返します。
次に同じコルーチンがresumeされると、そのyieldした場所、つまり
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
の呼び出しから戻るところから実行が続行されます。
その際
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
に渡した残りの引数がすべて返されます。


<p>
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
と同様に
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
関数もコルーチンを作成しますが、コルーチン自体を返すのではなく関数を返します。
その関数を呼ぶと、そのコルーチンがresumeされます。
この関数に渡した引数はすべて
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
に追加の引数として渡されます。
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
は、
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
が返した値を、最初のひとつ (ブーリアンのエラーコード) を除き、すべて返します。
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
と異なり、
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
はエラーをキャッチしません。
あらゆるエラーは呼び出し元に伝播されます。


<p>
コルーチンがどのように動作するかの例として、以下のコードを考えてみてください。

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end

     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)

     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
実行すると以下のように出力されます。

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
CのAPIを使ってコルーチンを作成、操作することもできます。
<a href="#lua_newthread"><code>lua_newthread</code></a> 関数、
<a href="#lua_resume"><code>lua_resume</code></a> 関数、
<a href="#lua_yield"><code>lua_yield</code></a> 関数を参照してください。





<h1>3 &ndash; <a name="3">言語</a></h1>

<p>
この節ではLuaの字句、構文、意味論について説明します。
別の言い方をすると、この節ではどのようなトークンが有効なのか、それをどのように組み合わせられるのか、そしてその組み合わせが何を意味するのかについて述べます。


<p>
言語要素は一般的な拡張BNF記法を使って説明します。
つまり
{<em>a</em>} は<em>a</em>の0回以上の繰り返しを表し、
[<em>a</em>] は<em>a</em>が省略可能であることを表します。
非終端記号は non-terminal
のように表し、キーワードは <b>kword</b>
のように表し、それ以外の終端記号は &lsquo;<b>=</b>&rsquo; のように表します。
Luaの完全な構文は、このマニュアルの最後 <a href="#9">&sect;9</a> に掲載されています。



<h2>3.1 &ndash; <a name="3.1">字句規約</a></h2>

<p>
Luaはフリーフォーマットの言語です。
字句要素 (トークン) 間の空白 (改行を含む) は無視されます
(ただし名前やキーワードを区切る効果はあります)。


<p>
Luaにおける<em>名前</em> (<em>識別子</em>とも言います)
は文字、数字、アンダースコアを組み合わせた任意の文字列です。
ただし数字で始まってはいけません。
識別子は変数、テーブルフィールド、ラベルに名前を付けるために使われます。


<p>
以下の<em>キーワード</em>は予約されており、
名前として使うことはできません。


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Luaは大文字小文字を区別する言語です。
<code>and</code> は予約語ですが、
<code>And</code> と <code>AND</code> は2つの異なる有効な名前です。
慣例により、アンダースコアと大文字で始まる名前
(例えば <a href="#pdf-_VERSION"><code>_VERSION</code></a>)
を作るのは避けるようにしてください。


<p>
以下の文字列は、それ以外のトークンです。

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>リテラル文字列</em>は対応するシングルクォートまたはダブルクォートで区切られます。
また以下に示すCのようなエスケープシーケンスを使うことができます。
<ul>
<li>'<code>\a</code>': ベル
<li>'<code>\b</code>': バックスペース
<li>'<code>\f</code>': 改頁
<li>'<code>\n</code>': 改行
<li>'<code>\r</code>': 復帰
<li>'<code>\t</code>': 水平タブ
<li>'<code>\v</code>': 垂直タブ
<li>'<code>\\</code>': バックスラッシュ (円記号)
<li>'<code>\"</code>': 引用符 (ダブルクォート)
<li>'<code>\'</code>': アポストロフィ (シングルクォート)
</ul>
<p>
バックスラッシュに本物の改行が続いたものは文字列中の改行になります。
エスケープシーケンス '<code>\z</code>'
は後続のホワイトスペース (改行を含む) をスキップします。
文字列の中身に改行やスペースを追加せずに長いリテラル文字列を複数行に分割してインデントしたいとき特に便利でしょう。


<p>
Luaの文字列は
'<code>\0</code>'
で表されるゼロを含む任意の8ビット値を持つことができます。
より一般的に言えば、数値によってリテラル文字列中の任意のバイトを指定することができます。
これはエスケープシーケンス <code>\x<em>XX</em></code>
(<em>XX</em> はちょうど2桁の16進数)
やエスケープシーケンス <code>\<em>ddd</em></code>
(<em>ddd</em> は最大3桁の10進数)
で行うことができます。
(10進数のエスケープシーケンスに数字が続く場合は、ちょうど3桁を使って表さなければならないことに注意してください。)


<p>
エスケープシーケンス <code>\u{<em>XXX</em>}</code>
(<em>XXX</em> は文字のコードポイントを表す1桁以上の16進数)
を使うと、リテラル文字列にそのUnicode文字のUTF-8エンコーディングを入れることができます
(周りの括弧は必須です)。


<p>
リテラル文字列は<em>長括弧</em>で囲む長い形式を使って書くこともできます。
<em><em>n</em>段の開き長括弧</em>は、開き角括弧に<em>n</em>個のイコール記号と、もうひとつ開き角括弧が続いたものです。
つまり0段の開き長括弧は <code>[[</code>
と書き、1段の開き長括弧は <code>[=[</code> と書き、以下同様です。
<em>閉じ長括弧</em>も同様です。
例えば4段の閉じ長括弧は <code>]====]</code> と書きます。
<em>長いリテラル</em>は任意の段数の開き長括弧で始まり、同じ段数の最初の閉じ長括弧で終わります。
これには同じ段数の閉じ長括弧以外の任意のテキストを含めることができます。
この括弧形式のリテラルは複数行に渡って書くことができ、いかなるエスケープシーケンスも解釈せず、異なる段数の長括弧を無視します。
あらゆる種類の改行シーケンス
(復帰、改行、復帰+改行、改行+復帰)
は単純な改行に変換されます。


<p>
ここまで述べたルールに当てはまらないリテラル文字列中のあらゆるバイトは、それ自身を表します。
ただし、Luaはファイルをテキストモードで開いて読み込むので、制御文字を使うと場合によっては問題があるかもしれません。
そのため、テキストでないデータをリテラル文字列として表現する場合は、テキストでない文字の部分は明示的にエスケープシーケンスを使って記述する方が安全です。


<p>
便利なように、開き長括弧の直後に改行がある場合、その改行は文字列に含まれません。
例えば、ASCII
('<code>a</code>' が97、改行が10、 '<code>1</code>' が49である文字コード)
を使っているシステムでは、以下の5つのリテラル文字列は同じ文字列を表します。

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
<em>数値定数</em> (または<em>数値</em>)
には省略可能な小数部と省略可能な10進指数を付けることができます。
10進指数は
'<code>e</code>' または '<code>E</code>'
の文字で示されます。
<code>0x</code> または <code>0X</code>
で始まる16進定数も使うことができます。
16進定数にも省略可能な小数部と省略可能な2進指数を付けることができます。
2進指数は
'<code>p</code>' または '<code>P</code>'
の文字で示されます。
数値定数に小数点または指数が付いている場合は浮動小数点数を表し、それ以外の場合は整数を表します。
有効な整数定数の例を以下に示します。

<pre>
     3   345   0xff   0xBEBADA
</pre><p>
有効な浮動小数点数定数の例を以下に示します。

<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
<em>コメント</em>は2つのハイフン
(<code>--</code>) で始まります。
ただし文字列中は除きます。
<code>--</code> の直後のテキストが開き長括弧でなければ、そのコメントは<em>短いコメント</em>で、行の終わりまでです。
そうでなければ、それは<em>長いコメント</em>で、対応する閉じ長括弧までです。
長いコメントはコードを一時的に無効化するためによく使われます。





<h2>3.2 &ndash; <a name="3.2">変数</a></h2>

<p>
変数は値を格納する場所です。
Luaには3種類の変数があります。
グローバル変数、ローカル変数、テーブルフィールドです。


<p>
単発の名前はグローバル変数かローカル変数です
(あるいは関数の仮引数かもしれませんが、それはローカル変数の一種です)。

<pre>
	var ::= Name
</pre><p>
<a href="#3.1">&sect;3.1</a> で述べたように、名前は識別子を表します。


<p>
あらゆる変数名は明示的にローカルと宣言されない限りグローバルとみなされます
(<a href="#3.3.7">&sect;3.3.7</a> を参照)。
ローカル変数は<em>レキシカルスコープ</em>を持ちます。
つまりローカル変数は、そのスコープ内部で定義された関数から自由にアクセスできます
(<a href="#3.5">&sect;3.5</a> を参照)。


<p>
変数に最初の代入が行われるまで、その値は <b>nil</b> です。


<p>
角括弧はテーブルのインデックス検索に使われます。

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
メタテーブルを使うと、テーブルフィールドにアクセスしたときの効果を変更できます。
インデックス付き変数 <code>t[i]</code> へのアクセスは
<code>gettable_event(t,i)</code> の呼び出しと同等です。
(<code>gettable_event</code> 関数の完全な説明は
<a href="#2.4">&sect;2.4</a> を参照してください。
この関数はLuaに定義されておらず、呼ぶことはできません。
ここでの説明のために使用しているだけです。)


<p>
構文 <code>var.Name</code> は
<code>var["Name"]</code> の単なるシンタックスシュガーです。

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
グローバル変数 <code>x</code> へのアクセスは、
<code>_ENV.x</code> と同等です。
チャンクのコンパイル方法に由来する理由により、
<code>_ENV</code> がグローバル変数になることはありません
(<a href="#2.2">&sect;2.2</a> を参照)。





<h2>3.3 &ndash; <a name="3.3">文</a></h2>

<p>
LuaにはPascalやCのものと同様の一般的な文が一通り用意されています。
具体的には代入、制御構文、関数呼び出し、変数宣言などがあります。



<h3>3.3.1 &ndash; <a name="3.3.1">ブロック</a></h3>

<p>
ブロックは順番に実行される文のリストです。

<pre>
	block ::= {stat}
</pre><p>
Luaには<em>空文</em>があるので、文をセミコロンで区切ったり、ブロックをセミコロンで始めたり、連続して2つのセミコロンを書いたりできます。

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
関数呼び出しと代入は開き括弧で始めることができます。
これによってLuaの文法に曖昧さが生じる場合があります。
以下のコード片を考えてみてください。

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
これは以下の2通りの解釈が可能です。

<pre>
     a = b + c(print or io.write)('done')

     a = b + c; (print or io.write)('done')
</pre><p>
現在のパーサはこのような構文を常に前者のように扱い、開き括弧は関数呼び出しの引数の始まりであると解釈します。
このような曖昧さを回避するために、括弧で始まる文には必ずセミコロンを前置するのが良い習慣です。

<pre>
     ;(print or io.write)('done')
</pre>

<p>
ブロックは単一の文とするために明示的に区切ることができます。

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
明示的なブロックは変数宣言のスコープを制御するのに便利です。
また他のブロックの途中に <b>return</b> 文を追加するために使われることもあります
(<a href="#3.3.4">&sect;3.3.4</a> を参照)。





<h3>3.3.2 &ndash; <a name="3.3.2">チャンク</a></h3>

<p>
Luaのコンパイル単位は<em>チャンク</em>と言います。
構文的には、チャンクは単なるブロックです。

<pre>
	chunk ::= block
</pre>

<p>
チャンクは可変長引数を持つ無名関数の本体として扱われます
(<a href="#3.4.11">&sect;3.4.11</a> を参照)。
そのため、チャンクはローカル変数を定義したり、引数を受け取ったり、値を返すことができます。
さらに、この無名関数は <code>_ENV</code> という名前の外部ローカル変数のスコープ内にあるかのようにコンパイルされます。
その結果となる関数は常に (例え使わなくとも) 唯一の上位値として <code>_ENV</code> を持ちます。


<p>
チャンクはファイルやホストプログラム内の文字列に格納しておくことができます。
チャンクを実行する場合は、まずそれが<em>ロード</em>されます。
具体的には、そのチャンクのコードが仮想機械の命令列にコンパイルされます。
それから、そのコンパイルされたコードが仮想機械のインタプリタを使って実行されます。


<p>
チャンクはコンパイル済みのバイナリ形式にしておくこともできます。
詳細は <code>luac</code> プログラムと <a href="#pdf-string.dump"><code>string.dump</code></a> 関数を参照してください。
ソースプログラムとコンパイル済み形式はどちらでも使用できます。
ファイルの形式は自動的に判定され、その結果に応じて適切に動作します
(<a href="#pdf-load"><code>load</code></a> を参照)。





<h3>3.3.3 &ndash; <a name="3.3.3">代入</a></h3>

<p>
Luaには多重代入があります。
そのため、代入の構文は左辺に変数リストがあり、右辺に式リストがあります。
どちらのリストもコンマで要素を区切ります。

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
式は <a href="#3.4">&sect;3.4</a> で議論します。


<p>
代入の前に、値リストが変数リストの長さに<em>調節</em>されます。
必要な数よりも値が多い場合、余分な値は捨てられます。
必要な数よりも値が少ない場合、必要な数だけ <b>nil</b> がリストに追加されます。
式リストの最後が関数呼び出しの場合、その呼び出しから返された値がすべて、代入の前に値リストに追加されます
(その呼び出しを括弧で囲った場合を除きます。
<a href="#3.4">&sect;3.4</a> を参照)。


<p>
代入文では、まずすべての式が評価され、それから代入が行われます。
そのため、以下のコードは

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
<code>a[3]</code> を20に設定し、 <code>a[4]</code> には影響を与えません。
<code>a[i]</code> の <code>i</code> は、4が代入される前に (3に) 評価されるためです。
同様に、以下の行は

<pre>
     x, y = y, x
</pre><p>
<code>x</code> と <code>y</code> を入れ替えます。
また、以下の行は

<pre>
     x, y, z = y, z, x
</pre><p>
<code>x</code>、
<code>y</code>、
<code>z</code> の値を巡回置換します。


<p>
メタテーブルを使うと、グローバル変数とテーブルフィールドへの代入の効果を変更できます。
インデックス付き変数への代入 <code>t[i] = val</code> は
<code>settable_event(t,i,val)</code> と同等です。
(<code>settable_event</code> 関数の完全な説明は
<a href="#2.4">&sect;2.4</a> を参照してください。
この関数はLuaに定義されておらず、呼ぶことはできません。
ここでの説明のために使用しているだけです。)


<p>
グローバルな名前への代入 <code>x = val</code>
は、代入 <code>_ENV.x = val</code> と同等です
(<a href="#2.2">&sect;2.2</a> を参照)。





<h3>3.3.4 &ndash; <a name="3.3.4">制御構造</a></h3><p>
制御構造
<b>if</b>、<b>while</b>、<b>repeat</b>
は一般的な意味と馴染み深い構文を持っています。




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
また2種類の <b>for</b> 文もあります
(<a href="#3.3.5">&sect;3.3.5</a> を参照)。


<p>
制御構造の条件式には任意の値を指定することができます。
<b>false</b> と <b>nil</b> は両方とも偽とみなされます。
<b>nil</b> と <b>false</b> 以外のすべての値は真とみなされます
(例えば数値の0や空文字列も真になります)。


<p>
<b>repeat</b>&ndash;<b>until</b> ループでは、内部のブロックの終わりは
<b>until</b> キーワードのところではなく、条件式の後です。
そのため、ループブロックの内部で宣言したローカル変数を条件式から参照できます。


<p>
<b>goto</b> 文はプログラムの制御をラベルへ移動させます。
構文的な理由により、Luaではラベルも文とみなされます。



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
ラベルは、それが定義されたブロック全体において可視です。
ただし、同じ名前のラベルが定義されているネストしたブロックの内部とネストした関数の内部は除きます。
gotoは、ローカル変数のスコープの中へ入らない限り、可視なラベルのどれにでも飛べます。

<p>
ラベルと空文は<em>無の文</em>と言います。
何のアクションも行わないという意味です。


<p>
<b>break</b> 文は
<b>while</b>、<b>repeat</b>、<b>for</b>
ループの実行を終了し、そのループの後の次の文まで飛びます。


<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b> はそれを囲んでいる最も内側のループを終了します。


<p>
<b>return</b> 文は関数やチャンク
(チャンクは無名関数です)
から値を返すために使います。

関数は2つ以上の値を返すことができます。
そのため <b>return</b> 文の構文は以下のようになっています。

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
<b>return</b> 文はブロックの最後の文としてのみ書くことができます。
ブロックの途中で <b>return</b> することが本当に必要であれば、
明示的な内部ブロックを使うことができます。
つまり、
<code>do return end</code>
という慣用句を使えば、
<b>return</b> は (内部) ブロックの最後の文となります。





<h3>3.3.5 &ndash; <a name="3.3.5">for文</a></h3>

<p>

<b>for</b> 文には数値用と汎用の2種類の形式があります。


<p>
数値用の <b>for</b> ループは、制御変数が等差数列を辿る間、コードブロックを繰り返します。
構文は以下の通りです。

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
<em>name</em>が最初の<em>exp</em>の値で始まり、2番目の<em>exp</em>を超えるまで、3番目の<em>exp</em>ずつ増えながら、<em>block</em>が繰り返されます。
より正確に言うと、以下のような <b>for</b> 文は、

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
以下のコードと同等です。

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
注意点は以下の通りです。

<ul>

<li>
3つの制御式はすべて、ループが始まる前に一度だけ評価されます。
これらはすべて、数値に評価されなければなりません。
</li>

<li>
<code><em>var</em></code>、
<code><em>limit</em></code>、
<code><em>step</em></code>
は見えない変数です。
ここで示した名前は説明のためだけのものです。
</li>

<li>
3番目の式 (増分) を指定しなかった場合は1が使われます。
</li>

<li>
<b>break</b> や <b>goto</b> を使うと
<b>for</b> ループを抜けることができます。
</li>

<li>
ループ変数 <code>v</code> はループ本体にローカルです。
ループ終了後にその値が必要な場合は、ループを抜ける前に別の変数に代入しておいてください。
</li>

</ul>

<p>
汎用の <b>for</b> 文は<em>イテレータ</em>と呼ばれる関数を用いて動作します。
繰り返しのたびにイテレータ関数を呼んで新しい値を生成します。
この新しい値が <b>nil</b> であれば繰り返しは終了します。
汎用 <b>for</b> ループの構文は以下の通りです。

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
以下のような <b>for</b> 文は、

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
以下のコードと同等です。

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
注意点は以下の通りです。

<ul>

<li>
<code><em>explist</em></code> は一度だけ評価されます。
戻り値は<em>イテレータ</em>関数、<em>状態</em>、最初の<em>イテレータ変数</em>の初期値です。
</li>

<li>
<code><em>f</em></code>、
<code><em>s</em></code>、
<code><em>var</em></code>
は見えない変数です。
この名前はここでの説明のためだけのものです。
</li>

<li>
<b>break</b> を使うと <b>for</b> ループから抜けることができます。
</li>

<li>
ループ変数 <code><em>var_i</em></code> はループにローカルです。
<b>for</b> の終了後に使うことはできません。
値が必要であれば、ループをbreakしたり抜けたりする前に、別の変数に代入しておいてください。
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">文としての関数呼び出し</a></h3><p>
副作用目的で、関数呼び出しを文として実行することができます。

<pre>
	stat ::= functioncall
</pre><p>
この場合、戻り値はすべて捨てられます。
関数呼び出しは <a href="#3.4.10">&sect;3.4.10</a> で説明します。





<h3>3.3.7 &ndash; <a name="3.3.7">ローカル宣言</a></h3><p>
ローカル変数はブロック内のどこでも宣言できます。
宣言には初期値の代入を付けることもできます。

<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
もしあれば、初期値の代入は多重代入と同じ意味論を持ちます
(<a href="#3.3.3">&sect;3.3.3</a> を参照)。
なければ、すべての変数は <b>nil</b> で初期化されます。


<p>
チャンクもブロックであるので
(<a href="#3.3.2">&sect;3.3.2</a> を参照)、
ローカル変数は明示的なブロックの外側のチャンク内でも宣言することができます。

<p>
ローカル変数の可視性ルールは <a href="#3.5">&sect;3.5</a> で説明します。







<h2>3.4 &ndash; <a name="3.4">式</a></h2>

<p>
基本的な式には以下のものがあります。

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
数値とリテラル文字列は <a href="#3.1">&sect;3.1</a> で説明しました。
変数は <a href="#3.2">&sect;3.2</a> で説明しました。
関数定義は <a href="#3.4.11">&sect;3.4.11</a> で説明します。
関数呼び出しは <a href="#3.4.10">&sect;3.4.10</a> で説明します。
テーブルコンストラクタは <a href="#3.4.9">&sect;3.4.9</a> で説明します。
3つのドット ('<code>...</code>') で表される可変長引数式は、可変長関数の中でだけ使えます。
これは <a href="#3.4.11">&sect;3.4.11</a> で説明します。


<p>
二項演算子には算術演算子
(<a href="#3.4.1">&sect;3.4.1</a> を参照)、
ビット演算子 (<a href="#3.4.2">&sect;3.4.2</a> を参照)、
関係演算子 (<a href="#3.4.4">&sect;3.4.4</a> を参照)、
論理演算子 (<a href="#3.4.5">&sect;3.4.5</a> を参照)、
連結演算子 (<a href="#3.4.6">&sect;3.4.6</a> を参照)
があります。
単項演算子には単項マイナス (<a href="#3.4.1">&sect;3.4.1</a> を参照)、
単項ビット否定 (<a href="#3.4.2">&sect;3.4.2</a> を参照)、
単項論理 <b>not</b> (<a href="#3.4.5">&sect;3.4.5</a> を参照)、
単項<em>長さ演算子</em> (<a href="#3.4.7">&sect;3.4.7</a> を参照)
があります。

<p>
関数呼び出しと可変長引数式は両方とも、複数の値を返す場合があります。
関数呼び出しが文として使われた場合 (<a href="#3.3.6">&sect;3.3.6</a> を参照)、その戻り値リストはゼロ個の要素に調節され、つまりすべての戻り値が捨てられます。
式を式リストの最後の (または唯一の) 要素として使った場合、調節は行われません (その式を括弧で囲った場合を除きます)。
それ以外のすべての文脈では、戻り値リストは1個の要素に調節され、最初のひとつ以外のすべての値が捨てられるか、値がない場合は <b>nil</b> がひとつ追加されます。


<p>
いくつか例を挙げます。

<pre>
     f()                -- 戻り値は0個に調節される
     g(f(), x)          -- f()の戻り値は1個に調節される
     g(x, f())          -- gは、xに加え、f()からの戻り値をすべて受け取りる
     a,b,c = f(), x     -- f()の戻り値は1個に調節される (cはnilになる)
     a,b = ...          -- aは可変長引数の最初の値を受け取り、
                        -- bは2番目の値を受け取る
                        -- (aもbも、対応する値がなければnilを受け取る)

     a,b,c = x, f()     -- f()の戻り値は2個に調節される
     a,b,c = f()        -- f()の戻り値は3個に調節される
     return f()         -- f()の戻り値をすべて返す
     return ...         -- 受け取った可変長引数をすべて返す
     return x,y,f()     -- x、y、およびf()のすべての戻り値を返す
     {f()}              -- f()のすべての戻り値を持つリストを作る
     {...}              -- すべての可変長引数を持つリストを作る
     {f(), nil}         -- f()の戻り値は1個に調節される
</pre>

<p>
括弧で囲まれたあらゆる式は、常に1個だけの値を返します。
例えば、 <code>f</code> が複数の値を返す場合でも、
<code>(f(x,y,z))</code> は必ず1個の値となります。
(<code>(f(x,y,z))</code> の値は <code>f</code> が返した最初の値になります。
<code>f</code> が何も返さなければ <b>nil</b> になります。)



<h3>3.4.1 &ndash; <a name="3.4.1">算術演算子</a></h3><p>
算術演算子には以下のものがあります。

<ul>
<li><b><code>+</code>: </b>加算</li>
<li><b><code>-</code>: </b>減算</li>
<li><b><code>*</code>: </b>乗算</li>
<li><b><code>/</code>: </b>浮動小数点数除算</li>
<li><b><code>//</code>: </b>切り捨て除算</li>
<li><b><code>%</code>: </b>剰余</li>
<li><b><code>^</code>: </b>累乗</li>
<li><b><code>-</code>: </b>単項マイナス</li>
</ul>

<p>
累乗と浮動小数点数除算以外の算術演算は以下のように動作します。
引数が両方とも整数であれば、演算は整数で行われ、結果は整数になります。
そうでなければ、引数が両方とも数値であるか、数値に変換可能な文字列であれば
(<a href="#3.4.3">&sect;3.4.3</a> を参照)、
それらは浮動小数点数に変換され、演算は浮動小数点数算術の一般的な規則
(通常はIEEE 754標準規格)
に従って行われ、結果は浮動小数点数になります。


<p>
累乗と浮動小数点数除算 (<code>/</code>)
では、引数は常に浮動小数点数に変換され、結果は必ず浮動小数点数になります。
累乗にはISO Cの <code>pow</code>
関数が使用されるため、整数以外の指数に対しても動作します。


<p>
切り捨て除算 (<code>//</code>) は商を負の無限大に向かって丸めた除算です。
つまり除算の切り捨てです。


<p>
剰余は商を負の無限大に向かって丸めた除算 (切り捨て除算) の余りとして定義されています。


<p>
整数算術がオーバーフローした場合、すべての演算は2の補数算術の一般的なルールに従って<em>ラップアラウンド</em>します。
(別の言い方をすると、数学的な結果を<em>2<sup>64</sup></em>で割った余りと等しい一意に表現可能な整数を返します。)



<h3>3.4.2 &ndash; <a name="3.4.2">ビット演算子</a></h3><p>
ビット演算子には以下のものがあります。

<ul>
<li><b><code>&amp;</code>: </b>ビットごとの論理積</li>
<li><b><code>&#124;</code>: </b>ビットごとの論理和</li>
<li><b><code>~</code>: </b>ビットごとの排他的論理和</li>
<li><b><code>&gt;&gt;</code>: </b>右シフト</li>
<li><b><code>&lt;&lt;</code>: </b>左シフト</li>
<li><b><code>~</code>: </b>単項ビットごとの否定</li>
</ul>

<p>
ビット演算子はすべて、引数を整数に変換し
(<a href="#3.4.3">&sect;3.4.3</a> を参照)、その整数の全ビットを演算し、結果を整数で返します。


<p>
右シフトと左シフトは両方とも、空いたビットをゼロで埋めます。
変位に負の値を指定すると逆方向にシフトします。
変位の絶対値が整数のビット数以上であれば結果はゼロになります
(すべてのビットが追い出されます)。





<h3>3.4.3 &ndash; <a name="3.4.3">強制型変換</a></h3><p>
Luaでは型や表現が実行時に自動的に変換される場合があります。
ビット演算では浮動小数点数の引数は常に整数に変換されます。
累乗と浮動小数点数除算では整数の引数は常に浮動小数点数に変換されます。
それ以外の算術演算はすべて、整数と浮動小数点数の混ざった引数に適用した場合、整数の引数は浮動小数点数に変換されます
(これを<em>一般的なルール</em>と言います)。
CのAPIでも、必要に応じて整数が浮動小数点数に変換されたり、浮動小数点数が整数に変換されたりします。
さらに、文字列連結では文字列だけでなく数値も引数として受け付けます。


<p>
また、数値が期待されるところでは、文字列は数値に変換されます。


<p>
整数から浮動小数点数への変換では、その整数の値が浮動小数点数で正確に表現可能であれば、それが結果となります。
そうでなければ、その整数より大きな最も近い表現可能な値か、その整数より小さな最も近い表現可能な値に変換されます。
この種の変換に失敗することはありません。


<p>
浮動小数点数から整数への変換では、その浮動小数点数が整数として正確に表現可能かどうか
(つまりその浮動小数点数に小数点以下の端数がないかどうかと、その値が整数表現の範囲内かどうか)
がチェックされます。
表現可能であればその表現が結果となります。
そうでなければ変換は失敗します。


<p>
文字列から数値への変換は以下のように行われます。
まずその文字列が、Luaの数値構文と字句解析のルールに従って、整数か浮動小数点数に変換されます。
(文字列の前後に空白があってもよく、符号が付いていても構いません。)
それから結果の数値 (浮動小数点数または整数)
が、文脈 (強制的に変換を行う演算子など)
によって要求される型 (浮動小数点数または整数) に変換されます。


<p>
数値から文字列への変換では、人間が読める適当な形式が使われます。
数値を文字列に変換する方法を完全に制御したい場合は、文字列ライブラリの <code>format</code> 関数を使ってください
(<a href="#pdf-string.format"><code>string.format</code></a> を参照)。





<h3>3.4.4 &ndash; <a name="3.4.4">関係演算子</a></h3><p>
関係演算子には以下のものがあります。

<ul>
<li><b><code>==</code>: </b>等しい</li>
<li><b><code>~=</code>: </b>等しくない</li>
<li><b><code>&lt;</code>: </b>より小さい</li>
<li><b><code>&gt;</code>: </b>より大きい</li>
<li><b><code>&lt;=</code>: </b>小さいまたは等しい</li>
<li><b><code>&gt;=</code>: </b>大きいまたは等しい</li>
</ul><p>
これらの演算子は必ず <b>false</b> か <b>true</b> を返します。


<p>
等値比較 (<code>==</code>) では、まず引数の型が比較されます。
型が異なる場合、結果は <b>false</b> です。
そうでなければ引数の値が比較されます。
文字列は一般的な方法で比較されます。
数値は両辺の数学的な値が同じであれば等しくなります。


<p>
テーブル、ユーザーデータ、スレッドの場合は参照が比較されます。
つまり、2つのオブジェクトが同じオブジェクトである場合に限り、等しいとみなされます。
新しいオブジェクト (テーブル、ユーザーデータ、スレッド)
を作成したときは必ず、その新しいオブジェクトは既存のいかなるオブジェクトとも異なります。
同じ参照を持つクロージャは必ず等しくなります。
検出可能な差異 (異なる動作、異なる定義)
を持つクロージャは必ず異なります。


<p>
"eq" メタメソッドを使うと、テーブルやユーザーデータの比較方法を変更できます
(<a href="#2.4">&sect;2.4</a> を参照)。


<p>
等値比較では、文字列を数値に変換したり、数値を文字列に変換したりしません。
そのため <code>"0"==0</code> は <b>false</b> に評価され、
<code>t[0]</code> と <code>t["0"]</code> はテーブルの異なるエントリを指します。


<p>
演算子 <code>~=</code> は等値比較 (<code>==</code>) の否定です。


<p>
順序演算子は以下のように動作します。
引数が両方とも数値であれば、
その数学的な値に従って (サブタイプに関係なく) 比較されます。
そうでなく、引数が両方とも文字列であれば、その値が現在のロケールに従って比較されます。
そうでなければ、 "lt" または "le" メタメソッド
(<a href="#2.4">&sect;2.4</a> を参照) が試みられます。
比較 <code>a &gt; b</code> は <code>b &lt; a</code> に変換され、
<code>a &gt;= b</code> は <code>b &lt;= a</code> に変換されます。


<p>
IEEE 754標準規格に従い、NaNは、いかなる値 (それ自身も含む)
と比較しても、小さくなく、等しくなく、大きくもないものとみなされます。





<h3>3.4.5 &ndash; <a name="3.4.5">論理演算子</a></h3><p>
論理演算子には <b>and</b>、<b>or</b>、<b>not</b> があります。
制御構造と同様に (<a href="#3.3.4">&sect;3.3.4</a> を参照)、すべての論理演算子は
<b>false</b> と <b>nil</b> を両方とも偽とみなし、それ以外のすべてを真とみなします。


<p>
否定演算子 <b>not</b> は必ず <b>false</b> か <b>true</b> を返します。
論理積演算子 <b>and</b> は最初の引数が <b>false</b> か <b>nil</b>
であればその値を返し、そうでなければ2番目の引数を返します。
論理和演算子 <b>or</b> は最初の引数が <b>nil</b> でも <b>false</b>
でもなければその値を返し、そうでなければ2番目の引数を返します。
<b>and</b> と <b>or</b> は両方とも短絡評価を行います。
つまり2番目の引数は必要な場合にだけ評価されます。
いくつか例を挙げます。

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
(このマニュアルでは <code>--&gt;</code> で式の結果を表します。)





<h3>3.4.6 &ndash; <a name="3.4.6">連結</a></h3><p>
文字列連結演算子は2つのドット ('<code>..</code>') で表されます。
引数が両方とも文字列か数値であれば、
<a href="#3.4.3">&sect;3.4.3</a> で述べたルールに従って文字列に変換されます。
そうでなければ <code>__concat</code> メタメソッドが呼ばれます
(<a href="#2.4">&sect;2.4</a> を参照)。





<h3>3.4.7 &ndash; <a name="3.4.7">長さ演算子</a></h3>

<p>
長さ演算子は単項前置演算子 <code>#</code> によって表されます。
文字列の長さは、そのバイト数です
(つまり、それぞれの文字が1バイトだとしたときの、文字列の長さです)。


<p>
<code>__len</code> メタメソッドを使うと、文字列以外の任意の値に対する長さ演算子の動作を変更できます
(<a href="#2.4">&sect;2.4</a> を参照)。


<p>
<code>__len</code> メソッドが指定されていない場合、テーブル
<code>t</code> の長さは、そのテーブルが<em>シーケンス</em>の場合に限り定義されます。
つまり、その正の数値キーの集合が <em>{1..n}</em>
(<em>n</em>は何らかの負でない整数) に等しい場合です。
この場合、<em>n</em>がその長さになります。
ちなみに、以下のようなテーブルは

<pre>
     {10, 20, nil, 40}
</pre><p>
シーケンスではないことに気をつけて下さい。
これにはキー <code>4</code> はありますが、キー <code>3</code> はありません。
(そのため、このテーブルの正の数値キーの集合が <em>{1..n}</em>
と等しいような<em>n</em>が存在しません。)
しかし、数値でないキーはテーブルがシーケンスかどうかに影響しないことに注意してください。





<h3>3.4.8 &ndash; <a name="3.4.8">優先順位</a></h3><p>
演算子の優先順位は以下の表の通りです。
優先順位の低い方から高い方に並べてあります。

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     単項演算子 (not   #     -     ~)
     ^
</pre><p>
一般的な数式と同様に、括弧を使って式の優先度を変えることができます。
連結演算子 ('<code>..</code>') と累乗演算子 ('<code>^</code>') は右結合です。
それ以外の二項演算子はすべて左結合です。





<h3>3.4.9 &ndash; <a name="3.4.9">テーブルコンストラクタ</a></h3><p>
テーブルコンストラクタはテーブルを作成する式です。
コンストラクタが評価されるたびに新しいテーブルが作成されます。
コンストラクタを使うと、空のテーブルを作成したり、テーブルを作成していくつかのフィールドを初期化したりできます。
コンストラクタの一般的な構文は以下の通りです。

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
<code>[exp1] = exp2</code> 形式のフィールドは、それぞれキー <code>exp1</code> と値
<code>exp2</code> を持つエントリを、その新しいテーブルに追加します。
<code>name = exp</code> 形式のフィールドは <code>["name"] = exp</code> と同等です。
最後に、 <code>exp</code> 形式のフィールドは <code>[i] = exp</code> と同等です。
ただし <code>i</code> は1から始まる連番の整数です。
他の形式のフィールドは、この連番に影響しません。
例えば、

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
これは以下と同等です。

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 最初のexp
       t[2] = "y"         -- 2番目のexp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3番目のexp
       t[30] = 23
       t[4] = 45          -- 4番目のexp
       a = t
     end
</pre>

<p>
コンストラクタ内の代入の順番は決まっていません。
(この順番は同じキーが複数回出現する場合にだけ意味があります。)


<p>
リストの最後のフィールドが <code>exp</code>
形式で、その式が関数呼び出しか可変長引数式であれば、その式が返したすべての値がリストに追加されます
(<a href="#3.4.10">&sect;3.4.10</a> を参照)。


<p>
機械生成コードに便利なように、フィールドのリストには省略可能な区切り文字を付けることができます。





<h3>3.4.10 &ndash; <a name="3.4.10">関数呼び出し</a></h3><p>
関数呼び出しの構文は以下の通りです。

<pre>
	functioncall ::= prefixexp args
</pre><p>
関数呼び出しでは、まずprefixexpとargsが評価されます。
prefixexpの値が<em>関数</em>型であれば、その関数が指定された引数で呼ばれます。
そうでなければ、prefixexpの "call" メタメソッドが呼ばれます。
このとき、prefixexpの値が最初の引数として渡され、その後に元の呼び出しの引数が続きます
(<a href="#2.4">&sect;2.4</a> を参照)。


<p>
以下の形式を使って「メソッド」を呼ぶことができます。

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
呼び出し <code>v:name(<em>args</em>)</code> は、
<code>v.name(v,<em>args</em>)</code> のシンタックスシュガーです。
ただし <code>v</code> の評価が一度だけである点が異なります。


<p>
引数の構文は以下の通りです。

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
すべての引数式は呼び出し前に評価されます。
<code>f{<em>fields</em>}</code> 形式の呼び出しは
<code>f({<em>fields</em>})</code>
のシンタックスシュガーであり、引数リストは新しいテーブルひとつです。
<code>f'<em>string</em>'</code>
(または <code>f"<em>string</em>"</code> または <code>f[[<em>string</em>]]</code>)
形式の呼び出しは <code>f('<em>string</em>')</code>
のシンタックスシュガーであり、引数リストはリテラル文字列ひとつです。


<p>
<code>return <em>functioncall</em></code>
形式の呼び出しは<em>末尾呼び出し</em>と言います。
Luaには<em>真正末尾呼び出し</em> (または<em>真正末尾再帰</em>) が実装されています。
つまり、末尾呼び出しでは呼び出し先の関数が呼び出し元の関数のスタックエントリを再利用します。
そのため、末尾呼び出しをネストできる数に制限がありません。
ただし、末尾呼び出しは呼び出し元の関数に関するデバッグ情報をすべて消去してしまいます。
末尾呼び出しは特定の構文においてのみ起きることに注意してください。
その構文とは、関数呼び出しひとつを引数として持つ <b>return</b> です。
つまり、呼び出し元の関数は呼び出し先の関数の戻り値をそのまま返します。
そのため、以下の例はいずれも末尾呼び出しではありません。

<pre>
     return (f(x))        -- 戻り値を1個に調節している
     return 2 * f(x)      -- 戻り値を加工している
     return x, f(x)       -- 戻り値を追加している
     f(x); return         -- 戻り値を破棄している
     return x or f(x)     -- 戻り値を1個に調節している
</pre>




<h3>3.4.11 &ndash; <a name="3.4.11">関数定義</a></h3>

<p>
関数定義の構文は以下の通りです。

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
以下のシンタックスシュガーを使うと関数定義が簡単になります。

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
以下の文は

<pre>
     function f () <em>body</em> end
</pre><p>
以下のように変換されます。

<pre>
     f = function () <em>body</em> end
</pre><p>
以下の文は

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
以下のように変換されます。

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
以下の文は

<pre>
     local function f () <em>body</em> end
</pre><p>
以下のように変換されます。

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
以下のようにではありません。

<pre>
     local f = function () <em>body</em> end
</pre><p>
(この違いは <em>body</em> から <code>f</code> を参照するときにだけ影響があります。)


<p>
関数定義は実行可能な式であり、<em>関数</em>型の値を持ちます。
チャンクをコンパイルすると、その関数の本体もすべてコンパイルされます。
その後、関数定義を実行すると、その関数が<em>インスタンス化</em>
(または<em>クローズ</em>) されます。
この関数インスタンス (または <em>クロージャ</em>) が、その式の最終的な値になります。


<p>
仮引数は、実引数の値で初期化されたローカル変数として振舞います。

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
関数が呼ばれると、実引数リストが仮引数リストの長さに調節されます。
ただし、その関数が<em>可変長引数関数</em>の場合は除きます。
可変長引数関数は仮引数リストの最後の3つのドット ('<code>...</code>') で表されます。
可変長引数関数では実引数リストが調節されません。
代わりに余分な引数がすべて集められ、<em>可変長引数式</em>としてその関数に渡されます。
可変長引数式もまた3つのドットで表されます。
この式の値は余分な実引数すべてのリストであり、複数の戻り値を持つ関数に似たものです。
可変長引数式を他の式の内部や式リストの途中で使った場合、その戻り値リストは1個の要素に調節されます。
式リストの最後の要素として使った場合、調節は行われません
(その最後の式を括弧で囲った場合を除きます)。


<p>
例えば以下の定義を考えてみてください。

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
この場合、実引数から仮引数と可変長引数式への対応関係は以下のようになります。

<pre>
     呼び出し          仮引数

     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2

     g(3)             a=3, b=nil, ... --&gt;  (なし)
     g(3, 4)          a=3, b=4,   ... --&gt;  (なし)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
戻り値は <b>return</b> 文を使って返します (<a href="#3.3.4">&sect;3.3.4</a> を参照)。
制御が <b>return</b> 文に出会わず関数の最後に達した場合、関数は戻り値なしでリターンします。


<p>
関数が返せる値の数にはシステム依存の制限があります。
この制限は1000より大きいことが保証されています。


<p>
<em>コロン</em>構文を使って<em>メソッド</em>を定義することができます。
メソッドとは暗黙の引数 <code>self</code> を余分に持つ関数です。
例えば、以下の文は
<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
以下のシンタックスシュガーです。

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>






<h2>3.5 &ndash; <a name="3.5">可視性ルール</a></h2>

<p>

Luaはレキシカルスコープを採用した言語です。
ローカル変数のスコープは、その宣言の次の文から始まり、その宣言を含む最も内側のブロックの、無でない最後の文で終わります。
以下の例を考えてみてください。

<pre>
     x = 10                -- グローバル変数
     do                    -- 新しいブロック
       local x = x         -- 新しい'x'、値は10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 別の新しいブロック
         local x = x+1     -- 別の新しい'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (グローバル変数)
</pre>

<p>
<code>local x = x</code> のような宣言の場合、右辺の
<code>x</code> は外側の変数を参照することに注意してください。
いま宣言している新しい <code>x</code> はまだスコープに入っていないためです。


<p>
レキシカルスコープのルールにより、ローカル変数はそのスコープ内で定義した関数から自由にアクセスできます。
内部関数から使われるローカル変数は、その内部関数からは<em>上位値</em>または<em>外部ローカル変数</em>と言います。


<p>
<b>local</b> 文を実行するたびに新しいローカル変数が定義されることに注意してください。
以下の例を考えてみてください。

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
このループはクロージャを10個
(つまり、無名関数のインスタンスを10個)
作成します。
これらのクロージャは、
<code>x</code> は同じものを共有していますが、
<code>y</code> はそれぞれ別々のものを持っています。





<h1>4 &ndash; <a name="4">API</a></h1>

<p>

この節ではLuaのためのCのAPI、つまりLuaとやりとりするためにホストプログラムから利用可能なCの関数について説明します。
すべてのAPI関数、関連する型、定数は、ヘッダファイル
<a name="pdf-lua.h"><code>lua.h</code></a> で宣言されています。


<p>
ここでは「関数」という言葉を使いますが、代わりにマクロとして提供されているAPIもあります。
特に記載がない限り、そういったマクロは引数を正確にただ一度だけ使用するので、
隠れた副作用は発生しません
(ただし最初の引数であるLuaステートは除きます)。


<p>
ほとんどのCのライブラリと同様に、LuaのAPIでも引数の正当性や一貫性はチェックされません。
ただし、マクロ
<a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a>
を定義してLuaをコンパイルすると、この動作を変更できます。



<h2>4.1 &ndash; <a name="4.1">スタック</a></h2>

<p>
Luaでは、Cのコードと値をやりとりするために<em>仮想的なスタック</em>を使用します。
スタック内の各要素はLuaの値(<b>nil</b>、数値、文字列など)を表します。


<p>
LuaからCを呼んだとき、呼ばれた関数には新しいスタックが用意されます。
つまり、以前のスタックや未だアクティブなCの関数が使っているスタックから独立しているということです。
初期状態では、このスタックにはそのCの関数に渡された引数がすべて格納されています。
また、そのCの関数から呼び出し元に返すための戻り値を置く場所でもあります
(<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照)。


<p>
便利なように、ほとんどの取得系APIでは厳密なスタックの規則に従っていません。
代わりにスタック内の任意の要素を<em>インデックス</em>で参照することができます。
正のインデックスはスタック内の絶対位置を表します (1から始まります)。
負のインデックスはスタックトップからの相対位置を表します。
より具体的に言うと、スタックに<em>n</em>個の要素があるとき、インデックス1は最初の要素
(つまりスタックに最初に積まれた要素)
を表し、インデックス<em>n</em>は最後の要素を表します。
またインデックス-1は最後の要素
(つまりスタックトップの要素)
を表し、インデックス<em>-n</em>は最初の要素を表します。





<h2>4.2 &ndash; <a name="4.2">スタックサイズ</a></h2>

<p>
LuaのAPIを使用するときは一貫性を保証する責任があります。
特に<em>スタックオーバーフローに対処しなければなりません</em>。
関数 <a href="#lua_checkstack"><code>lua_checkstack</code></a>
を使うと、新しい要素をスタックに積むのに十分な空き領域があることを保証できます。


<p>
LuaからCが呼ばれるとき、スタックには少なくとも
<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>
個の空きスロットがあることが保証されています。
<code>LUA_MINSTACK</code>
は20に定義されているので、通常はスタック空間について心配する必要はありません。
ただし、ループを使ってスタックにどんどん要素を積むような場合は別です。


<p>
戻り値の数を固定せずにLuaの関数を呼んだ場合
(<a href="#lua_call"><code>lua_call</code></a> を参照)、その戻り値を格納するのに十分なスタック空間は保証されますが、余分な空間が残っているかは保証されません。
そのため、そのような呼び出しの後でスタックに何らかの値を積む場合は
<a href="#lua_checkstack"><code>lua_checkstack</code></a>
を使った方がよいでしょう。





<h2>4.3 &ndash; <a name="4.3">有効なインデックスと受け入れ可能なインデックス</a></h2>

<p>
スタックインデックスを受け取るAPI関数はすべて、<em>有効なインデックス</em>または<em>受け入れ可能なインデックス</em>のみを使うことができます。


<p>
<em>有効なインデックス</em>とは変更可能なLuaの値を格納する位置を参照するインデックスです。
これには1からスタックトップまで
(<code>1 &le; abs(index) &le; top</code>)
のスタックインデックスと、<em>擬似インデックス</em>があります。

擬似インデックスは、スタック内には無いけれどもCのコードからアクセス可能ないくつかの位置を表します。
擬似インデックスはレジストリ
(<a href="#4.5">&sect;4.5</a> を参照)
やCの関数の上位値
(<a href="#4.4">&sect;4.4</a> を参照)
にアクセスするために使われます。


<p>
特定の変更可能な位置ではなく、値のみが必要な関数 (取得系関数など)
では、<em>受け入れ可能なインデックス</em>を使うことができます。
有効なインデックスはすべて受け入れ可能なインデックスでもあります。
また、スタックトップより後ろの確保済み空間を指す任意の正のインデックス
(つまりスタックサイズまでのインデックス)
も受け入れ可能なインデックスです。
(0は受け入れ可能なインデックスでないことに注意してください。)
特に記載がない限り、API関数では受け入れ可能なインデックスを使うことができます。


<p>
受け入れ可能なインデックスには、スタックから値を取得するとき、スタックトップに対する余分なチェックを回避できる効果があります。
例えば、第3引数が存在するかどうかを確認せずに、つまり、3が有効なインデックスかどうかを調べずに、第3引数の値を取得しても構いません。


<p>
受け入れ可能なインデックスを指定できる関数では、有効でないインデックスは仮想的な
<a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>
型の値を持つものとみなされます。
これはnil値と同様の振る舞いをします。





<h2>4.4 &ndash; <a name="4.4">Cのクロージャ</a></h2>

<p>
Cの関数を作成するとき、それにいくつかの値を紐付けることができます。
つまり<em>Cのクロージャ</em>を作成できます
(<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> を参照)。
これらの値は<em>上位値</em>と言い、その関数が呼ばれたときはいつでもアクセスできます。


<p>
Cの関数が呼ばれたとき、その上位値が特定の擬似インデックスに配置されます。
この擬似インデックスは
<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>
マクロで生成できます。
関数に紐付けられた最初の上位値はインデックス
<code>lua_upvalueindex(1)</code> にあり、以下同様です。
現在の関数の上位値の個数より大きな<em>n</em> (ただし256以下) を指定して
<code>lua_upvalueindex(<em>n</em>)</code>
を呼ぶと、受け入れ可能な、しかし無効なインデックスが生成されます。





<h2>4.5 &ndash; <a name="4.5">レジストリ</a></h2>

<p>
<em>レジストリ</em>は、任意のLuaの値を格納するために任意のCのコードから使うことができる、定義済みのテーブルです。
レジストリテーブルは常に、擬似インデックス
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>
の位置に配置されています。
あらゆるCのライブラリがこのテーブルにデータを格納できます。
ただし、衝突を回避するため、他のライブラリで使われないようなキーを注意深く選ぶ必要があります。
一般的には、自分のライブラリの名前を含む文字列や、自分のコード内のCのオブジェクトのアドレスを指すライトユーザーデータ、自分のコード内で作成した任意のLuaオブジェクトなどを、キーとして使うのがよいでしょう。
変数名と同様に、アンダースコアと大文字で始まる文字列のキーは、Luaが内部で使用するために予約されています。


<p>
整数のキーは、リファレンスの仕組み
(<a href="#luaL_ref"><code>luaL_ref</code></a> を参照)
やいくつかの定義済みの値によって使われています。
そのため、それ以外の目的で整数のキーを使わないでください。


<p>
新しいLuaステートを作成したとき、レジストリにはいくつか定義済みの値が格納されています。
これら定義済みの値は <code>lua.h</code> で定数として定義されている整数キーでアクセスできます。
以下の定数が定義されています。

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b>
レジストリのこのインデックスには、そのステートのメインスレッドが格納されています。
(メインスレッドとは、ステートと一緒に作成されたスレッドのことです。)
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b>
レジストリのこのインデックスには、グローバル環境が格納されています。
</li>
</ul>




<h2>4.6 &ndash; <a name="4.6">Cでのエラー処理</a></h2>

<p>
Luaではエラーを処理するために、内部的にCの <code>longjmp</code> の機能を使っています。
(LuaをC++としてコンパイルした場合は例外が使われます。
詳細はソースコード内の <code>LUAI_THROW</code> を検索してください。)
Luaが何らかのエラー
(メモリ確保エラー、型エラー、構文エラー、実行時エラーなど)
に直面すると、エラーを<em>発生</em>させます。
つまりロングジャンプを行います。
<em>保護された環境</em>は <code>setjmp</code> を使って復帰点を設定します。
あらゆるエラーは最も最近のアクティブな復帰点にジャンプします。

<p>
保護された環境の外でエラーが起きると<em>パニック関数</em>が呼び出されます
(<a href="#lua_atpanic"><code>lua_atpanic</code></a> を参照)。
その後、 <code>abort</code> が呼ばれ、ホストアプリケーションが終了します。
独自のパニック関数を用意し、その関数から戻らないようにすれば
(Luaの外に作った独自の復帰点にロングジャンプするなど)、終了を回避できます。


<p>
パニック関数はメッセージハンドラ
(<a href="#2.3">&sect;2.3</a> を参照)
であるかのように実行されます。
例えば、スタックトップにエラーメッセージが置かれます。
しかしスタック空間についての保証はありません。
スタックに何かを積む場合、まず利用可能な空き領域をチェックしなければなりません
(<a href="#4.2">&sect;4.2</a> を参照)。


<p>
APIのほとんどの関数はエラーを発生する可能性があります。
例えばメモリ確保エラーなどです。
各関数のドキュメントにエラーが発生する可能性があるかどうかについて記載してあります。


<p>
<a href="#lua_error"><code>lua_error</code></a>
を呼ぶとCの関数からエラーを発生させることができます。





<h2>4.7 &ndash; <a name="4.7">Cでのyield処理</a></h2>

<p>
Luaではコルーチンをyieldするために、内部的にCの <code>longjmp</code> の機能を使っています。
そのため、例えばCの関数 <code>foo</code> がAPI関数を呼び、そのAPI関数が
(直接的に、またはyieldする他の関数を呼ぶことによって間接的に)
yieldした場合、 <code>longjmp</code> によってCのスタックフレームが消去されるため、もはや
<code>foo</code> に戻ることはできなくなります。


<p>
この種の問題を避けるため、API呼び出しを横切ってyieldしようとするとエラーが発生します。
ただし以下の3つの関数を除きます。
<ul>
<li><a href="#lua_yieldk"><code>lua_yieldk</code></a></li>
<li><a href="#lua_callk"><code>lua_callk</code></a></li>
<li><a href="#lua_pcallk"><code>lua_pcallk</code></a></li>
</ul>
これらの関数はすべて、yield後に実行を継続するための<em>継続関数</em>を
(<code>k</code>という名前の引数で) 受け取ります。


<p>
継続を説明するには、いくつか用語の定義が必要です。
Luaから呼ばれたCの関数は<em>元の関数</em>と言うことにします。
この元の関数は上記3つのCのAPI関数のいずれかを呼びます。
これを<em>呼び出し先の関数</em>と言うことにします。
そして現在のスレッドがyieldされます。
(これが発生するのは、呼び出し先の関数が
<a href="#lua_yieldk"><code>lua_yieldk</code></a>
である場合か、呼び出し先の関数が
<a href="#lua_callk"><code>lua_callk</code></a>
または
<a href="#lua_pcallk"><code>lua_pcallk</code></a>
であり、それによって呼ばれた関数がyieldした場合です。)


<p>
呼び出し先の関数の実行中に現在のスレッドがyieldされたとしましょう。
スレッドの再開後、いずれ呼び出し先の関数は実行を終了します。
しかし、呼び出し先の関数は元の関数に戻ることができません。
元の関数のCのスタックフレームはyieldによって破壊されているためです。
代わりに<em>継続関数</em>が呼ばれます。
呼び出し先の関数に引数として渡した関数です。
名前が示すように、継続関数は元の関数の作業を継続します。

<p>
例えば以下の関数を考えてみてください。

<pre>
     int original_function (lua_State *L) {
       ...     /* コード1 */
       status = lua_pcall(L, n, m, h);  /* Luaを呼ぶ */
       ...     /* コード2 */
     }
</pre><p>
<a href="#lua_pcall"><code>lua_pcall</code></a>
で実行されるLuaのコードからyieldできるようにしたいとします。
まず、この関数を以下のように書き換えます。

<pre>
     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* コード2 */
     }

     int original_function (lua_State *L) {
       ...     /* コード1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
上のコードにある新しい関数 <code>k</code> が <em>継続関数</em> です
(<a href="#lua_KFunction"><code>lua_KFunction</code></a> 型です)。
<a href="#lua_pcall"><code>lua_pcall</code></a>
を呼んだ後に元の関数がしていた処理をすべて引き継ぐ関数です。
次に、
<a href="#lua_pcall"><code>lua_pcall</code></a>
で実行されるLuaのコードが割り込み
(エラーまたはyield)
を受けた場合に <code>k</code> を呼んでほしい旨をLuaに伝えなければなりません。
<a href="#lua_pcall"><code>lua_pcall</code></a>
を
<a href="#lua_pcallk"><code>lua_pcallk</code></a>
に変更し、コードを以下のように書き換えます。

<pre>
     int original_function (lua_State *L) {
       ...     /* コード1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
外側にある明示的な継続関数の呼び出しに注意してください。
継続関数は必要な場合にだけ呼び出されます。
つまり、エラーやyield後に再開した場合です。
呼び出し先の関数が一度もyieldせずに正常終了した場合は
<a href="#lua_pcallk"><code>lua_pcallk</code></a> (および <a href="#lua_callk"><code>lua_callk</code></a>)
も正常に戻ります。
(もちろんその場合、継続関数を呼ぶ代わりに、元の関数の中で同等の処理を直接行っても構いません。)


<p>
継続関数はLuaステート以外に2つの引数を取ります。
呼び出しの最終状態と
<a href="#lua_pcallk"><code>lua_pcallk</code></a>
に渡したコンテキスト値 (<code>ctx</code>) です。
(Luaはこのコンテキスト値を使用しません。
元の関数から継続関数に値を渡すためだけのものです。)
<a href="#lua_pcallk"><code>lua_pcallk</code></a>
では、状態は
<a href="#lua_pcall"><code>lua_pcall</code></a>
の戻り値と同じですが、yield後に実行された場合は
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
になります (<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> の代わりです)。
<a href="#lua_yieldk"><code>lua_yieldk</code></a>
および
<a href="#lua_callk"><code>lua_callk</code></a>
では、継続関数が呼ばれたとき、状態は常に
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
です。
(これら2つの関数はエラーを処理しないため、エラーの場合には継続関数が呼ばれません。)
同様に、
<a href="#lua_callk"><code>lua_callk</code></a>
を使う場合は、状態として
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
を継続関数に渡すべきです。
(<a href="#lua_yieldk"><code>lua_yieldk</code></a>
では継続関数を直接呼ぶことに大した意味はありません。
<a href="#lua_yieldk"><code>lua_yieldk</code></a>
は、通常、戻りません。)


<p>
継続関数は元の関数と同様に扱われます。
継続関数は元の関数と同じLuaのスタックを、呼び出し先の関数が戻ったばかりかのような状態で受け取ります。
(例えば <a href="#lua_callk"><code>lua_callk</code></a>
の後、関数とその引数がスタックから削除され、その呼び出しからの戻り値で置き換えられます。)
また上位値も同じものが配置されます。
戻り値は元の関数から返したかのように処理されます。





<h2>4.8 &ndash; <a name="4.8">関数と型</a></h2>

<p>
この節では、CのAPIにあるすべての関数と型の一覧をアルファベット順で掲載しています。
各関数には
<span class="apii" style="float:none;">[-o, +p, <em>x</em>]</span>
のような表示があります。


<p>
最初のフィールド <code>o</code> はスタックから削除される要素の数です。
2番目のフィールド <code>p</code> はスタックに積まれる要素の数です。
(どの関数も必ず、引数を削除してから結果を積みます。)
<code>x|y</code> 形式のフィールドは、状況に応じて
<code>x</code> 個または <code>y</code> 個の要素が積まれる (または削除される) ことを表します。
疑問符 '<code>?</code>' は、引数を見ただけでは積まれる (または削除される) 要素の数がわからないことを表します
(例えばスタックに何があるかによって変わるなど)。
3番目のフィールド <code>x</code> は、エラーが発生するかどうかを示します。
'<code>-</code>' はエラーが発生しないことを表します。
'<code>e</code>' はエラーが発生する場合があることを表します。
'<code>v</code>' は意図的にエラーを発生させる場合があることを表します。



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
受け入れ可能なインデックス <code>idx</code> を、それと同等な絶対インデックス
(つまりスタックトップに依存しないインデックス)
に変換します。





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
Luaステートで使われるメモリアロケータ関数の型です。
アロケータ関数は <code>realloc</code>
に似た機能を提供しなければなりませんが、まったく同じではありません。
引数は以下の通りです。
<ul>
<li><b><code>ud</code>: </b>
<a href="#lua_newstate"><code>lua_newstate</code></a> に渡した不透明なポインタ。</li>
<li><b><code>ptr</code>: </b>
確保/再確保/解放しようとしているブロックのポインタ。</li>
<li><b><code>osize</code>: </b>
ブロックの元のサイズ、または確保しようとしているものを表すコード。</li>
<li><b><code>nsize</code>: </b>
ブロックの新しいサイズ。</li>
</ul>


<p>
<code>ptr</code> が <code>NULL</code> でない場合、
<code>osize</code> は <code>ptr</code> が指しているブロックのサイズです。
つまりそのブロックを確保/再確保したときに渡されたサイズです。


<p>
<code>ptr</code> が <code>NULL</code> の場合、
<code>osize</code> は確保しようとしているオブジェクトの種類を表すコードで、以下の値になります。
<ul>
<li><a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a></li>
<li><a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a></li>
<li><a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a></li>
<li><a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a></li>
<li><a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a></li>
</ul>
<p>
上記以外の値の場合は上記以外のメモリを確保しようとしていることを表します。


<p>
アロケータ関数は以下のように動作するものと想定されます。


<p>
<code>nsize</code> がゼロの場合、アロケータは
<code>free</code> と同様の動作を行い、
<code>NULL</code> を返さなければなりません。


<p>
<code>nsize</code> がゼロでない場合、アロケータは
<code>realloc</code> と同様の動作をしなければなりません。
要求を満たせない場合、アロケータは <code>NULL</code> を返します。
<code>osize &gt;= nsize</code> の場合、アロケータは失敗しないものと想定されます。


<p>
アロケータ関数の単純な実装を以下に示します。
これは補助ライブラリの
<a href="#luaL_newstate"><code>luaL_newstate</code></a>
で使われているものです。

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* 未使用 */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
<code>free(NULL)</code> が何の効果もないことと、
<code>realloc(NULL,size)</code> が
<code>malloc(size)</code> と同等であることは、標準規格のCで保証されていることに注意してください。
このコードではブロックを縮小するときに <code>realloc</code> が失敗しないものと仮定しています。
(この動作は標準規格のCで保証されていませんが、安全な仮定であろうと思われます。)





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
スタックトップの2つ
(否定の場合は1つ)
の値に対して算術演算またはビット演算を行い
(トップにある方の値が第2引数になります)、それらの値を削除し、演算の結果を積みます。
この関数は、対応するLuaの演算子の意味論に従います
(つまりメタメソッドが呼ばれる場合があります)。


<p>
<code>op</code> の値は以下の定数のいずれかでなければなりません。

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 加算 (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 減算 (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 乗算 (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 浮動小数点数除算 (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> 切り捨て除算 (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> 剰余 (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 累乗 (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 反数 (単項の <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> ビットごとの否定 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> ビットごとの論理積 (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> ビットごとの論理和 (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> ビットごとの排他的論理和 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> 左シフト (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> 右シフト (<code>&gt;&gt;</code>)</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
新しいパニック関数を設定し、古いものを返します (<a href="#4.6">&sect;4.6</a> を参照)。





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
関数を呼びます。


<p>
関数を呼ぶには以下のようにします。
まず呼びたい関数をスタックに積みます。
次にその関数に渡す引数を順番通りに積みます。
つまり最初の引数を最初に積みます。
最後に <a href="#lua_call"><code>lua_call</code></a> を呼びます。
<code>nargs</code> はスタックに積んだ引数の数です。
関数を呼ぶと、その関数と引数がすべてスタックから削除されます。
関数から戻ると、その関数の戻り値がスタックに積まれます。
戻り値の数は <code>nresults</code> 個に調節されます。
ただし <code>nresults</code> が <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a> の場合は除きます。
この場合は関数の戻り値がすべて積まれます。
スタック空間は戻り値が収まるように必要に応じて伸ばされます。
関数の戻り値は順番通りにスタックに積まれます
(最初の戻り値が最初に積まれます)。
そのため呼び出しの後は最後の戻り値がスタックトップになります。


<p>
呼んだ関数の中でエラーが発生すると
(<code>longjmp</code> を使って)
上に伝播されます。


<p>
このLuaコードと同等のことをホストプログラムで行う方法を以下の例に示します。

<pre>
     a = f("how", t.x, 14)
</pre><p>
Cでは以下のようにします。

<pre>
     lua_getglobal(L, "f");       /* 呼ぶ関数 */
     lua_pushliteral(L, "how");   /* 第1引数 */
     lua_getglobal(L, "t");       /* 検索するテーブル */
     lua_getfield(L, -1, "x");    /* t.x の結果を積む (第2引数) */
     lua_remove(L, -2);           /* 't' をスタックから削除 */
     lua_pushinteger(L, 14);      /* 第3引数 */
     lua_call(L, 3, 1);           /* 3個の引数と1個の戻り値で 'f' を呼ぶ */
     lua_setglobal(L, "a");       /* グローバル変数 'a' を設定 */
</pre><p>
上記のコードは<em>釣り合いが取れている</em>ことに注意してください。
つまり最終的にスタックが元の状態に戻っています。
これは良いプログラミング習慣であると考えられます。





<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
<a href="#lua_call"><code>lua_call</code></a> とまったく同様の動作をしますが、呼んだ関数がyieldできます
(<a href="#4.7">&sect;4.7</a> を参照)。





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
Cの関数の型です。


<p>
適切にLuaとやりとりするためには、引数と戻り値を以下のように受け渡します。
Cの関数はLuaからの引数をスタックに順番通りに受け取ります
(最初の引数が最初に積まれます)。
そのため関数が開始したとき
<code>lua_gettop(L)</code> はその関数が受け取った引数の数を返します。
最初の引数 (もしあれば) はインデックス1で、最後の引数はインデックス
<code>lua_gettop(L)</code> です。
Luaに戻り値を返すには、その値を順番通りにスタックに積み
(最初の戻り値を最初に積み)、その戻り値の数を返します。
戻り値より下にある値はすべて適切に破棄されます。
Luaの関数と同様に、Luaから呼ばれるCの関数も複数の戻り値を返すことができます。


<p>
例えば、以下の関数は可変個の数値引数を受け取り、その平均と合計を返します。

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);           /* 引数の数 */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 最初の戻り値 */
       lua_pushnumber(L, sum);          /* 2番目の戻り値 */
       return 2;                        /* 戻り値の数 */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
スタックに少なくとも <code>n</code> 個の空きスロットがあることを保証します。
要求を満たせなかった場合は false を返します。
これは、スタックを固定の最大サイズ
(通常、少なくとも数千個)
より大きくしようとしたか、空きスロットのためのメモリを確保できなかったかです。
スタックが小さくなることはありません。
スタックがすでに新しいサイズよりも大きい場合は何もしません。





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
指定されたLuaステートのすべてのオブジェクトを破棄し
(もしあればガベージコレクションメタメソッドも呼び)、このステートが使用していた動的メモリをすべて解放します。
プラットフォームによっては、ホストプログラムの終了時にすべてのリソースが自動的に解放されるため、この関数を呼ぶ必要がないかもしれません。
一方、デーモンやウェブサーバのような複数のステートを作成する実行時間の長いプログラムでは、おそらく必要なくなったステートは直ちに閉じる必要があるでしょう。




<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
2つのLuaの値を比較します。
インデックス <code>index1</code> の値とインデックス <code>index2</code>
の値を比較し、 <code>op</code> を満たす場合は1を返します。
比較は対応するLuaの演算子の意味論に従います
(つまりメタメソッドが呼ばれる場合があります)。
それ以外の場合は0を返します。
いずれかのインデックスが有効でない場合も0を返します。


<p>
<code>op</code> は以下のいずれかの値でなければなりません。

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> compares for equality (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> compares for less than (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> compares for less or equal (<code>&lt;=</code>)</li>
<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> 等しい (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> より小さい (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> より小さいまたは等しい (<code>&lt;=</code>)</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
スタックトップにある <code>n</code>
個の値を連結し、それらをスタックから削除し、結果をスタックトップに置きます。
<code>n</code> が1の場合、結果はその1個の値です
(つまり何もしません)。
<code>n</code> が0の場合、結果は空文字列です。
連結はLuaの通常の意味論に従って行われます
(<a href="#3.4.6">&sect;3.4.6</a> を参照)。





<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
インデックス <code>fromidx</code> の位置にある要素を、有効なインデックス
<code>toidx</code> の位置にある要素に上書きコピーします。
それ以外の位置の要素には影響しません。





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
新しい空のテーブルを作成し、スタックに積みます。
引数 <code>narr</code> は、そのテーブルがシーケンスとして持つ予定の要素数のヒントです。
引数 <code>nrec</code> は、そのテーブルが持つ予定のそれ以外の要素数のヒントです。
これらのヒントは新しいテーブルのメモリを事前確保するために使われる場合があります。
テーブルが持つ予定の要素数があらかじめわかってる場合、この事前確保は性能向上の役に立ちます。
そうでない場合は <a href="#lua_newtable"><code>lua_newtable</code></a> を使っても構いません。





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
関数をバイナリチャンクとしてダンプします。
スタックトップにあるLuaの関数を受け取り、バイナリチャンクを生成します。
このバイナリチャンクをロードすると、ダンプした関数と同等な関数になります。
チャンクの部分部分を書き出すためにライター関数
(<a href="#lua_Writer"><code>lua_Writer</code></a> を参照)
が呼ばれ、その際に <code>data</code> が渡されます。



<p>
<code>strip</code> が真であれば、空間を節約するため、そのバイナリ表現には関数に関するすべてのデバッグ情報が含まれない場合があります。


<p>
戻り値はライターの最後の呼び出しから返されたエラーコードです。
エラーがなければ0です。


<p>
ダンプ対象のLuaの関数はスタックから削除されません。





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
スタックトップの値をエラーオブジェクトとして使用してLuaのエラーを発生させます。
ロングジャンプを行うため、この関数が戻ることはありません
(<a href="#luaL_error"><code>luaL_error</code></a> を参照)。





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
ガベージコレクタを制御します。


<p>
この関数は引数 <code>what</code> の値によっていくつかの処理を行います。

<ul>

<li><b><code>LUA_GCSTOP</code>: </b>
ガベージコレクタを停止させます。
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
ガベージコレクタを再開させます。
</li>

<li><b><code>LUA_GCCOLLECT</code>: </b>
完全なガベージコレクションサイクルを実行します。
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
Luaが使用している現在のメモリ量を (キロバイト単位で) 返します。
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
Luaが使用しているメモリの現在のバイト数を1024で割った余りを返します。
</li>

<li><b><code>LUA_GCSTEP</code>: </b>
ガベージコレクションのインクリメンタルステップをひとつ実行します。
</li>

<li><b><code>LUA_GCSETPAUSE</code>: </b>
ガベージコレクタ<em>停止期間</em>
(<a href="#2.5">&sect;2.5</a> 参照)
を <code>data</code> に変更し、以前の値を返します。
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>: </b>
ガベージコレクタ<em>ステップ係数</em>
(<a href="#2.5">&sect;2.5</a> 参照)
を <code>data</code> に変更し、以前の値を返します。
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
ガベージコレクタが動作中 (つまり停止中でない)
かどうかを示すブーリアンを返します。
</li>

</ul>

<p>
これらのオプションの詳細は
<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>
を参照してください。





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
指定されたステートのメモリアロケータ関数を返します。
<code>ud</code> が <code>NULL</code>
でなければ、そのメモリアロケータ関数を設定したときに渡された不透明なポインタが
<code>*ud</code> に格納されます。





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
<code>t[k]</code> の値をスタックに積みます。
ただし <code>t</code> は指定されたインデックスにある値です。
Luaの場合と同様に "index" イベントに対するメタメソッドが呼ばれる場合があります
(<a href="#2.4">&sect;2.4</a> 参照)。


<p>
積んだ値の型を返します。





<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
指定されたLuaステートに紐付けられた生のメモリ領域へのポインタを返します。
アプリケーションはこの領域をどのような目的で使っても構いません。
Luaはこの領域を一切使いません。


<p>
新しいスレッドを作成すると、そのスレッドのメモリ領域はメインスレッドが持つメモリ領域のコピーで初期化されます。


<p>
デフォルトでは、この領域はvoidポインタ1個分のサイズです。
Luaをコンパイルし直せばこの領域のサイズを変更できます。
(<code>luaconf.h</code> の <code>LUA_EXTRASPACE</code> を参照。)





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
グローバル変数 <code>name</code> の値をスタックに積みます。
その値の型を返します。





<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
<code>t[i]</code> の値をスタックに積みます。
ただし <code>t</code> は指定されたインデックスにある値です。
Luaの場合と同様に "index" イベントに対するメタメソッドが呼ばれる場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。


<p>
積んだ値の型を返します。





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がメタテーブルを持っていれば、そのメタテーブルをスタックに積み、1を返します。
そうでなければ0を返し、スタックに何も積みません。





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
<code>t[k]</code> の値をスタックに積みます。
ただし <code>t</code> は指定されたインデックスの値で、
<code>k</code> はスタックトップの値です。


<p>
キーはスタックから削除され、結果の値がそこに積まれます。
Luaの場合と同様に "index" イベントに対するメタメソッドが呼ばれる場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。


<p>
積んだ値の型を返します。





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
スタックトップのインデックスを返します。
インデックスは1から始まるので、この結果はスタックの要素数と等しくなります。
ちなみに0はスタックが空であることを表します。





<hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getuservalue (lua_State *L, int index);</pre>

<p>
指定されたインデックスのユーザーデータに紐付けられたLuaの値をスタックに積みます。


<p>
積んだ値の型を返します。





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
スタックトップの値を指定された有効なインデックスに移動します。
このインデックスより上にある要素は空いた隙間にずらされます。
擬似インデックスは実際のスタック位置を表していないため、この関数では使用できません。





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
Luaの整数の型です。


<p>
デフォルトでは <code>long long</code>
(一般的には2の補数表現の64ビット整数)
ですが、 <code>long</code> や <code>int</code>
(一般的には2の補数表現の32ビット整数)
に変えることもできます。
(<code>luaconf.h</code> の <code>LUA_INT_TYPE</code> を参照。)


<p>
この型の最小値および最大値を表す定数
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a>
および
<a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>
も定義されています。





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がブーリアンであれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がCの関数であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値が関数 (CまたはLuaのいずれか)
であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値が整数
(つまり、その値が数値であって、その表現が整数)
であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がライトユーザーデータであれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値が <b>nil</b>
であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
指定されたインデックスが有効でなければ1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
指定されたインデックスが有効でないか、その値が <b>nil</b>
であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値が数値であるか、数値に変換可能な文字列であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値が文字列または数値
(数値は常に文字列に変換可能)
であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がテーブルであれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がスレッドであれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がユーザーデータ
(フルはまたはライトのいずれか)
であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
指定されたコルーチンがyield可能であれば1を返し、そうでなければ0を返します。





<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
継続関数のコンテキストの型です。
数値型でなければなりません。
<code>intptr_t</code> が使用可能な場合は
<code>intptr_t</code> として定義されるため、ポインタを格納することもできます。
そうでない場合は <code>ptrdiff_t</code> として定義されます。





<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
継続関数の型です
(<a href="#4.7">&sect;4.7</a> を参照)。





<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値の長さを返します。
Luaの '<code>#</code>' 演算子
(<a href="#3.4.7">&sect;3.4.7</a> を参照)
と同等であり、 "length" イベントに対するメタメソッドが呼ばれる場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。
結果はスタックに積まれます。





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
Luaのチャンクを実行せずにロードします。
エラーがなければ、コンパイルしたチャンクがLuaの関数としてスタックトップに積まれます。


<p>
戻り値は以下のいずれかです。

<ul>

<li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> エラーなし。</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b>
コンパイル中の構文エラー。</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
メモリ確保エラー。</li>

<li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
<code>__gc</code> メタメソッド実行中のエラー。
(このエラーはロード中のチャンクとは関係ありません。
ガベージコレクタによって発生します。)
</li>

</ul>

<p>
チャンクを読み込むためにユーザー提供の <code>reader</code> 関数が使われます
(<a href="#lua_Reader"><code>lua_Reader</code></a> を参照)。
<code>data</code> 引数はこのリーダー関数に渡される不透明な値です。


<p>
<code>chunkname</code> 引数はチャンクの名前で、エラーメッセージやデバッグ情報に使われます
(<a href="#4.9">&sect;4.9</a> で参照)。


<p>
チャンクがテキストであるかバイナリであるかは自動的に判定され、その結果に応じて適切にロードされます
(<code>luac</code> プログラムを参照)。
文字列 <code>mode</code> は
<a href="#pdf-load"><code>load</code></a> のものと同様です。
ただし <code>NULL</code> の場合は文字列 "<code>bt</code>" と同等です。


<p>
<code>lua_load</code> の内部でスタックを使用するので、リーダー関数から戻るときは必ずスタックを元の状態に戻さなければなりません。


<p>
結果となる関数に上位値がある場合、その最初の上位値はレジストリのインデックス
<code>LUA_RIDX_GLOBALS</code> に格納されているグローバル環境の値に設定されます
(<a href="#4.5">&sect;4.5</a> を参照)。
メインチャンクをロードするとき、この上位値は <code>_ENV</code> 変数になります
(<a href="#2.2">&sect;2.2</a> を参照)。
それ以外の上位値は <b>nil</b> で初期化されます。




<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
新しい独立したステートで実行される新しいスレッドを作成します。
(メモリ不足により) スレッドかステートを作成できない場合は <code>NULL</code> を返します。
引数 <code>f</code> はアロケータ関数です。
このステートのためのメモリ確保はすべてこの関数を通して行われます。
第2引数 <code>ud</code> はアロケータ関数を呼ぶときに渡される不透明なポインタです。





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
新しい空のテーブルを作成し、スタックに積みます。
<code>lua_createtable(L, 0, 0)</code> と同等です。





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
新しいスレッドを作成し、それをスタックに積み、その新しいスレッドを表す
<a href="#lua_State"><code>lua_State</code></a>
へのポインタを返します。
この関数から返される新しいスレッドはグローバル環境を元のスレッドと共有しますが、実行スタックは別々です。


<p>
スレッドを閉じたり破棄したりする明示的な関数はありません。
スレッドは他のLuaオブジェクト同様にガベージコレクションの対象です。





<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
指定されたサイズの新しいメモリブロックを確保し、そのブロックのアドレスを持つ新しいフルユーザーデータをスタックに積み、そのアドレスを返します。
このメモリはホストプログラム側で自由に使用できます。





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
スタックからキーを削除し、指定されたインデックスのテーブルからキーと値のペア
(指定されたキーの「次の」ペア)
を積みます。
テーブルにそれ以上要素がなければ (何も積まずに) 0を返します。


<p>
一般的な使い方は以下のようなものです。

<pre>
     /* テーブルはスタックのインデックス 't' にあります */
     lua_pushnil(L);  /* 最初のキー */
     while (lua_next(L, t) != 0) {
       /* 「キー」 (インデックス-2) と「値」 (インデックス-1) を使います */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 「値」を削除、「キー」は次の繰り返しのために残しておきます */
       lua_pop(L, 1);
     }
</pre>

<p>
テーブルを巡回している間、キーに対して直接
<a href="#lua_tolstring"><code>lua_tolstring</code></a>
を呼ばないでください
(そのキーが実際に文字列であるとわかっている場合は除きます)。
<a href="#lua_tolstring"><code>lua_tolstring</code></a>
は指定されたインデックスの値を変更する場合があるため、次に
<a href="#lua_next"><code>lua_next</code></a>
を呼んだときに問題が生じます。


<p>
巡回中にテーブルを変更する場合の注意点について
<a href="#pdf-next"><code>next</code></a>
関数を参照してください。





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
Luaの浮動小数点数の型です。


<p>
デフォルトでは double ですが、 float や long double に変更することもできます。
(<code>luaconf.h</code> の <code>LUA_FLOAT_TYPE</code> を参照。)





<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
Luaの浮動小数点数をLuaの整数に変換します。
<code>n</code> は小数点以下の端数がないものと仮定されます。
その値がLuaの整数の範囲内であれば整数に変換され、
<code>*p</code> に代入されます。
このマクロは変換が成功したかどうかを表すブーリアン値を返します。
(ちなみに、この範囲チェックをこのマクロを使わずに正しく行うのは、丸めの問題があるため少々トリッキーなものになります。)


<p>
このマクロは引数を2回以上評価する場合があります。





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
保護モードで関数を呼びます。


<p>
<code>nargs</code> と <code>nresults</code> は両方とも
<a href="#lua_call"><code>lua_call</code></a> の場合と同じ意味です。
呼び出しの間にエラーが発生しなければ、
<a href="#lua_pcall"><code>lua_pcall</code></a>
は
<a href="#lua_call"><code>lua_call</code></a>
とまったく同様の動作をします。
しかし何らかのエラーが発生した場合、それは
<a href="#lua_pcall"><code>lua_pcall</code></a>
によってキャッチされ、ひとつの値 (エラーメッセージ)
をスタックに積み、エラーコードを返します。
<a href="#lua_call"><code>lua_call</code></a>
と同様に、関数と引数は常にスタックから削除されます。


<p>
<code>msgh</code> が0であれば、スタック上に返されるエラーメッセージは元のエラーメッセージそのままです。
そうでなければ、 <code>msgh</code> は<em>メッセージハンドラ</em>のスタックインデックスです。
(擬似インデックスは使えません。)
実行時エラーが発生すると、エラーメッセージを引数としてその関数が呼ばれ、その戻り値が
<a href="#lua_pcall"><code>lua_pcall</code></a>
からスタック上に返されるメッセージになります。


<p>
一般的に、メッセージハンドラはエラーメッセージにさらなるデバッグ情報を付加するために使われます。
例えばスタックトレースなどです。
そういった情報は
<a href="#lua_pcall"><code>lua_pcall</code></a>
から戻った後では収集することができません。
スタックが巻き戻されるためです。


<p>
<a href="#lua_pcall"><code>lua_pcall</code></a>
関数は以下の定数のいずれかを返します
(<code>lua.h</code> で定義されています)。


<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b>
成功。</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b>
実行時エラー。
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
メモリ確保エラー。
このようなエラーの場合、メッセージハンドラは呼ばれません。
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b>
メッセージハンドラ実行中のエラー。
</li>

<li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
<code>__gc</code> メタメソッド実行中のエラー。
(このエラーは一般的に、呼んだ関数とは関係ありません。)
</li>

</ul>




<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
<a href="#lua_pcall"><code>lua_pcall</code></a>
とまったく同様の動作をしますが、呼んだ関数の中でyieldできます
(<a href="#4.7">&sect;4.7</a> を参照)。





<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, &ndash;]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
スタックから <code>n</code> 個の要素を削除します。





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
<code>b</code> の値を持つブーリアン値をスタックに積みます。





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
新しいCのクロージャをスタックに積みます。


<p>
Cの関数を作成するとき、それにいくつかの値を紐付けることができます。
つまりCのクロージャを作成できます (<a href="#4.4">&sect;4.4</a> を参照)。
その関数が呼ばれたときはいつでもその値にアクセスすることができます。
Cの関数に値を紐付けるには、まずその値をスタックに積みます
(値が複数ある場合は、最初の値を最初に積みます)。
次に
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
を呼び、Cの関数を作成してスタックに積みます。
このとき関数に紐付けたい値の数を引数 <code>n</code> に指定します。
これらの値もスタックから削除されます。


<p>
<code>n</code> の最大値は255です。


<p>
<code>n</code> がゼロの場合は<em>軽量なCの関数</em>が作成されます。
これはそのCの関数への単なるポインタです。
この場合、メモリエラーが発生することはありません。





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Cの関数をスタックに積みます。
この関数は、Cの関数へのポインタを受け取り、<em>関数</em>型のLuaの値をスタックに積みます。
この値が呼ばれると、対応するCの関数が呼ばれます。


<p>
Luaから呼ばれる関数はすべて、引数と戻り値の正しい受け渡し方法に従わなければなりません
(<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照)。





<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
書式化した文字列をスタックに積み、その文字列へのポインタを返します。
ISO Cのsprintf関数に似ていますが、重要な違いがいくつかあります。

<ul>

<li>
結果を格納する空間を自分で確保する必要はありません。
結果はLuaの文字列であり、Luaがメモリ確保の面倒を見ます
(そしてガベージコレクションによって自動的に解放されます)。
</li>

<li>
変換指定子は非常に制限されています。
フラグ、幅、精度はありません。
以下変換指定子のみが使用可能です。
<ul>
<li><b>'<code>%%</code>': </b>
文字 '<code>%</code>' を挿入します。</li>
<li><b>'<code>%s</code>': </b>
ゼロ終端文字列を挿入します。
サイズ制限はありません。</li>
<li><b>'<code>%f</code>': </b>
<a href="#lua_Number"><code>lua_Number</code></a> を挿入します。</li>
<li><b>'<code>%I</code>': </b>
<a href="#lua_Integer"><code>lua_Integer</code></a> を挿入します。</li>
<li><b>'<code>%p</code>': </b>
ポインタを16進数として挿入します。</li>
<li><b>'<code>%d</code>': </b>
<code>int</code> を挿入します。</li>
<li><b>'<code>%c</code>': </b>
<code>int</code> を1バイト文字として挿入します。</li>
<li><b>'<code>%U</code>': </b>
<code>long int</code> をUTF-8バイトシーケンスとして挿入します。</li>
</ul>
</li>

</ul>




<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
グローバル環境をスタックに積みます。





<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
<code>n</code> の値を持つ整数をスタックに積みます。





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
ライトユーザーデータをスタックに積みます。


<p>
ユーザーデータはCの値をLuaで表現したものです。
<em>ライトユーザーデータ</em>はポインタ、つまり <code>void*</code> を表します。
これは値です (数値と同様です)。
つまり作成する必要はなく、個別のメタテーブルを持たず、
(作成されないため) 回収されません。
ライトユーザーデータは同じCのアドレスを持つ「どの」ライトユーザーデータとも等しくなります。





<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
このマクロは
<a href="#lua_pushstring"><code>lua_pushstring</code></a>
と同等ですが、 <code>s</code> がリテラル文字列である場合にだけ使うべきです。





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
<code>s</code> が指しているサイズ <code>len</code> の文字列をスタックに積みます。
指定された文字列は内部コピーが作成される (または再利用される) ため、
<code>s</code> が指しているメモリはこの関数から戻った直後に自由に解放したり再利用したりできます。
文字列はゼロを含む任意のバイナリを持つことができます。


<p>
その文字列の内部コピーを指すポインタを返します。





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
nil値をスタックに積みます。





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
<code>n</code> の値を持つ浮動小数点数をスタックに積みます。





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
<code>s</code> が指しているゼロ終端文字列をスタックに積みます。
指定された文字列は内部コピーが作成される (または再利用される) ため、
<code>s</code> が指しているメモリはこの関数から戻った直後に自由に解放したり再利用したりできます。


<p>
その文字列の内部コピーを指すポインタを返します。


<p>
<code>s</code> が <code>NULL</code> の場合は
<b>nil</b> を積み、 <code>NULL</code> を返します。





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
<code>L</code> が表しているスレッドをスタックに積みます。
このステートのスレッドがメインスレッドであれば1を返します。





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
指定されたインデックスの要素のコピーをスタックに積みます。





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>
と同等ですが、可変長引数の代わりに <code>va_list</code> を取ります。





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
インデックス <code>index1</code> と <code>index2</code>
の2つの値が生で (つまりメタメソッドを呼ばずに) 等しければ1を返します。
そうでなければ0を返します。
いずれかのインデックスが有効でない場合も0を返します。





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
<a href="#lua_gettable"><code>lua_gettable</code></a>
に似ていますが、生のアクセス (つまりメタメソッドなし) を行います。





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
<code>t[n]</code> の値をスタックに積みます。
ただし
<code>t</code> は指定されたインデックスのテーブルです。
アクセスは生です。
つまりメタメソッドは呼ばれません。


<p>
積んだ値の型を返します。





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
<code>t[k]</code> の値をスタックに積みます。
ただし
<code>t</code> は指定されたインデックスのテーブルで、
<code>k</code> はポインタ <code>p</code> をライトユーザーデータとして表現したものです。
アクセスは生です。
つまりメタメソッドは呼ばれません。


<p>
積んだ値の型を返します。





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値の生の「長さ」を返します。
文字列の場合はその文字列の長さです。
テーブルの場合は長さ演算子 ('<code>#</code>') の結果です。
ただしメタメソッドは呼ばれません。
ユーザーデータの場合は、そのユーザーデータに割り当てられたメモリブロックのサイズです。
それ以外の場合は0です。





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
<a href="#lua_settable"><code>lua_settable</code></a>
と似ていますが、生の代入 (つまりメタメソッドなし) を行います。





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
<code>t[i] = v</code> と同等のことを行います。
ただし
<code>t</code> は指定されたインデックスのテーブルで、
<code>v</code> はスタックトップの値です。


<p>
値はスタックから削除されます。
代入は生です。
つまりメタメソッドは呼ばれません。





<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
<code>t[p] = v</code> と同等のことを行います。
ただし
<code>t</code> は指定されたインデックスのテーブル、
<code>p</code> はライトユーザーデータとして符号化されたポインタ、
<code>v</code> はスタックトップの値です。


<p>
値はスタックから削除されます。
代入は生です。
つまりメタメソッドは呼ばれません。





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
<a href="#lua_load"><code>lua_load</code></a>
で使われるリーダー関数です。
チャンクの新しい断片が必要になるたびに
<a href="#lua_load"><code>lua_load</code></a> から呼ばれ、
<code>data</code> 引数が渡されます。
リーダー関数は、チャンクの新しい断片を入れたメモリブロックへのポインタを返し、
<code>size</code> にそのブロックのサイズを設定しなければなりません。
このブロックはリーダー関数がもう一度呼ばれるまで存在していなければなりません。
チャンクの終わりを知らせるには
<code>NULL</code> を返すか、 <code>size</code> をゼロに設定しなければなりません。
リーダー関数は1以上の任意のサイズの断片を返すことができます。





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
グローバル変数 <code>name</code> の新しい値として、Cの関数 <code>f</code> を設定します。
これは以下のようなマクロとして定義されています。

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
指定された有効なインデックスの要素を削除し、それより上の要素を隙間を埋めるため下にずらします。
この関数では擬似インデックスを使うことはできません。
擬似インデックスは実際のスタック位置ではないためです。





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
スタックトップの要素を指定された有効なインデックスに移動し、そのスタックトップの要素を削除します
(それ以外の要素は移動しません。
つまり指定されたインデックスの値を置換します)。





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs);</pre>

<p>
指定されたスレッド <code>L</code> のコルーチンを開始および再開させます。


<p>
コルーチンを開始するには、メイン関数と引数をスレッドのスタックに積み、
<a href="#lua_resume"><code>lua_resume</code></a> を呼びます。
<code>nargs</code> は引数の数です。
コルーチンの実行が中断するか終了すると呼び出しから戻ります。
戻ったとき、スタックには
<a href="#lua_yield"><code>lua_yield</code></a>
に渡されたすべての値、または本体の関数から返されたすべての値が置かれています。
コルーチンがyieldした場合は
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
を返します。
エラーを発生せずにコルーチンが実行終了した場合は
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
を返します。
エラーが発生した場合はエラーコードを返します
(<a href="#lua_pcall"><code>lua_pcall</code></a> を参照)。


<p>
エラーが発生した場合、スタックは巻き戻されません。
そのためデバッグAPIを使うことができます。
スタックトップにエラーメッセージがあります。


<p>
コルーチンを再開するには、最後の
<a href="#lua_yield"><code>lua_yield</code></a>
からすべての戻り値を削除し、
<code>yield</code> からの戻り値として渡す値だけをスタックに積み、それから
<a href="#lua_resume"><code>lua_resume</code></a>
を呼びます。


<p>
引数 <code>from</code> は <code>L</code> を再開するコルーチンを表します。
そのようなコルーチンがない場合は <code>NULL</code> を指定できます。





<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
有効なインデックス <code>idx</code> とスタックトップの間のスタック要素を回転させます。
<code>n</code> が正の場合はトップ方向に <code>n</code> 個分、
<code>n</code> が負の場合はボトム方向に <code>-n</code> 個分回転します。
<code>n</code> の絶対値を回転させる部分のサイズより大きくしてはなりません。
この関数では擬似インデックスを使うことはできません。
擬似インデックスは実際のスタック位置ではないためです。





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
指定されたステートのアロケータ関数を <code>f</code>
に、そのユーザーデータを <code>ud</code> に変更します。





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
<code>t[k] = v</code> と同等のことを行います。
ただし
<code>t</code> は指定されたインデックスの値で、
<code>v</code> はスタックトップの値です。


<p>
値はスタックから削除されます。
Luaの場合と同様に "newindex" イベントのメタメソッドが呼ばれる場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
スタックから値を削除し、それをグローバル変数
<code>name</code> の新しい値に設定します。





<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
<code>t[n] = v</code> と同等のことをします。
ただし
<code>t</code> は指定されたインデックスの値で、
<code>v</code> はスタックトップの値です。


<p>
値はスタックから削除されます。
Lua の場合と同様に "newindex" イベントのメタメソッドが呼ばれる場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。





<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>

<p>
スタックからテーブルを削除し、
そのテーブルを指定されたインデックスの値の新しいメタテーブルとして設定します。





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
<code>t[k] = v</code> と同等のことをします。
ただし
<code>t</code> は指定されたインデックスの値、
<code>v</code> はスタックトップの値で、
<code>k</code> はスタックトップのひとつ下の値です。


<p>
キーと値は両方ともスタックから削除されます。
Luaの場合と同様に "newindex" イベントのメタメソッドが呼ばれる場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。




<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
任意のインデックスまたは0を受け取り、
スタックトップをそのインデックスにします。
新しいスタックトップが古いスタックトップより大きい場合、新しい要素は
<b>nil</b> で埋められます。
<code>index</code> が0の場合、スタックの要素はすべて削除されます。





<hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>

<p>
値をスタックから削除し、それを指定されたインデックスのユーザーデータに関連付けます。





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
スレッドおよび (そのスレッドを通して)
間接的にLuaインタプリタのステート全体を指す不透明な構造体です。
Luaのライブラリは完全に再入可能です。
つまりグローバル変数を持ちません。
ステートに関する情報はすべて、この構造体を通してアクセスされます。


<p>
ライブラリのどの関数にも最初の引数としてこの構造体へのポインタを渡さなければなりません。
ただしゼロからLuaステートを作成する
<a href="#lua_newstate"><code>lua_newstate</code></a> は除きます。





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
スレッド <code>L</code> の状態を返します。


<p>
状態は、通常のスレッドの場合は0
(<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>)、
<a href="#lua_resume"><code>lua_resume</code></a>
で実行したスレッドがエラー終了した場合はエラーコード、スレッドが中断している場合は
<a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> です。


<p>
関数の呼び出しは状態が
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
のスレッドでのみ行うことができます。
再開は状態が
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> (新しいコルーチンを再開する場合)
または
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> (コルーチンを再開する場合)
のスレッドに対して行うことができます。





<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
ゼロ終端文字列 <code>s</code>
を数値に変換し、その数値をスタックに積み、その文字列の合計サイズ、つまり長さプラス1を返します。
変換結果はLuaの字句規約に従って整数か浮動小数点数になります
(<a href="#3.1">&sect;3.1</a> を参照)。
文字列の前後に空白があってもよく、符号が付いていても構いません。
文字列が有効な数値でなかった場合は0が返され、スタックには何も積まれません。
(この戻り値はブーリアンとみなすことができます。
つまり変換が成功した場合は真です。)





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
指定されたインデックスのLuaの値をブーリアン値 (0または1) に変換します。
Luaの条件判定と同様に <b>false</b> と <b>nil</b>
以外のすべてのLuaの値に対して真を返し、それ以外は偽を返します。
(実際のブーリアン値のみを受け入れたい場合は
<a href="#lua_isboolean"><code>lua_isboolean</code></a>
を使ってその値の型をチェックしてください。)




<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値をCの関数に変換します。
この値はCの関数でなければなりません。
そうでなければ <code>NULL</code> を返します。





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
<a href="#lua_tointegerx"><code>lua_tointegerx</code></a>
の <code>isnum</code> に <code>NULL</code> を渡した場合と同等です。





<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
指定されたインデックスのLuaの値を符号付き整数型 <a href="#lua_Integer"><code>lua_Integer</code></a> に変換します。
このLuaの値は整数か、整数に変換可能な数値または文字列
(<a href="#3.4.3">&sect;3.4.3</a> を参照)
でなければなりません。
そうでなければ0を返します。


<p>
<code>isnum</code> が <code>NULL</code>
でなければ、その参照先に操作が成功したかどうかを示すブーリアン値が格納されます。





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
指定されたインデックスのLuaの値をCの文字列に変換します。
<code>len</code> が <code>NULL</code> でなければ、
<code>*len</code> にその文字列の長さが設定されます。
このLuaの値は文字列か数値でなければなりません。
そうでなければ <code>NULL</code> を返します。
値が数値の場合、<em>そのスタック内の値は実際に文字列に変換されます</em>。
(この変換はテーブル巡回中のキーに対して適用すると
<a href="#lua_next"><code>lua_next</code></a> を混乱させます。)


<p>
<code>lua_tolstring</code> は、Luaステートの内部の文字列を指す、完全にアラインメントされたポインタを返します。
この文字列は (Cのように) 最後の文字の後に必ずゼロ ('<code>\0</code>')
を持ちますが、途中にもゼロが含まれる場合があります。


<p>
Luaはガベージコレクションを行うため、 <code>lua_tolstring</code>
から返されたポインタが、対応するLuaの値がスタックから削除された後も有効かどうかは、保証されていません。





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
<a href="#lua_tonumberx"><code>lua_tonumberx</code></a>
の <code>isnum</code> に <code>NULL</code> を渡した場合と同等です。





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
指定されたインデックスのLuaの値をCの型
<a href="#lua_Number"><code>lua_Number</code></a>
に変換します。
このLuaの値は数値か、数値に変換可能な文字列
(<a href="#3.4.3">&sect;3.4.3</a> を参照)
でなければなりません。
そうでなければ0を返します。


<p>
<code>isnum</code> が <code>NULL</code>
でなければ、その参照先に操作が成功したかどうかを示すブーリアン値が格納されます。





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値をCの汎用ポインタ (<code>void*</code>) に変換します。
この値はユーザーデータ、テーブル、スレッドまたは関数でなければなりません。
そうでなければ <code>NULL</code> を返します。
異なるオブジェクトには異なるポインタが返されます。
このポインタから元の値に戻す方法はありません。


<p>
通常、この関数はハッシュとデバッグ情報のためにのみ使われます。





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
<a href="#lua_tolstring"><code>lua_tolstring</code></a>
で <code>len</code> に <code>NULL</code> を渡した場合と同等です。





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値をLuaのスレッドに変換します
(<code>lua_State*</code> として表されます)。
この値はスレッドでなければなりません。
そうでなければ <code>NULL</code> を返します。





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値がフルユーザーデータであれば、そのブロックアドレスを返します。
値がライトユーザーデータであれば、そのポインタを返します。
そうでなければ <code>NULL</code> を返します。





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値の型を返します。
有効でない (しかし受け入れ可能な) インデックスに対しては
<code>LUA_TNONE</code> を返します。
<a href="#lua_type"><code>lua_type</code></a>
が返す型は <code>lua.h</code> で定義されている以下の定数で符号化されます。
<ul>
<li><a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a> (0)
<li><a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>
<li><a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>
<li><a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>
<li><a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>
<li><a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>
<li><a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>
<li><a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>
<li><a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>
</ul>





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
値 <code>tp</code> に符号化された型の名前を返します。
この値は <a href="#lua_type"><code>lua_type</code></a>
が返す値のいずれかでなければなりません。





<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
<a href="#lua_Integer"><code>lua_Integer</code></a> の符号なし版です。





<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
実行中の関数の <code>i</code> 番目の上位値を表す擬似インデックスを返します
(<a href="#4.4">&sect;4.4</a> を参照)。





<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>

<p>
Luaのコアに格納されているバージョン番号のアドレスを返します。
有効な <a href="#lua_State"><code>lua_State</code></a>
を渡した場合は、そのステートを作成するのに使われたバージョンのアドレスを返します。
<code>NULL</code> を渡した場合は、その呼び出しを実行しているバージョンのアドレスを返します。





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
<a href="#lua_dump"><code>lua_dump</code></a>
で使われるライター関数の型です。
新しいチャンクの断片が生成されるたびに
<a href="#lua_dump"><code>lua_dump</code></a>
から呼ばれ、出力されるバッファ (<code>p</code>)
とそのサイズ (<code>sz</code>)、および
<a href="#lua_dump"><code>lua_dump</code></a>
に渡した <code>data</code> 引数が渡されます。


<p>
ライター関数はエラーコードを返します。
0はエラー無しを表します。
それ以外の値はすべてエラーを表し、
<a href="#lua_dump"><code>lua_dump</code></a>
を停止してライター関数をそれ以上呼ばれなくします。





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
同じステートの異なるスレッド間で値を交換します。


<p>
<code>from</code> のスタックから <code>n</code> 個の値を削除し、
<code>to</code> のスタックにそれらを積みます。





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
<a href="#lua_yieldk"><code>lua_yieldk</code></a>
と同等ですが、継続を取りません (<a href="#4.7">&sect;4.7</a> を参照)。
そのためスレッドが再開したときは呼び出し元の関数から再開されます。





<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
コルーチン (スレッド) をyieldします。


<p>
<a href="#lua_yieldk"><code>lua_yieldk</code></a>
を呼ぶと、実行中のコルーチンはその実行を一時停止し、そのコルーチンを開始した
<a href="#lua_resume"><code>lua_resume</code></a>
の呼び出しから戻ります。
引数 <code>nresults</code> は
<a href="#lua_resume"><code>lua_resume</code></a>
に戻り値として渡すスタック上の値の数です。


<p>
コルーチンが再び再開すると、yieldしたCの関数の実行を続行するために指定された継続関数
<code>k</code> が呼ばれます
(<a href="#4.7">&sect;4.7</a> を参照)。
この継続関数は以前の関数と同じスタックを受け取ります。
ただし <code>n</code> 個の戻り値は削除され、
<a href="#lua_resume"><code>lua_resume</code></a>
に渡された引数に置き換えられます。
さらに継続関数は
<a href="#lua_yieldk"><code>lua_yieldk</code></a>
に渡した値 <code>ctx</code> を受け取ります。


<p>
通常、この関数は戻りません。
コルーチンが再開するときは継続関数から実行が再開されます。
ただし特別な場合がひとつあります。
それは行フック (<a href="#4.9">&sect;4.9</a> を参照) の内部で呼ばれたときです。
この場合、
<code>lua_yieldk</code> は継続無しで
(おそらく <a href="#lua_yield"><code>lua_yield</code></a> の形で)
呼ばれるべきであり、そのフックはこの呼び出しの直後に戻るべきです。
コルーチンをyieldし、そして再開するとき、そのフックを呼び出した
(Luaの) 関数から通常の実行が続行されます。


<p>
保留中のCの呼び出しに継続関数が無い場合、
またはresumeの内部で実行されていないスレッド (すなわちメインスレッド)
から呼ばれた場合は、エラーが発生します。







<h2>4.9 &ndash; <a name="4.9">デバッグインタフェース</a></h2>

<p>
Luaには組み込みのデバッグ機能がありません。
代わりに関数および<em>フック</em>の形で特別なインタフェースが用意されています。
このインタフェースを使うと、デバッガやプロファイラなど、インタプリタの「内部情報」を必要とする様々な種類のツールを作ることができます。



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>
関数またはアクティベーションレコードに関する様々な情報を受け渡すために使われる構造体です。
<a href="#lua_getstack"><code>lua_getstack</code></a>
は、後の利用のために、この構造体のプライベートな部分のみを埋めます。
それ以外のフィールドを役に立つ情報で埋めるには
<a href="#lua_getinfo"><code>lua_getinfo</code></a>
を呼んでください。


<p>
<a href="#lua_Debug"><code>lua_Debug</code></a>
の各フィールドの意味は以下の通りです。

<ul>

<li><b><code>source</code>: </b>
その関数を作成したチャンクの名前です。
<code>source</code> が '<code>@</code>'
で始まっている場合、それは '<code>@</code>'
の後の名前のファイルで定義された関数だという意味です。
<code>source</code> が '<code>=</code>'
で始まっている場合、その残りの部分はユーザー依存の方法で記述されたソースの説明です。
それ以外の場合、その関数は文字列内で定義された関数であり、
<code>source</code> がその文字列です。
</li>

<li><b><code>short_src</code>: </b>
エラーメッセージに使うための、
<code>source</code> の「印刷可能」なバージョンです。
</li>

<li><b><code>linedefined</code>: </b>
その関数の定義が始まる位置の行番号です。
</li>

<li><b><code>lastlinedefined</code>: </b>
その関数の定義が終わる位置の行番号です。
</li>

<li><b><code>what</code>: </b>
その関数がLuaの関数であれば文字列 <code>"Lua"</code>、
Cの関数であれば <code>"C"</code>、
チャンクのメイン部分であれば <code>"main"</code> です。
</li>

<li><b><code>currentline</code>: </b>
その関数の現在の実行位置の行です。
行番号情報が利用可能でなければ-1に設定されます。
</li>

<li><b><code>name</code>: </b>
その関数に対する適当な名前です。
Luaの関数はファーストクラスの値であるため固定の名前を持ちません。
関数によっては複数のグローバル変数に格納されているかもしれません。
テーブルフィールドにのみ格納されている関数もあるでしょう。
<code>lua_getinfo</code>
関数は、その関数がどのように呼ばれたのかを調べて、良さそうな名前を探します。
名前が見つからなければ <code>NULL</code> に設定されます。
</li>

<li><b><code>namewhat</code>: </b>
<code>name</code> フィールドの説明です。
その関数がどのように呼ばれたのかに応じて以下のいずれかの値になります。
<ul>
<li><code>"global"</code>
<li><code>"local"</code>
<li><code>"method"</code>
<li><code>"field"</code>
<li><code>"upvalue"</code>
<li><code>""</code> (空文字列)
</ul>
(適用できそうな選択肢がなければ空文字列になります。)
</li>

<li><b><code>istailcall</code>: </b>
その関数呼び出しが末尾呼び出しであれば真になります。
その場合、その呼び出しの呼び出し元はスタックに残っていません。
</li>

<li><b><code>nups</code>: </b>
その関数の上位値の数です。
</li>

<li><b><code>nparams</code>: </b>
その関数の固定引数の数です
(Cの関数の場合は必ず0になります)。
</li>

<li><b><code>isvararg</code>: </b>
その関数が可変長引数を持つ場合は真になります。
(Cの関数の場合は必ず真になります)。
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
現在のフック関数を返します。





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
現在のフックカウントを返します。





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
現在のフックマスクを返します。





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
指定された関数または関数呼び出しに関する情報を取得します。


<p>
関数呼び出しに関する情報を取得する場合、
引数 <code>ar</code> は、事前に
<a href="#lua_getstack"><code>lua_getstack</code></a>
の呼び出しによって埋められたか、フック
(<a href="#lua_Hook"><code>lua_Hook</code></a> を参照)
に引数として渡された、有効なアクティベーションレコードでなければなりません。


<p>
関数に関する情報を取得する場合は、その関数をスタックに積み、文字列
<code>what</code> の最初の文字を '<code>&gt;</code>' にします。
(この場合、その関数はスタックトップから取り出され、削除されます。)
例えば関数 <code>f</code>
が定義された行を知りたい場合、以下のようなコードを書きます。

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* グローバル変数 'f' を取得 */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
文字列 <code>what</code> の各文字により、構造体 <code>ar</code>
の埋めるフィールドやスタックに積む値を指定します。

<ul>

<li><b>'<code>n</code>': </b>
フィールド <code>name</code>、
<code>namewhat</code> を埋めます。
</li>

<li><b>'<code>S</code>': </b>
フィールド
<code>source</code>、
<code>short_src</code>、
<code>linedefined</code>、
<code>lastlinedefined</code>、
<code>what</code>
を埋めます。
</li>

<li><b>'<code>l</code>': </b>
フィールド <code>currentline</code> を埋めます。
</li>

<li><b>'<code>t</code>': </b>
フィールド <code>istailcall</code> を埋めます。
</li>

<li><b>'<code>u</code>': </b>
フィールド <code>nups</code>、
<code>nparams</code>、
<code>isvararg</code>
を埋めます。
</li>

<li><b>'<code>f</code>': </b>
指定されたレベルで実行中の関数をスタックに積みます。
</li>

<li><b>'<code>L</code>': </b>
その関数の有効な行番号をインデックスに持つテーブルをスタックに積みます。
(<em>有効な行</em>とは何らかのコードが関連付けられている行です。
つまりブレークポイントを設置することができる行のことです。
空行やコメントは有効な行ではありません。)


<p>
このオプションがオプション '<code>f</code>' と一緒に使われた場合、
このテーブルは関数の後に積まれます。
</li>

</ul>

<p>
この関数はエラーの場合
(例えば <code>what</code> に無効なオプションを指定された場合)
0を返します。





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
指定されたアクティベーションレコード、または指定された関数の、ローカル変数に関する情報を取得します。


<p>
前者の場合、引数 <code>ar</code> は、事前に
<a href="#lua_getstack"><code>lua_getstack</code></a>
の呼び出しによって埋められたか、
フック (<a href="#lua_Hook"><code>lua_Hook</code></a> を参照)
に引数として渡された、有効なアクティベーションレコードでなければなりません。
インデックス <code>n</code> で調査するローカル変数を選びます。
変数のインデックスと名前については
<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>
を参照してください。

<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a>
は、その変数の値をスタックに積み、その名前を返します。


<p>
後者の場合、
<code>ar</code> には <code>NULL</code>
を指定し、関数はスタックトップに置かなければなりません。
この場合はLuaの関数の引数のみを見ることができ
(アクティブな変数についての情報はないため)、
スタックに積まれる値はありません。


<p>
インデックスがアクティブなローカル変数の数より大きい場合は
<code>NULL</code> を返します (そして何も積みません)。





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
インタプリタのランタイムスタックについての情報を取得します。


<p>
指定されたレベルで実行中の関数の<em>アクティベーションレコード</em>の識別情報で、
<a href="#lua_Debug"><code>lua_Debug</code></a>
構造体の一部が埋められます。
レベル0は現在実行中の関数、
レベル<em>n+1</em>はレベル<em>n</em>の呼び出し元の関数です
(スタックに残らない末尾呼び出しは除きます)。
エラーがなければ1を返します。
スタックの深さよりも大きなレベルが指定された場合は0を返します。





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
インデックス <code>funcindex</code> のクロージャの
<code>n</code> 番目の上位値に関する情報を取得します。
その上位値の値をスタックに積み、その名前を返します。
インデックス <code>n</code> が上位値の数より大きい場合は
<code>NULL</code> を返します (そして何も積みません)。


<p>
Cの関数の場合は、どの上位値に対しても、名前として空文字列
<code>""</code> が返されます。
(Luaの関数の場合は、上位値はその関数が使用しているためにクロージャに含まれている外部ローカル変数です。)


<p>
上位値は関数全体にわたってアクティブであり、特定の順番はありません。
適当な順番で番号付けられます。





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
デバッグフック関数の型です。


<p>
フックが呼ばれると、引数 <code>ar</code> のフィールド
<code>event</code> に、そのフックの原因となったイベントが設定されます。
これらのイベントは以下の定数で表されます。
<ul>
<li><a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>
<li><a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>
<li><a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>
<li><a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>
<li><a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>
</ul>
さらに、lineイベントの場合はフィールド <code>currentline</code> も設定されます。
<code>ar</code> のそれ以外のフィールドの値を取得する場合は
<a href="#lua_getinfo"><code>lua_getinfo</code></a>
を呼ばなければなりません。


<p>
callイベントの場合、
<code>event</code> は <code>LUA_HOOKCALL</code> (通常の値)
または <code>LUA_HOOKTAILCALL</code> (末尾呼び出しの場合) です。
後者の場合、対応するreturnイベントはありません。


<p>
フックを実行中の間、さらなるフックの呼び出しは無効化されます。
そのため、フックから関数やチャンクを実行ためにLuaをコールバックすると、それはいかなるフックも呼び出さずに実行されます。


<p>
フック関数は継続を持つことができません。
そのため
<a href="#lua_yieldk"><code>lua_yieldk</code></a>、
<a href="#lua_pcallk"><code>lua_pcallk</code></a>、
<a href="#lua_callk"><code>lua_callk</code></a>
にnull以外の <code>k</code> を渡すことはできません。


<p>
フック関数は以下の状況でyieldすることができます。
countイベントとlineイベントのみyieldできます。
yieldするには、
<a href="#lua_yield"><code>lua_yield</code></a>
の <code>nresults</code> に0を渡して呼ぶ
(つまり値を渡さない)
ことによってフック関数の実行を終了しなければなりません。





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
デバッグフック関数を設定します。


<p>
引数 <code>f</code> はフック関数です。
<code>mask</code> は、そのフックが呼ばれるイベントを以下の定数のビットごとの論理和で指定します。
<ul>
<li><a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>
<li><a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>
<li><a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>
<li><a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>
</ul>
<code>count</code> 引数は、マスクに
<code>LUA_MASKCOUNT</code> が含まれている場合にだけ意味があります。
各イベントについて、フック関数は以下で説明するように呼ばれます。

<ul>

<li><b>callフック: </b>
関数を呼んだときに呼ばれます。
フックは新しい関数に入った直後、その関数が引数を取得する前に呼ばれます。
</li>

<li><b>returnフック: </b>
関数から戻るときに呼ばれます。
フックは関数から離れる直前に呼ばれます。
その関数の戻り値にアクセスする標準的な方法はありません。
</li>

<li><b>lineフック: </b>
コードの新しい行の実行が開始されるとき、または
(同じ行であっても)
コード内で逆方向のジャンプが発生したときに呼ばれます。
(このイベントはLuaの関数を実行している間だけ発生します。)
</li>

<li><b>countフック: </b>
<code>count</code> 個の命令を実行するごとに呼ばれます。
(このイベントはLuaの関数を実行している間だけ発生します。)
</li>

</ul>

<p>
<code>mask</code> をゼロに設定するとフックは無効化されます。





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
指定されたアクティベーションレコードのローカル変数の値を設定します。
スタックトップの値をその変数に代入し、その名前を返します。
また、スタックトップからその値を削除します。


<p>
インデックスがアクティブなローカル変数の数よりも大きい場合は
<code>NULL</code> を返します (そしてスタックの値は削除されません)。


<p>
引数 <code>ar</code> および <code>n</code> は関数
<a href="#lua_getlocal"><code>lua_getlocal</code></a>
と同様です。





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
クロージャの上位値の値を設定します。
スタックトップの値をその上位値に代入し、その名前を返します。
また、スタックからその値を削除します。


<p>
インデックス <code>n</code> が上位値の数より大きい場合は
<code>NULL</code> を返します (そしてスタックの値は削除されません)。


<p>
引数 <code>funcindex</code> および <code>n</code> は関数
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>
と同様です。





<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
インデックス <code>funcindex</code> のクロージャの
<code>n</code> 番目の上位値の一意な識別子を返します。


<p>
この一意な識別子を使うと、異なるクロージャが上位値を共有しているかどうかを確認することができます。
ひとつの上位値を共有している
(つまり同じ外部ローカル変数にアクセスする)
Luaのクロージャは、その上位値のインデックスに対して同一の識別子を返します。


<p>
引数 <code>funcindex</code> および <code>n</code> は関数
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a>
と同様ですが、
<code>n</code> を上位値の数より大きくすることはできません。





<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
インデックス <code>funcindex1</code> にあるLuaのクロージャの
<code>n1</code> 番目の上位値が、インデックス
<code>funcindex2</code> にあるLuaのクロージャの
<code>n2</code> 番目の上位値を参照するようにします。







<h1>5 &ndash; <a name="5">補助ライブラリ</a></h1>

<p>

<em>補助ライブラリ</em>にはCとLuaの間でやり取りするための便利な関数がいくつか用意されています。
基本APIはCとLuaの間でやり取りするために必要な基本的な関数をすべて提供していますが、補助ライブラリはいくつかの一般的な処理のためにより高水準な関数を提供しています。


<p>
補助ライブラリの関数と型はすべて、ヘッダファイル <code>lauxlib.h</code>
で定義されており、接頭辞 <code>luaL_</code> が付いています。


<p>
補助ライブラリの関数はすべて基本APIの上に構築されているため、基本APIを使ってできないことは何もありません。
しかし補助ライブラリを使えばコードの一貫性を高められます。


<p>
補助ライブラリの関数にはいくつか追加のスタックスロットを内部的に使用するものがあります。
補助ライブラリの関数が使うスロットが5個未満の場合、スタックサイズのチェックは行っていません。
単純に十分なスロットがあるものと仮定しています。


<p>
補助ライブラリの関数にはCの関数の引数をチェックするためのものがあります。
これらの関数は引数用のエラーメッセージを生成するため
("<code>bad argument #1</code>" など)、それ以外の値に対して使うべきではありません。


<p>
<code>luaL_check*</code> という名前の関数は、そのチェック内容を満たさなかった場合、常にエラーが発生します。



<h2>5.1 &ndash; <a name="5.1">関数と型</a></h2>

<p>
すべての補助ライブラリの関数と型をアルファベット順に掲載します。



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
バイト <code>c</code> をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。





<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
<code>s</code> の指す長さ <code>l</code>
の文字列をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。
文字列にはゼロを含めることができます。





<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
バッファエリア
(<a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a> を参照)
に事前にコピーしておいた長さ <code>n</code> の文字列をバッファ <code>B</code>
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)
に追加します。





<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
<code>s</code> の指すゼロ終端文字列をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。





<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +?, <em>e</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
スタックトップの値をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。
その値はスタックから削除されます。


<p>
これは文字列バッファ系唯一の、追加の要素をスタックから取るタイプの関数です。





<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
<code>cond</code> が真かどうかを確認します。
そうでなければ標準的なエラーメッセージを使ってエラーを発生させます
(<a href="#luaL_argerror"><code>luaL_argerror</code></a> を参照)。





<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
<code>extramsg</code>
をコメントとして含む以下のような標準的なエラーメッセージを使って、呼び出し元のCの関数の第
<code>arg</code> 引数の問題を報告するエラーを発生します。

<pre>
     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>
この関数は戻りません。





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
<em>文字列バッファ</em>の型です。


<p>
文字列バッファを使うとCのコードでLuaの文字列を少しずつ組み立てられます。
以下のような形で使います。

<ul>

<li>まず
<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>
型の変数 <code>b</code> を宣言します。</li>

<li>次に
<code>luaL_buffinit(L, &amp;b)</code>
を呼んでそれを初期化します。</li>

<li>
そして任意の
<code>luaL_add*</code> 関数を呼んで、文字列片をバッファに追加します。
</li>

<li>
最後に <code>luaL_pushresult(&amp;b)</code> を呼びます。
これによりスタックトップに最終的な文字列が残されます。
</li>

</ul>

<p>
結果となる文字列の合計サイズが事前に判っているのであれば、バッファを以下のように使うことができます。

<ul>

<li>まず
<a href="#luaL_Buffer"><code>luaL_Buffer</code></a>
型の変数 <code>b</code> を宣言します。</li>

<li>次に
<code>luaL_buffinitsize(L, &amp;b, sz)</code>
を呼んでそれを初期化し、サイズ <code>sz</code> の空間を事前確保します。</li>

<li>そしてその空間に文字列をコピーします。</li>

<li>
最後に <code>luaL_pushresultsize(&amp;b, sz)</code> を呼びます。
<code>sz</code> はその空間にコピーされる結果の文字列の合計サイズです。
</li>

</ul>

<p>
この操作の間、文字列バッファは不定個のスタックスロットを使います。
そのためバッファを使用している間、スタックトップがどこにあるかはわかりません。
釣り合いが取れている限り、バッファ操作の呼び出しの合間にスタックを使うことはできます。
つまりバッファ操作を呼び出すときは、前回バッファ操作をした直後の状態と同じレベルにスタックを戻す必要があります。
(このルールの唯一の例外は
<a href="#luaL_addvalue"><code>luaL_addvalue</code></a>
です。)
<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>
を呼んだ後、スタックはバッファを初期化したときのレベルに戻り、その上に最終的な文字列が積まれます。





<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
バッファ <code>B</code> を初期化します。
この関数は空間を一切割り当てません。
バッファは変数として宣言していなければなりません
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。





<hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a> を呼んだ後に
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
を呼ぶのと同等です。





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
メタメソッドを呼びます。


<p>
インデックス <code>obj</code>
のオブジェクトがメタテーブルを持っていて、このメタテーブルにフィールド
<code>e</code> がある場合、この関数はそのオブジェクトを引数としてそのフィールドを呼びます。
その場合、この関数は真に加えて、その呼び出しから返された戻り値をスタックに積みます。
メタテーブルがないか、メタメソッドがない場合、この関数は偽を返します
(スタックには何も積みません)。





<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 番目の引数が存在するかどうか
(<b>nil</b> を含む)
を確認します。





<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 番目の引数が整数
(または整数に変換可能な値)
かどうかを確認し、その整数を
<a href="#lua_Integer"><code>lua_Integer</code></a>
に変換して返します。





<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
<code>arg</code> 番目の引数が文字列かどうかを確認し、その文字列を返します。
<code>l</code> が <code>NULL</code> でなければ、
<code>*l</code> がその文字列の長さで埋められます。


<p>
この関数は結果を取得するために
<a href="#lua_tolstring"><code>lua_tolstring</code></a>
を使います。
そのため、その関数の変換と注意点はすべてここでも適用されます。





<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 番目の引数が数値かどうかを確認し、その数値を返します。





<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
<code>arg</code> 番目の引数が文字列かどうかを確認し、その文字列を配列 <code>lst</code>
(NULLで終わっていなければなりません)
の中から探します。
その文字列が見つかれば、その配列内のインデックスを返します。
引数が文字列でないか、その文字列が見つからなければ、エラーが発生します。


<p>
<code>def</code> が <code>NULL</code>
でなければ、 <code>arg</code> 番目の引数が存在しないときやその引数が
<b>nil</b> のときに、デフォルト値として <code>def</code> が使われます。


<p>
この関数は、文字列をCのenumに対応付けるときに便利です。
(Luaのライブラリの通常の慣習では、オプションの選択に数値ではなく文字列を使います。)





<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
スタックサイズを <code>top + sz</code> 個分に伸ばします。
スタックをそのサイズに伸ばせない場合はエラーが発生します。
<code>msg</code> は、そのエラーメッセージに追加されるテキストです
(追加のテキストが不要であれば <code>NULL</code> でも構いません)。





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
<code>arg</code> 番目の引数が文字列かどうかを確認し、その文字列を返します。


<p>
この関数は結果を取得するために
<a href="#lua_tolstring"><code>lua_tolstring</code></a>
を使います。
そのため、その関数の変換と注意点はすべてここでも適用されます。





<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
<code>arg</code> 番目の引数が <code>t</code> 型かどうかを確認します。
<code>t</code> の型の符号化については
<a href="#lua_type"><code>lua_type</code></a> を参照してください。





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
<code>arg</code> 番目の引数が
<code>tname</code> 型のユーザーデータ
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> を参照)
かどうかを確認し、そのユーザーデータのアドレスを返します
(<a href="#lua_touserdata"><code>lua_touserdata</code></a> を参照)。





<hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_checkversion (lua_State *L);</pre>

<p>
呼び出しを実行しているコア、Luaステートを作成したコア、呼び出しを行ったコードがすべて同じバージョンのLuaを使用しているかどうかを確認します。
また、呼び出しを実行しているコアとLuaステートを作成したコアが、同じアドレススペースを使用しているかどうかも確認します。





<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>e</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
指定されたファイルをロードして実行します。
これは以下のマクロとして定義されています。

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
エラーがなければ偽を返し、エラーの場合は真を返します。





<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
指定された文字列をロードして実行します。
これは以下のマクロとして定義されています。

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
エラーがなければ偽を返し、エラーの場合は真を返します。





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
エラーを発生させます。
エラーメッセージの書式は、
<code>fmt</code> と追加の引数で指定されます。
これらは
<a href="#lua_pushfstring"><code>lua_pushfstring</code></a>
と同じルールに従います。
また、エラーが発生したファイル名と行番号が利用可能であれば、それらがメッセージの先頭に追加されます。


<p>
この関数は決して戻りませんが、慣例としてCの関数で
<code>return luaL_error(<em>args</em>)</code>
のように使います。





<hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>e</em>]</span>
<pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
標準ライブラリのプロセス関係の関数
(<a href="#pdf-os.execute"><code>os.execute</code></a> および <a href="#pdf-io.close"><code>io.close</code></a>)
のための戻り値を生成します。





<hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>e</em>]</span>
<pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
標準ライブラリのファイル関係の関数
(<a href="#pdf-io.open"><code>io.open</code></a>、
<a href="#pdf-os.rename"><code>os.rename</code></a>、
<a href="#pdf-file:seek"><code>file:seek</code></a> など)
のための戻り値を生成します。





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
インデックス <code>obj</code> のオブジェクトのメタテーブルのフィールド
<code>e</code> をスタックに積み、その積んだ値の型を返します。
そのオブジェクトがメタテーブルを持っていないか、そのメタテーブルがそのフィールドを持っていなければ、何も積まずに
<code>LUA_TNIL</code> を返します。





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
レジストリの名前 <code>tname</code> に関連付けられたメタテーブル
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> を参照)
(その名前に関連付けられたメタテーブルがなければ <b>nil</b>)
をスタックに積みます。
積んだ値の型を返します。





<hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
値 <code>t[fname]</code> がテーブルであることを保証し、そのテーブルをスタックに積みます。
ただし <code>t</code> はインデックス <code>idx</code> の値です。
既存のテーブルが存在した場合は真を返し、新しいテーブルを作成した場合は偽を返します。





<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
文字列 <code>s</code> 内に出現する文字列 <code>p</code>
をすべて文字列 <code>r</code> に置き換えた文字列を作成します。
その結果の文字列をスタックに積み、それを返します。





<hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値の「長さ」を数値として返します。
これはLuaの '<code>#</code>' 演算子と同等です (<a href="#3.4.7">&sect;3.4.7</a> を参照)。
演算の結果が整数でない場合はエラーが発生します。
(これはメタメソッドが呼ばれた場合にのみ発生します。)





<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
<a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a>
の <code>mode</code> に <code>NULL</code>
を渡した場合と同等です。





<hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
バッファをLuaのチャンクとしてロードします。
この関数は <a href="#lua_load"><code>lua_load</code></a> を使って
<code>buff</code> が指すサイズ <code>sz</code> のチャンクをロードします。


<p>
この関数は
<a href="#lua_load"><code>lua_load</code></a>
と同じ結果を返します。
<code>name</code> はチャンクの名前で、デバッグ情報やエラーメッセージに使われます。
文字列 <code>mode</code> は関数
<a href="#lua_load"><code>lua_load</code></a>
と同様です。





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
<a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a>
の <code>mode</code> に <code>NULL</code> を渡した場合と同等です。





<hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
ファイルをLuaのチャンクとしてロードします。
この関数は <a href="#lua_load"><code>lua_load</code></a> を使って
<code>filename</code> という名前のファイルからチャンクをロードします。
<code>filename</code> が <code>NULL</code> の場合は標準入力からロードされます。
ファイルの最初の行が <code>#</code> で始まっている場合、
その行は無視されます。


<p>
文字列 <code>mode</code> は関数
<a href="#lua_load"><code>lua_load</code></a>
と同様です。


<p>
この関数は
<a href="#lua_load"><code>lua_load</code></a>
と同じ結果を返しますが、ファイルを開けなかったり読み込めなかった場合は追加のエラーコード
<a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>
を返します。


<p>
<a href="#lua_load"><code>lua_load</code></a>
と同様に、この関数はチャンクをロードするだけです。
実行はしません。





<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
文字列をLuaのチャンクとしてロードします。
この関数は <a href="#lua_load"><code>lua_load</code></a> を使ってゼロ終端文字列
<code>s</code> からチャンクをロードします。


<p>
この関数は
<a href="#lua_load"><code>lua_load</code></a>
と同じ結果を返します。


<p>
<a href="#lua_load"><code>lua_load</code></a>
と同様に、この関数はチャンクをロードするだけです。
実行はしません。





<hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
新しいテーブルを作成し、リスト <code>l</code> の関数をそこに登録します。


<p>
これは以下のようなマクロとして実装されています。

<pre>
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
配列 <code>l</code> はポインタではなく、実際の配列でなければなりません。





<hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
配列 <code>l</code> のすべてのエントリを格納するのに適したサイズの新しいテーブルを作成します。
(しかし実際にそれらを格納はしません。)
これは
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
と共に使われることを意図しています
(<a href="#luaL_newlib"><code>luaL_newlib</code></a> を参照)。


<p>
これはマクロとして実装されています。
配列 <code>l</code> はポインタではなく、実際の配列でなければなりません。





<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
レジストリにキー <code>tname</code> がすでにあれば0を返します。
そうでなければ、ユーザーデータ用のメタテーブルとして使われる新しいテーブルを作成し、ペア
<code>__name = tname</code>
をこの新しいテーブルに追加し、ペア
<code>[tname] = 新しいテーブル</code>
をレジストリに追加し、1を返します。
(エントリ <code>__name</code> はエラー報告関数のいくつかで使われます。)


<p>
どちらの場合でも、レジストリの
<code>tname</code> に関連付けられた最終的な値がスタックに積まれます。





<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
Luaのステートを作成します。
標準規格のCの <code>realloc</code> 関数をベースとしたアロケータを渡して
<a href="#lua_newstate"><code>lua_newstate</code></a>
を呼びます。
また、致命的なエラーが発生した場合にエラーメッセージを標準エラー出力に表示するパニック関数
(<a href="#4.6">&sect;4.6</a> を参照)
を設定します。


<p>
新しいステートを返します。
メモリ確保エラーが発生した場合は <code>NULL</code> を返します。





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
すべての標準Luaライブラリを指定されたステートにオープンします。





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
<code>arg</code> 番目の引数が整数
(または整数に変換可能)
であれば、その整数を返します。
その引数が存在しないか <b>nil</b> であれば
<code>d</code> を返します。
どちらでもなければエラーが発生します。





<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
<code>arg</code> 番目の引数が文字列であれば、その文字列を返します。
その引数が存在しないか <b>nil</b> であれば
<code>d</code> を返します。
どちらでもなければエラーが発生します。


<p>
<code>l</code> が <code>NULL</code> でなければ、
<code>*l</code> に結果の長さが格納されます。





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
<code>arg</code> 番目の引数が数値であれば、その数値を返します。
その引数が存在しないか <b>nil</b> であれば
<code>d</code> を返します。
どちらでもなければエラーが発生します。





<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
<code>arg</code> 番目の引数が文字列であれば、その文字列を返します。
その引数が存在しないか <b>nil</b> であれば
<code>d</code> を返します。
どちらでもなければエラーが発生します。





<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
に定義済みのサイズ
<a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>
を渡した場合と同等です。





<hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
バッファ <code>B</code> に追加したい文字列をコピーすることのできる、サイズ
<code>sz</code> の領域のアドレスを返します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。
文字列をこの領域にコピーした後、実際にバッファに追加する文字列のサイズを引数に
<a href="#luaL_addsize"><code>luaL_addsize</code></a>
を呼ばなければなりません。





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
バッファ <code>B</code> の使用を終了し、最終的な文字列をスタックトップに置きます。





<hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
<a href="#luaL_addsize"><code>luaL_addsize</code></a> を呼んだ後に
<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>
を呼ぶのと同等です。





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
スタックトップのオブジェクトに対する<em>リファレンス</em>を、インデックス
<code>t</code> のテーブルに作成して返します。
(オブジェクトはスタックから削除されます。)


<p>
リファレンスは一意な整数のキーです。
テーブル <code>t</code> に手動で整数キーを追加しない限り、返されるキーの一意性が保証されます。
<code>lua_rawgeti(L, t, r)</code>
を呼ぶと、リファレンス <code>r</code> の参照するオブジェクトを取得できます。
関数
<a href="#luaL_unref"><code>luaL_unref</code></a>
を呼ぶと、リファレンスとそれに関連付けられたオブジェクトを解放できます。


<p>
スタックトップのオブジェクトが <b>nil</b> の場合は、定数
<a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>
を返します。
定数
<a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a>
は、
<a href="#luaL_ref"><code>luaL_ref</code></a>
が返すいかなるリファレンスとも異なることが保証されています。





<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
で登録する関数配列の型です。
<code>name</code> は関数の名前で、
<code>func</code> は関数へのポインタです。
<a href="#luaL_Reg"><code>luaL_Reg</code></a>
の配列は最後に必ず番兵エントリを置かなければなりません。
番兵エントリは <code>name</code> と <code>func</code> が両方とも <code>NULL</code> のエントリです。





<hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
<code>modname</code>
が
<a href="#pdf-package.loaded"><code>package.loaded</code></a>
にまだ存在しなければ、
<a href="#pdf-require"><code>require</code></a>
を通して呼ばれたかのように文字列 <code>modname</code>
を引数として関数 <code>openf</code> を呼び、
<code>package.loaded[modname]</code>
にその呼び出しの結果を設定します。


<p>
<code>glb</code> が真であれば、グローバル変数
<code>modname</code> にもそのモジュールが格納されます。


<p>
そのモジュールをスタックに置きます。





<hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>e</em>]</span>
<pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
配列 <code>l</code>
(<a href="#luaL_Reg"><code>luaL_Reg</code></a> を参照)
のすべての関数を、スタックトップのテーブル
(ただし上位値がある場合はその下です。下記参照)
に登録します。


<p>
<code>nup</code> がゼロでなければ、すべての関数は
<code>nup</code> 個の上位値を共有した状態で作成されます。
これらの上位値は事前にライブラリテーブルの上に積んでおかなければならず、登録後にスタックから削除されます。





<hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
スタックトップのオブジェクトのメタテーブルを、レジストリの名前
<code>tname</code> に関連付けられたメタテーブルとして設定します。
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> を参照)。





<hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
標準入出力ライブラリで使われるファイルハンドルの標準的な表現です。


<p>
ファイルハンドルは
<code>LUA_FILEHANDLE</code>
という名前のメタテーブルを持つフルユーザーデータとして実装されています
(<code>LUA_FILEHANDLE</code> は実際のメタテーブルの名前に展開されるマクロです)。
このメタテーブルは入出力ライブラリによって作成されます
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> を参照)。


<p>
このユーザーデータは先頭に構造体
<code>luaL_Stream</code>
が存在しなければなりません。
この最初の構造体の後には任意のデータを持つことができます。
フィールド <code>f</code> は対応するCのストリームです
(不完全に作成されたハンドルを表すために <code>NULL</code> になる場合もあります)。
フィールド <code>closef</code>
は、ハンドルが閉じられたか回収されたときにストリームを閉じるために呼ばれる、Luaの関数を指します。
この関数は唯一の引数としてファイルハンドルを取り、
<b>true</b> (成功の場合) または
<b>nil</b> とエラーメッセージ (エラーの場合)
を返さなければなりません。
ひとたびこのフィールドが呼ばれると、ハンドルが閉じられたことを表すため、このフィールドの値は
<code>NULL</code> に変更されます。





<hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
この関数は
<a href="#luaL_checkudata"><code>luaL_checkudata</code></a>
と同様に動作します。
ただしチェックが失敗した場合は、エラーを発生させる代わりに
<code>NULL</code> を返します。





<hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
指定されたインデックスの任意のLuaの値を、適当な書式でCの文字列に変換します。
結果の文字列はスタックに積まれ、また戻り値としても返されます。
<code>len</code> が <code>NULL</code> でなければ、
<code>*len</code> にその文字列の長さが設定されます。


<p>
その値に
<code>"__tostring"</code>
フィールドを持つメタテーブルがある場合は、その値を引数として対応するメタメソッドが呼ばれ、その呼び出しの戻り値が結果として使われます。





<hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
<code>L1</code> のスタックトレースを作成して積みます。
<code>msg</code> が <code>NULL</code>
でなければ、スタックトレースの先頭にそれが追加されます。
<code>level</code> 引数はスタックトレースを開始するレベルを指定します。





<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
指定されたインデックスの値の型の名前を返します。





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
インデックス <code>t</code> のテーブルからリファレンス
<code>ref</code> を解放します
(<a href="#luaL_ref"><code>luaL_ref</code></a> を参照)。
対応するエントリがテーブルから削除され、参照されていたオブジェクトが回収可能になります。
リファレンス <code>ref</code> もまた、後の再利用のために解放されます。


<p>
<code>ref</code> が
<a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a>
または
<a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>
の場合は、何もしません。





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
コールスタックのレベル <code>lvl</code>
の現在の実行位置を表す文字列をスタックに積みます。
通常、この文字列は以下のような書式です。

<pre>
     <em>チャンクの名前</em>:<em>現在の行</em>:
</pre><p>
レベル0は実行中の関数、レベル1は実行中の関数の呼び出し元の関数以下同様です。


<p>
この関数はエラーメッセージのプレフィックスを作成するために使われます。







<h1>6 &ndash; <a name="6">標準ライブラリ</a></h1>

<p>
標準LuaライブラリはCのAPIを通して直接実装できる便利な関数を提供しています。
これらの関数の中には、基本的な言語機能を提供しているもの
(例えば <a href="#pdf-type"><code>type</code></a> や
<a href="#pdf-getmetatable"><code>getmetatable</code></a>)、
「外部」のサービスへのアクセスを提供しているもの
(例えば入出力)、Lua自身で実装可能だけれども非常に便利であるとか重大な性能上の要件のためにCで実装する価値のあるもの
(例えば <a href="#pdf-table.sort"><code>table.sort</code></a>)
などがあります。


<p>
すべてのライブラリは公式のCのAPIを使って実装されており、本体とは別のCのモジュールとして提供されています。
現在Luaには以下の標準ライブラリがあります。

<ul>

<li>基本ライブラリ (<a href="#6.1">&sect;6.1</a>);</li>

<li>コルーチンライブラリ (<a href="#6.2">&sect;6.2</a>);</li>

<li>パッケージライブラリ (<a href="#6.3">&sect;6.3</a>);</li>

<li>文字列操作 (<a href="#6.4">&sect;6.4</a>);</li>

<li>基本的なUTF-8のサポート (<a href="#6.5">&sect;6.5</a>);</li>

<li>テーブル操作 (<a href="#6.6">&sect;6.6</a>);</li>

<li>数学関数 (<a href="#6.7">&sect;6.7</a>) (sin, log, etc.);</li>

<li>入出力 (<a href="#6.8">&sect;6.8</a>);</li>

<li>OS機能 (<a href="#6.9">&sect;6.9</a>);</li>

<li>デバッグ機能 (<a href="#6.10">&sect;6.10</a>).</li>

</ul><p>
基本ライブラリとパッケージライブラリを除き、各ライブラリのすべての機能はグローバルテーブルのフィールドとして、またはオブジェクトのメソッドとして提供されます。


<p>
これらのライブラリにアクセスするには、
<a href="#luaL_openlibs"><code>luaL_openlibs</code></a>
関数をCのホストプログラムから呼んでください。
これによりすべての標準ライブラリがオープンされます。
別の方法として、
<a href="#luaL_requiref"><code>luaL_requiref</code></a>
を使って以下の関数を呼ぶことで、個別にオープンすることもできます。
<ul>
<li><b><a name="pdf-luaopen_base"><code>luaopen_base</code></a>: </b> 基本ライブラリ
<li><b><a name="pdf-luaopen_package"><code>luaopen_package</code></a>: </b> パッケージライブラリ
<li><b><a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a>: </b> コルーチンライブラリ
<li><b><a name="pdf-luaopen_string"><code>luaopen_string</code></a>: </b> 文字列ライブラリ
<li><b><a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a>: </b> UTF8ライブラリ
<li><b><a name="pdf-luaopen_table"><code>luaopen_table</code></a>: </b> テーブルライブラリ
<li><b><a name="pdf-luaopen_math"><code>luaopen_math</code></a>: </b> 数学ライブラリ
<li><b><a name="pdf-luaopen_io"><code>luaopen_io</code></a>: </b> 入出力ライブラリ
<li><b><a name="pdf-luaopen_os"><code>luaopen_os</code></a>: </b> OSライブラリ
<li><b><a name="pdf-luaopen_debug"><code>luaopen_debug</code></a>: </b> デバッグライブラリ
</ul>
<p>
これらの関数は
<a name="pdf-lualib.h"><code>lualib.h</code></a>
で宣言されています。



<h2>6.1 &ndash; <a name="6.1">基本機能</a></h2>

<p>
基本ライブラリはLuaの中核的な機能を提供します。
アプリケーションにこのライブラリを含めない場合は、これらの機能の代替品を用意する必要がないか、慎重に検討してください。


<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
引数 <code>v</code> の値が偽
(つまり <b>nil</b> または <b>false</b>)
であれば
<a href="#pdf-error"><code>error</code></a>
を呼びます。
そうでなければその引数をすべて返します。
エラーの場合、
<code>message</code>
はエラーオブジェクトです。
指定しなかった場合はデフォルトの
"<code>assertion failed!</code>"
が使われます。




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
この関数はガベージコレクタへの汎用インタフェースです。
第1引数 <code>opt</code> によって様々な機能を実行します。

<ul>

<li><b>"<code>collect</code>": </b>
完全なガベージコレクションサイクルを実行します。
これはデフォルトのオプションです。
</li>

<li><b>"<code>stop</code>": </b>
ガベージコレクタの自動実行を停止します。
自動実行を再開するまでの間、ガベージコレクタは明示的に呼び出された場合にのみ動作します。
</li>

<li><b>"<code>restart</code>": </b>
ガベージコレクタの自動実行を再開します。
</li>

<li><b>"<code>count</code>": </b>
Luaが使用している合計メモリをキロバイト単位で返します。
この値には小数部があるので、1024を掛けるとLuaが使用している正確なバイト数になります
(オーバーフローした場合を除く)。
</li>

<li><b>"<code>step</code>": </b>
ガベージコレクションのステップを実行します。
<code>arg</code> によってそのステップの「サイズ」を制御できます。
ゼロの場合、コレクタは基本的な (分割不可能な) ステップをひとつ実行します。
ゼロ以外の場合、コレクタはその量のメモリ (キロバイト単位) の確保を行ったかのように動作します。
そのステップでコレクションサイクルが完了した場合は <b>true</b> を返します。
</li>

<li><b>"<code>setpause</code>": </b>
<code>arg</code> をコレクタの<em>停止値</em>
(<a href="#2.5">&sect;2.5</a> を参照)
の新しい値として設定します。
<em>停止値</em>の以前の値を返します。
</li>

<li><b>"<code>setstepmul</code>": </b>
<code>arg</code> をコレクタの<em>ステップ係数</em>
(<a href="#2.5">&sect;2.5</a> を参照)
の新しい値として設定します。
<em>ステップ係数</em>の以前の値を返します。
</li>

<li><b>"<code>isrunning</code>": </b>
コレクタが実行中 (つまり停止していない) かどうかを表すブーリアン値を返します。
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
指定された名前のファイルを開き、その内容をLuaのチャンクとして実行します。
引数なしで呼んだ場合は標準入力 (<code>stdin</code>) の内容を実行します。
チャンクから返されたすべての値を返します。
エラーの場合は呼び出し元にエラーを伝播させます
(つまり保護モードで実行しません)。




<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
最後の保護された関数呼び出しを終了し、
<code>message</code> をエラーオブジェクトとして返します。
関数 <code>error</code> は決して戻りません。


<p>
メッセージが文字列の場合は、通常、そのメッセージの先頭に、エラー位置に関する情報が追加されます。
<code>level</code> 引数は、そのエラー位置の取得方法を指定します。
レベル1 (デフォルト) の場合、エラー位置は <code>error</code> 関数の呼び出し元で、
レベル2は <code>error</code> の呼び出し元の呼び出し元を指し、以下同様です。
レベル0を指定すると、エラー位置に関する情報をメッセージに追加しません。




<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
グローバル環境 (<a href="#2.2">&sect;2.2</a> を参照)
を保持するグローバル変数です (関数ではありません)。
Lua自身はこの変数を使用しません。
この値を変更しても環境には影響しませんし、逆も同様です。




<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
<code>object</code>
にメタテーブルがなければ
<b>nil</b> を返します。
そうでなく、そのオブジェクトのメタテーブルに
<code>"__metatable"</code>
フィールドがあれば、それに関連付けられた値を返します。
いずれでもなければ、指定されたオブジェクトのメタテーブルを返します。




<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
以下の構文

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
でキーと値のペア
(<code>1,t[1]</code>)、(<code>2,t[2]</code>)、&middot;&middot;&middot;
を最初のnil値まで巡回できるような3つの値
(イテレータ関数、テーブル <code>t</code>、0)
を返します。




<p>
<hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
チャンクをロードします。


<p>
<code>chunk</code> が文字列であれば、チャンクはその文字列です。
<code>chunk</code> が関数であれば、チャンク片を取得するためにその関数が繰り返し呼ばれます。
<code>chunk</code> は呼ばれるたびに文字列を返さなければなりません。
この文字列は前回の戻り値と連結されます。
空文字列または <b>nil</b> を返すか、何も返さなければ、チャンクの終わりになります。


<p>
構文エラーがなければ、コンパイルされたチャンクが関数として返されます。
そうでなければ、
<b>nil</b> とエラーメッセージが返されます。


<p>
結果の関数に上位値がある場合、最初の上位値は <code>env</code>
が指定されていればその値に、そうでなければグローバル環境に設定されます。
残りの上位値は <b>nil</b> に初期化されます。
(メインチャンクをロードした場合、結果の関数は必ず、ちょうど1個の上位値として
<code>_ENV</code> 変数を持ちます
(<a href="#2.2">&sect;2.2</a> を参照)。
しかし、関数から作成したバイナリチャンク
(<a href="#pdf-string.dump"><code>string.dump</code></a> を参照)
をロードした場合、結果の関数は任意の個数の上位値を持っている場合があります。)
すべての上位値は新しく確保されます。
つまり他のいかなる関数とも共有されていません。


<p>
<code>chunkname</code>
はエラーメッセージやデバッグ情報で使われるチャンクの名前です
(<a href="#4.9">&sect;4.9</a> を参照)。
指定しなかった場合、
<code>chunk</code> が文字列であればデフォルトで <code>chunk</code>
になり、そうでなければ "<code>=(load)</code>" になります。


<p>
文字列 <code>mode</code> は、テキストまたはバイナリ
(コンパイル済みチャンク)
いずれのチャンクを許可するかを制御します。
以下の文字列のいずれかを指定できます。
<ul>
<li><b>"<code>b</code>": </b> バイナリチャンクのみ
<li><b>"<code>t</code>": </b> テキストチャンクのみ
<li><b>"<code>bt</code>": </b> バイナリとテキスト両方
</ul>
デフォルトは "<code>bt</code>" です。


<p>
バイナリチャンクの一貫性はチェックされません。
悪意を持って作られたバイナリチャンクはインタプリタをクラッシュさせる可能性があります。




<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
<a href="#pdf-load"><code>load</code></a>
に似ていますが、チャンクをファイル <code>filename</code> から取得します。
ファイル名を指定しなかった場合は標準入力から取得します。




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
テーブルのすべてのフィールドを巡回します。
第1引数はテーブルで、第2引数はそのテーブルのインデックスです。
<code>next</code> は、そのテーブルの次のインデックスと、それに関連付けられた値を返します。
第2引数に <b>nil</b> を指定して呼ぶと、最初のインデックスと、それに関連付けられた値を返します。
最後のインデックスを指定して呼ぶか、空のテーブルに <b>nil</b> を指定して呼ぶと、
<b>nil</b> を返します。
第2引数を指定しなかった場合は、
<b>nil</b> を指定したものと解釈されます。
例えば、
<code>next(t)</code> でテーブルが空かどうかを調べることができます。


<p>
インデックスが列挙される順番は決まっていません。
これは<em>数値のインデックスに対しても</em>同様です。
(テーブルを数値順に巡回したい場合は数値用の <b>for</b> を使ってください。)


<p>
巡回の途中でテーブル中の元々存在しなかったフィールドに値を代入した場合、
<code>next</code> の動作は未定義です。
しかし既存のフィールドは変更しても構いません。
また既存のフィールドを削除しても構いません。




<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
<code>t</code> にメタメソッド <code>__pairs</code> があれば、
<code>t</code> を引数としてそれを呼び、その呼び出しの最初の3つの戻り値を返します。


<p>
そうでなければ、
<a href="#pdf-next"><code>next</code></a> 関数、テーブル
<code>t</code>、
<b>nil</b> の3つの値を返します。
そのため、以下の構文

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
でテーブル <code>t</code> のすべてのキーと値のペアを巡回できます。


<p>
巡回中にテーブルを変更する際の注意点については、関数
<a href="#pdf-next"><code>next</code></a> を参照してください。




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
指定された引数を渡して関数 <code>f</code> を<em>保護モード</em>で呼びます。
つまり <code>f</code> の内部で発生したいかなるエラーも伝播されないという意味です。
代わりに <code>pcall</code> がエラーをキャッチし、ステータスコードを返します。
最初の戻り値はステータスコード (ブーリアン)
で、呼び出しがエラーなく成功した場合は真になります。
この場合、その最初の戻り値の後に、その呼び出しからの戻り値もすべて返されます。
エラーが発生した場合は <b>false</b> とエラーメッセージを返します。




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
任意の個数の引数を受け取り、
<a href="#pdf-tostring"><code>tostring</code></a>
を使って各引数を文字列に変換し、それらの値を <code>stdout</code> に表示します。
この関数は書式化出力を意図していません。
例えばデバッグ用に、値を表示するための簡単な方法として用意されているだけです。
出力を完全に制御したい場合は
<a href="#pdf-string.format"><code>string.format</code></a>
および
<a href="#pdf-io.write"><code>io.write</code></a>
を使ってください。




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
メタメソッドを呼ばずに、
<code>v1</code> と <code>v2</code> が等しいかどうかを確認します。
ブーリアンを返します。




<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
メタメソッドを呼ばずに、
<code>table[index]</code> の実際の値を取得します。
<code>table</code> はテーブルでなければなりません。
<code>index</code> は任意の値を指定できます。




<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
メタメソッドを呼ばずに、オブジェクト <code>v</code> の長さを返します。
<code>v</code> はテーブルか文字列でなければなりません。
整数を返します。




<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
メタメソッドを呼ばずに、
<code>table[index]</code> の実際の値を
<code>value</code> に設定します。
<code>table</code> はテーブルでなければなりません。
<code>index</code> は <b>nil</b> とNaN以外の任意の値を指定できます。
<code>value</code> は任意のLuaの値を指定できます。


<p>
この関数は <code>table</code> を返します。




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
<code>index</code> が数値の場合、
<code>index</code> 番目以降の引数をすべて返します。
負の数値の場合は最後から数えます (-1が最後の引数です)。
そうでなければ、 <code>index</code> は文字列 <code>"#"</code>
でなければならず、渡された追加の引数の合計個数を返します。




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
指定されたテーブルのメタテーブルを設定します。
(それ以外の型のメタテーブルをLuaから変更することはできません。
Cからのみできます。)
<code>metatable</code> が <b>nil</b>
の場合、指定されたテーブルのメタテーブルは削除されます。
元のメタテーブルに <code>"__metatable"</code>
フィールドがある場合はエラーが発生します。


<p>
この関数は <code>table</code> を返します。




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
<code>base</code> を指定せずに呼ぶと、引数を数値に変換しようと試みます。
その引数がすでに数値であるか、数値に変換可能な文字列であれば、その数値を返します。
そうでなければ <b>nil</b> を返します。


<p>
文字列の変換結果はLuaの字句規約
(<a href="#3.1">&sect;3.1</a> を参照)
に従って整数か浮動小数点数になります。
(文字列の前後に空白があってもよく、符号が付いていても構いません。)


<p>
<code>base</code> を指定して呼んだ場合、
<code>e</code> はその基数で整数値として解釈可能な文字列でなければなりません。
基数には2から36までの任意の整数を指定できます。
10より大きな基数の場合は、
'<code>A</code>'
(大文字でも小文字でも構いません)
が10を表し、
'<code>B</code>' が11を表し、以下同様で、
'<code>Z</code>' が35を表します。
文字列 <code>e</code> が、指定された基数で有効な数値でない場合は、
<b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
任意の型の値を受け取り、それを人間が読める形式の文字列に変換します。
(数値の変換方法を完全に制御したい場合は
<a href="#pdf-string.format"><code>string.format</code></a>
を使ってください。)


<p>
<code>v</code> のメタテーブルに <code>"__tostring"</code>
フィールドがあれば、 <code>v</code>
を引数としてその対応する値を呼び、その呼び出しの戻り値が結果として使われます。




<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
引数の型を文字列として返します。
戻り値は以下のいずれかになります。
<ul>
<li>"<code>nil</code>" (という文字列、 <b>nil</b> 値ではなく)
<li>"<code>number</code>"
<li>"<code>string</code>"
<li>"<code>boolean</code>"
<li>"<code>table</code>"
<li>"<code>function</code>"
<li>"<code>thread</code>"
<li>"<code>userdata</code>"
</ul>




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
現在のインタプリタのバージョン文字列を保持しているグローバル変数です
(関数ではありません)。
この変数の現在の値は "<code>Lua 5.3</code>" です。




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
<a href="#pdf-pcall"><code>pcall</code></a>
に似ていますが、新しいメッセージハンドラに <code>msgh</code> を設定します。







<h2>6.2 &ndash; <a name="6.2">コルーチン操作</a></h2>

<p>
このライブラリはコルーチンを操作する関数から構成されます。
このライブラリの関数はすべてテーブル
<a name="pdf-coroutine"><code>coroutine</code></a> の中に提供されます。
コルーチンの一般的な説明は <a href="#2.6">&sect;2.6</a> を参照してください。


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
<code>f</code> を本体に持つ新しいコルーチンを作成します。
<code>f</code> は関数でなければなりません。
その新しいコルーチンである<em>スレッド</em>型のオブジェクトを返します。




<p>
<hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ()</code></a></h3>


<p>
実行中のコルーチンがyield可能であれば真を返します。


<p>
実行中のコルーチンがメインスレッドでなく、yield可能でないCの関数の内部でなければ、そのコルーチンはyield可能です。




<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>


<p>
コルーチン <code>co</code> の実行を開始または続行します。
最初にコルーチンをresumeしたとき、その本体の実行が開始されます。
値 <code>val1</code>、&middot;&middot;&middot;
は、その本体関数に引数として渡されます。
そのコルーチンがyieldされていた場合は、それを再開します。
値 <code>val1</code>、&middot;&middot;&middot;
は、yieldからの戻り値として渡されます。


<p>
コルーチンをエラーなく実行できた場合は、
<b>true</b> に加え、
<code>yield</code> に渡されたあらゆる値
(コルーチンをyieldした場合)
または本体関数から返されたあらゆる値
(コルーチンを終了した場合)
を返します。
エラーが発生した場合は
<b>false</b> とエラーメッセージを返します。




<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
実行中のコルーチンとブーリアンを返します。
このブーリアンは、そのコルーチンがメインスレッドであれば真です。




<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
コルーチン <code>co</code> の状態を文字列として返します。
<ul>
<li><b><code>"running"</code>: </b>
コルーチンは実行中
(つまり呼び出し元のコルーチン)
である。
<li><b><code>"suspended"</code>: </b>
コルーチンは <code>yield</code> の呼び出しで中断されているか、
まだ実行開始していない。
<li><b><code>"normal"</code>: </b>
コルーチンはアクティブであるが、実行中ではない
(つまり他のコルーチンを resume した)。
<li><b><code>"dead"</code>: </b>
コルーチンは本体関数を終了したか、エラーで停止した。
</ul>




<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
<code>f</code> を本体に持つ新しいコルーチンを作成します。
<code>f</code> は関数でなければなりません。
呼ばれるたびにそのコルーチンをresumeする関数を返します。
この関数に渡したあらゆる引数は、
<code>resume</code> に追加の引数として渡したのと同様の動作をします。
最初のブーリアンを除き、
<code>resume</code> から返されるものと同じ値を返します。
エラーが発生した場合は、そのエラーを伝播します。




<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>
呼び出し元のコルーチンの実行を中断します。
<code>yield</code> に渡したあらゆる引数は、
<code>resume</code> に追加の戻り値として渡されます。







<h2>6.3 &ndash; <a name="6.3">モジュール</a></h2>

<p>
パッケージライブラリはLuaのモジュールをロードするための基本的な機能を提供します。
関数
<a href="#pdf-require"><code>require</code></a>
はグローバル環境に直接エクスポートされます。
それ以外のものはすべてテーブル
<a name="pdf-package"><code>package</code></a>
の中にエクスポートされます。


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
指定されたモジュールをロードします。
まず、
<code>modname</code> がすでにロード済みかどうかを確認するために、テーブル
<a href="#pdf-package.loaded"><code>package.loaded</code></a>
が調べられます。
もしロード済みであれば、
<code>package.loaded[modname]</code>
に格納されている値が返されます。
そうでなければ、そのモジュールのために<em>ローダー</em>の検索が試みられます。


<p>
ローダーを検索するにあたって、シーケンス
<a href="#pdf-package.searchers"><code>package.searchers</code></a>
がガイドとして用いられます。
このシーケンスを変更すると、モジュールの検索方法を変えることができます。
以下の説明は
<a href="#pdf-package.searchers"><code>package.searchers</code></a>
のデフォルトの設定に基づくものです。


<p>
まず
<code>package.preload[modname]</code>
が検索されます。
この値が存在すれば、その値 (関数でなければなりません) がローダーになります。
そうでなければ、
<a href="#pdf-package.path"><code>package.path</code></a>
に格納されているパスを使うLuaのローダーが検索されます。
それでも見つからなければ、
<a href="#pdf-package.cpath"><code>package.cpath</code></a>
に格納されているパスを使うCのローダーが検索されます。
それでも見つからなければ、<em>オールインワン</em>ローダー
(<a href="#pdf-package.searchers"><code>package.searchers</code></a>
を参照) が試みられます。


<p>
ローダーが見つかると、そのローダーに2個の引数、
<code>modname</code>
と、そのローダーをどのように取得したかに依存する追加の値が渡されます。
(ローダーがファイル由来の場合、追加の引数はそのファイル名になります。)
そのローダーがnilでない値を返すと、その返された値が
<code>package.loaded[modname]</code>
に代入されます。
ローダーがnilでない値を返さず、
<code>package.loaded[modname]</code>
に何の値も代入しなかった場合は、そのエントリに <b>true</b> が代入されます。
いずれの場合も、
<code>package.loaded[modname]</code>
の最終的な値が <code>require</code> から返されます。


<p>
モジュールのロード中または実行中に何らかのエラーが発生したか、そのモジュールのローダーを見つけることができなかった場合、
<code>require</code> はエラーを発生させます。




<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
パッケージのコンパイル時設定を記述した文字列です。
この文字列は以下の行の並びです。

<ul>

<li>1行目はディレクトリ区切り文字列です。
デフォルトはWindowsでは
'<code>\</code>' で、それ以外のすべてのシステムでは
'<code>/</code>' です。</li>

<li>2行目はパス中のテンプレートを区切る文字です。
デフォルトは '<code>;</code>' です。</li>

<li>3行目はテンプレート中の置換点を示す文字列です。
デフォルトは '<code>?</code>' です。</li>

<li>4行目はWindowsのパス中の、実行可能ファイルのディレクトリに置換される文字列です。
デフォルトは '<code>!</code>' です。</li>

<li>5行目は
<code>luaopen_</code> 関数の名前を作成するときに、その後のテキストをすべて無視する印です。
デフォルトは '<code>-</code>' です。</li>

</ul>



<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
Cのローダーを検索するために
<a href="#pdf-require"><code>require</code></a>
で使われるパスです。


<p>
Cのパス
<a href="#pdf-package.cpath"><code>package.cpath</code></a>
は、環境変数
<a name="pdf-LUA_CPATH_5_3"><code>LUA_CPATH_5_3</code></a>
または環境変数
<a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>
または
<code>luaconf.h</code>
で定義されているデフォルトのパスを使って、Luaのパス
<a href="#pdf-package.path"><code>package.path</code></a>
が初期化されるのと同じ方法で初期化されます。




<p>
<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
モジュールがすでにロード済みかどうかを制御するために
<a href="#pdf-require"><code>require</code></a>
で使われるテーブルです。
モジュール <code>modname</code> をrequireしたとき、
<code>package.loaded[modname]</code> が偽でなければ、
<a href="#pdf-require"><code>require</code></a>
は単にそこに格納されている値を返します。


<p>
この変数は実際のテーブルへの参照にすぎません。
この変数に代入しても
<a href="#pdf-require"><code>require</code></a>
で使われるテーブルは変わりません。




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
Cのライブラリ <code>libname</code> をダイナミックリンクします。


<p>
<code>funcname</code> が "<code>*</code>"
であれば、そのライブラリをリンクし、そのライブラリがエクスポートしているシンボルを他のダイナミックリンクライブラリから利用できるようにだけします。
そうでなければ、そのライブラリ内の関数 <code>funcname</code>
を検索し、その関数をCの関数として返します。
そのため、 <code>funcname</code> は
<a href="#lua_CFunction"><code>lua_CFunction</code></a>
のプロトタイプに従わなければなりません。
(<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照)。


<p>
これは低水準の関数です。
パッケージシステムやモジュールシステムを完全に迂回します。
<a href="#pdf-require"><code>require</code></a>
と異なり、パスを検索することもなく、拡張子を自動的に追加することもありません。
<code>libname</code>
Cのライブラリの完全なファイル名でなければならず、必要であればパスや拡張子も含めなければなりません。
<code>funcname</code>
はそのCのライブラリがエクスポートしている正確な名前でなければなりません
(使用したCコンパイラやリンカに依存します)。


<p>
この機能は標準規格のCではサポートされていません。
そのため一部のプラットフォーム
(Windows、Linux、Mac OS X、Solaris、BSD、および
<code>dlfcn</code> 標準をサポートしている各種Unixシステム)
でのみ利用可能です。




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
Luaのローダーを検索するために
<a href="#pdf-require"><code>require</code></a>
で使われるパスです。


<p>
この変数はスタートアップ時に環境変数
<a name="pdf-LUA_PATH_5_3"><code>LUA_PATH_5_3</code></a>
または環境変数
<a name="pdf-LUA_PATH"><code>LUA_PATH</code></a>
の値、またはそれらの環境変数が定義されていない場合は
<code>luaconf.h</code>
に定義されているデフォルトのパスに初期化されます。
環境変数の値の中の "<code>;;</code>" は
(もしあれば) デフォルトのパスに置換されます。




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
特定のモジュール用のローダーを格納するテーブルです
(<a href="#pdf-require"><code>require</code></a> を参照)。


<p>
この変数は実際のテーブルへの参照にすぎません。
この変数に代入しても
<a href="#pdf-require"><code>require</code></a>
で使われるテーブルは変わりません。




<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
モジュールのロード方法を制御するために
<a href="#pdf-require"><code>require</code></a>
で使われるテーブルです。


<p>
このテーブルの各エントリは<em>検索関数</em>です。
モジュールを検索するとき、モジュール名
(<a href="#pdf-require"><code>require</code></a> に渡した引数)
を唯一の引数としてこれらの各検索関数が昇順で呼ばれます。
この関数は、別の関数 (モジュール<em>ローダー</em>)
と、そのローダーに渡す追加の値を返すことができます。
あるいは、モジュールが見つからなかった理由を表す文字列
(あるいは何も言うべきことがなければ <b>nil</b>)
を返すこともできます。


<p>
このテーブルは4個の検索関数で初期化されます。


<p>
1番目の検索関数は単純に
<a href="#pdf-package.preload"><code>package.preload</code></a>
テーブルからローダーを検索します。


<p>
2番目の検索関数は
<a href="#pdf-package.path"><code>package.path</code></a>
に格納されているパスを使ってLuaのライブラリとしてローダーを検索します。
検索は関数
<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>
で説明されているように行われます。


<p>
3番目の検索関数は変数
<a href="#pdf-package.cpath"><code>package.cpath</code></a>
で指定されたパスを使ってCのライブラリとしてローダーを検索します。
これも同様に、検索は関数
<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>
で説明されているように行われます。
例えばCのパスが以下の文字列である場合、

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
モジュール <code>foo</code> の検索は、ファイル
<code>./foo.so</code>、
<code>./foo.dll</code>、
<code>/usr/local/foo/init.so</code>
を、この順番で、開けるかどうか試します。
Cのライブラリが見つかったなら、ダイナミックリンクの機能を使ってそのライブラリをリンクします。
次に、ローダーとして使えるCの関数をそのライブラリ内から検索します。
Cの関数の名前は、文字列 "<code>luaopen_</code>"
と、モジュール名のドットをアンダースコアで置換した文字列を連結したものです。
さらにモジュール名にハイフンが含まれている場合、最初のハイフンとその後の接尾辞は削除されます。
例えばモジュール名が <code>a.b.c-v2.1</code> の場合、関数名は
<code>luaopen_a_b_c</code> になります。


<p>
4番目の検索関数は<em>オールインワンローダー</em>を試みます。
指定されたモジュールのルート名に対してCのパスからライブラリを検索します。
例えば <code>a.b.c</code> をrequireすると、
<code>a</code> というCのライブラリが検索されます。
見つかれば、そのサブモジュールに対するオープン関数がライブラリ内から検索されます。
先程の例では <code>luaopen_a_b_c</code> になります。
この機能により、複数のCのサブモジュールを、各サブモジュールの元々のオープン関数を保ったまま、ひとつのライブラリにパッケージ化できます。


<p>
1番目 (preload) 以外のすべての検索関数は、
<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>
から返されるのと同様に、モジュールが見つかったファイル名を追加の値として返します。
1番目の検索関数は追加の値を返しません。




<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
指定された <code>path</code> から指定された <code>name</code> を検索します。


<p>
パスは一連の<em>テンプレート</em>をセミコロンで区切った文字列です。
各テンプレートに対して、テンプレート中の疑問符 (もしあれば)
が <code>name</code> に置換され、
<code>sep</code> (デフォルトはドット)
がすべて
<code>rep</code> (デフォルトではシステムのディレクトリ区切り文字)
に置換され、結果のファイル名が開けるかどうか試みられます。


<p>
例えばパスが以下の文字列の場合、

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
名前 <code>foo.a</code> を検索すると、ファイル
<code>./foo/a.lua</code>、
<code>./foo/a.lc</code>、
<code>/usr/local/foo/a/init.lua</code>
が、この順番で、開けるかどうか試みられます。


<p>
読み込みモードで開くことができた最初のファイル名を返します。
開けるファイルが無かった場合は、
<b>nil</b> とエラーメッセージを返します。
(このエラーメッセージには開けるかどうか試みられたすべてのファイル名が記載されます。)







<h2>6.4 &ndash; <a name="6.4">文字列操作</a></h2>

<p>
このライブラリは部分文字列の検索、部分文字列の抽出、パターンマッチングなど、文字列操作のための汎用的な機能を提供しています。
Luaでは文字列中のインデックスを指定するとき、最初の文字が1の位置です
(Cのように0ではありません)。
インデックスには負の値を指定することもでき、文字列の終わりから逆方向のインデックスとして解釈されます。
つまり最後の文字は-1の位置で、以下同様です。


<p>
文字列ライブラリの関数はすべてテーブル
<a name="pdf-string"><code>string</code></a>
の中に提供されます。
また文字列に対するメタテーブルも設定されます。
このメタテーブルは <code>__index</code> フィールドを持ち、
<code>string</code> テーブルを指します。
そのため文字列関数をオブジェクト指向スタイルで使うこともできます。
例えば
<code>string.byte(s,i)</code>
は
<code>s:byte(i)</code>
と書くこともできます。


<p>
文字列ライブラリでは1バイト文字のエンコーディングが想定されています。


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
文字
<code>s[i]</code>、<code>s[i+1]</code>、...、<code>s[j]</code>
の内部的な文字コードの数値を返します。
<code>i</code> のデフォルト値は1で、
<code>j</code> のデフォルト値は <code>i</code> です。
これらのインデックスは関数
<a href="#pdf-string.sub"><code>string.sub</code></a>
と同じルールに従って修正されます。


<p>
文字コードの数値は異なるプラットフォームへの移植性が保証されていません。




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
ゼロ個以上の整数を受け取り、引数の個数と同じ長さの文字列を返します。
この文字列中の各文字は、対応する引数に等しい内部的な文字コードの数値を持ちます。


<p>
文字コードの数値は異なるプラットフォームへの移植性が保証されていません。




<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>


<p>
指定された関数のバイナリ表現
(<em>バイナリチャンク</em>)
を含む文字列を返します。
後にこの文字列を
<a href="#pdf-load"><code>load</code></a>
に渡すと、その関数のコピーを作成できます
(ただし上位値は新しいものになります)。
<code>strip</code> が真の値の場合は、空間を節約するため、その関数に関するすべてのデバッグ情報が含まれない場合があります。


<p>
上位値を持つ関数は、上位値の個数だけが保存されます。
(再) ロードされたとき、それらの上位値には新しいインスタンスが作成され、
<b>nil</b> に初期化されます。
(デバッグライブラリを使用し、関数の上位値を必要に応じて自分で保存、再ロードすることはできます。)




<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>
文字列 <code>s</code> から <code>pattern</code>
(<a href="#6.4.1">&sect;6.4.1</a> を参照)
の最初のマッチを検索します。
マッチが見つかれば、その開始位置と終了位置を示す <code>s</code> のインデックスを返します。
見つからなければ <b>nil</b> を返します。
省略可能な第3引数 <code>init</code> は検索の開始位置を指定する数値です。
デフォルト値は1で、負の値も指定できます。
省略可能な第4引数 <code>plain</code> は、
<b>true</b> の値を指定するとパターンマッチの機能が無効化され、
<code>pattern</code> のどの文字も魔法扱いしない、ただの「部分文字列検索」処理になります。
<code>plain</code> を指定するときは
<code>init</code> も指定しなければならないことに注意してください。


<p>
パターンにキャプチャがある場合は、マッチが成功すると、2つのインデックスの後にキャプチャした値も返されます。




<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>


<p>
最初の引数 (文字列でなければなりません)
で指定された記述に従い、可変長引数を書式化して返します。
書式文字列はISO Cの関数 <code>sprintf</code> と同じルールに従います。
ただしオプションおよび修飾子
<code>*</code>、
<code>h</code>、
<code>L</code>、
<code>l</code>、
<code>n</code>、
<code>p</code>
はサポートされず、
追加のオプション <code>q</code> があるという点が異なります。
<code>q</code> オプションは二重引用符で囲った文字列を書式化します。
このとき、Luaインタプリタで安全に読み戻せることを保証するために、必要に応じてエスケープシーケンスが使われます。
例えば以下の呼び出しは

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
以下の文字列を生成します。

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
オプション
<code>A</code>、
<code>a</code>、
<code>E</code>、
<code>e</code>、
<code>f</code>、
<code>G</code>、
<code>g</code>
はすべて引数として数値を期待します。
オプション
<code>c</code>、
<code>d</code>、
<code>i</code>、
<code>o</code>、
<code>u</code>、
<code>X</code>、
<code>x</code>
は整数を期待します。
オプション <code>q</code> は文字列を期待します。
オプション <code>s</code> はゼロを含まない文字列を期待します。
引数が文字列でなければ
<a href="#pdf-tostring"><code>tostring</code></a>
と同じルールに従って文字列に変換されます。


<p>
LuaをC99でないコンパイラでコンパイルした場合、オプション
<code>A</code> および <code>a</code> (16進浮動小数点数)
ではいかなる修飾子 (フラグ、幅、長さ) もサポートされません。




<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
呼ばれるたびに文字列 <code>s</code> に対して <code>pattern</code>
(<a href="#6.4.1">&sect;6.4.1</a> を参照)
から次のキャプチャを返すようなイテレータ関数を返します。
<code>pattern</code> にキャプチャが指定されていなければ、呼ばれるたびにマッチ全体が返されます。


<p>
例えば以下のループは文字列 <code>s</code>
中のすべての単語を巡回し、それを各行に表示します。

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
次の例は指定された文字列中の
<code>key=value</code> ペアをすべて集め、
テーブルに格納します。

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
この関数の場合、パターン先頭のキャレット
'<code>^</code>' は巡回を妨げることになるので、アンカーとして機能しません。




<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
<code>s</code> 中のすべて
(または指定されていれば最初の <code>n</code> 個)
の <code>pattern</code>
(<a href="#6.4.1">&sect;6.4.1</a> を参照)
を <code>repl</code> で指定された置換文字列で置き換えた文字列を返します。
<code>repl</code> には文字列、テーブル、または関数を指定できます。
また、2つめの値として出現したマッチの合計数も返します。
<code>gsub</code> という名前は <em>Global SUBstitution</em> から来ています。


<p>
<code>repl</code> が文字列の場合はその値が置換に使われます。
文字 <code>%</code> はエスケープ文字として動作します。
<code>repl</code> 中の <code>%<em>d</em></code>
(ただし <em>d</em> は1から9)
形式の並びは、<em>d</em>番目のキャプチャした部分文字列の値を表します。
並び <code>%0</code> はマッチ全体を表し、並び
<code>%%</code> は単一の <code>%</code> を表します。


<p>
<code>repl</code> がテーブルの場合は、各マッチに対し、1番目のキャプチャをキーとして使ってテーブルが検索されます。


<p>
<code>repl</code> が関数の場合は、マッチが出現するたびにその関数が呼ばれ、キャプチャした部分文字列が順番通りに引数として渡されます。


<p>
どの場合でも、パターンにキャプチャが無ければ、パターン全体が1個のキャプチャ内にあるかのように動作します。


<p>
テーブル検索や関数呼び出しの戻り値が文字列または数値であれば、それが置換文字列として使われます。
そうでなく、 <b>false</b> または <b>nil</b> であれば、置換は行われません
(つまり文字列中の元のマッチがそのまま保たれます)。


<p>
いくつか例を挙げます。

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"

     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"

     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"

     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"

     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"

     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.3.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
文字列を受け取り、その長さを返します。
空文字列 <code>""</code> の長さは0です。
ゼロも数えられるので、
<code>"a\000bc\000"</code> の長さは5です。




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
文字列を受け取り、その文字列中の大文字をすべて小文字に変更した文字列を返します。
それ以外の文字は変更されません。
何が大文字であるかの定義は現在のロケールに依存します。




<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
文字列 <code>s</code> 中の <code>pattern</code>
(<a href="#6.4.1">&sect;6.4.1</a> を参照)
の最初の<em>マッチ</em>を検索します。
見つかった場合は、そのパターンのキャプチャを返します。
そうでなければ <b>nil</b> を返します。
<code>pattern</code> にキャプチャが無ければ、マッチ全体が返されます。
省略可能な第3引数 <code>init</code> は検索の開始位置を指定する数値です。
デフォルト値は1で、負の値も指定できます。




<p>
<hr><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>


<p>
書式文字列 <code>fmt</code>
(<a href="#6.4.2">&sect;6.4.2</a> を参照)
に従って、値 <code>v1</code>、<code>v2</code>、&middot;&middot;&middot;
をバイナリ文字列にパックし、その文字列を返します。




<p>
<hr><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>


<p>
指定された書式で
<a href="#pdf-string.pack"><code>string.pack</code></a>
から返される文字列のサイズを返します。
書式文字列には可変長のオプション
'<code>s</code>' および '<code>z</code>'
を含めることはできません
(<a href="#6.4.2">&sect;6.4.2</a> を参照)。




<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
文字列 <code>s</code> を文字列 <code>sep</code> で区切って
<code>n</code> 個連結した文字列を返します。
<code>sep</code> のデフォルト値は空文字列
(つまり区切り文字なし) です。
<code>n</code> が正の値でなければ空文字列を返します。




<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
文字列 <code>s</code> を反転した文字列を返します。




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
<code>s</code> の <code>i</code> 文字目から <code>j</code> 文字目までの部分文字列を返します。
<code>i</code> および <code>j</code> には負の値も指定できます。
<code>j</code> を省略した場合は-1
(つまり文字列の長さ)
になります。
例えば呼び出し <code>string.sub(s,1,j)</code> は
<code>s</code> の先頭から <code>j</code> 文字を返し、
<code>string.sub(s, -i)</code> は
<code>s</code> の最後から <code>i</code> 文字を返します。


<p>
負のインデックスを変換した後、
<code>i</code> が1より小さければ1に修正され、
<code>j</code> が文字列の長さより大きければその長さに修正されます。
これらの修正の後、
<code>i</code> が <code>j</code> より大きければ空文字列が返されます。




<p>
<hr><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>


<p>
書式文字列 <code>fmt</code> (<a href="#6.4.2">&sect;6.4.2</a> を参照)
に従って、文字列 <code>s</code> にパックされた値を返します
(<a href="#pdf-string.pack"><code>string.pack</code></a> を参照)。
省略可能な <code>pos</code> は
<code>s</code> の読み込み開始位置を指定します (デフォルトは1です)。
値を読み込んだ後、
<code>s</code> の最初の未読バイトのインデックスも返されます。




<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
文字列を受け取り、その文字列中の小文字をすべて大文字に変更した文字列を返します。
それ以外の文字は変更されません。
何が小文字であるかの定義は現在のロケールに依存します。





<h3>6.4.1 &ndash; <a name="6.4.1">パターン</a></h3>

<p>
Luaのパターンは、パターンマッチ関数
<a href="#pdf-string.find"><code>string.find</code></a>、
<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>、
<a href="#pdf-string.gsub"><code>string.gsub</code></a>、
<a href="#pdf-string.match"><code>string.match</code></a>
によってパターンとして解釈される正規文字列によって記述されます。
この節ではこれらの文字列の構文と意味
(つまり何にマッチするのか)
を説明します。



<h4>文字クラス</h4><p>
<em>文字クラス</em>は文字の集合を表すために使われます。
文字クラスの記述では以下の組み合わせが使えます。

<ul>

<li><b><em>x</em>: </b>
(ただし<em>x</em>は<em>魔法の文字</em><code>^$()%.[]*+-?</code>のいずれでもない)
文字<em>x</em>自身を表します。
</li>

<li><b><code>.</code>: </b> (ドット) すべての文字を表します。</li>

<li><b><code>%a</code>: </b> すべての英字を表します。</li>

<li><b><code>%c</code>: </b> すべての制御文字を表します。</li>

<li><b><code>%d</code>: </b> すべての数字を表します。</li>

<li><b><code>%g</code>: </b> 空白以外のすべての印刷可能文字を表します。</li>

<li><b><code>%l</code>: </b> すべての小文字を表します。</li>

<li><b><code>%p</code>: </b> すべての句読点文字を表します。</li>

<li><b><code>%s</code>: </b> すべての空白文字を表します。</li>

<li><b><code>%u</code>: </b> すべての大文字を表します。</li>

<li><b><code>%w</code>: </b> すべての英数字を表します。</li>

<li><b><code>%x</code>: </b> すべての16進数字を表します。</li>

<li><b><code>%<em>x</em></code>: </b>
(ただし<em>x</em>は英数以外の任意の文字)
文字<em>x</em>を表します。
これは魔法の文字をエスケープする標準的な方法です。
英数以外のあらゆる文字
(魔法でない文字も含むすべての句読点文字が含まれます)
は、前に '<code>%</code>' を付けることでパターン中でそれ自身を表すことができます。
</li>

<li><b><code>[<em>set</em>]</code>: </b>
<em>set</em>の中のすべての文字の和集合であるクラスを表します。
'<code>-</code>' を使って範囲の終わりの文字を区切ることによって、その範囲の文字を指定することができます。
範囲は昇順です。
上で説明したすべてのクラス <code>%</code><em>x</em>
は<em>set</em>の中でも部品として使うことができます。
<em>set</em>の中のそれ以外の文字はすべてそれ自身を表します。
例えば
<code>[%w_]</code> (または <code>[_%w]</code>)
はすべての英数字にアンダースコアを加えたものを表し、
<code>[0-7]</code>
は8進数字を表し、
<code>[0-7%l%-]</code>
は8進数字に小文字と '<code>-</code>' 文字を加えたものを表します。


<p>
範囲とクラスの相互作用は定義されていません。
そのため
<code>[%a-z]</code> や <code>[a-%%]</code>
といったパターンは無意味です。
</li>

<li><b><code>[^<em>set</em>]</code>: </b>
<em>set</em>の補集合を表します。
<em>set</em>は上で述べた通りに解釈されます。
</li>

</ul><p>
ひとつの文字で表されているクラス
(<code>%a</code>、<code>%c</code> など)
はすべて、対応する大文字でそのクラスの補集合を表します。
例えば
<code>%S</code> は空白以外のすべての文字を表します。


<p>
英字、空白などの文字グループは現在のロケールに依存します。
例えば、クラス <code>[a-z]</code> と <code>%l</code> は同等でない場合があります。





<h4>パターン項目</h4><p>
<em>パターン項目</em>は以下のいずれかです。

<ul>

<li>
単一の文字クラス。
そのクラス中の任意の1文字にマッチします。
</li>

<li>
単一の文字クラスに '<code>*</code>' が続いたもの。
そのクラス中の文字の0回以上の繰り返しにマッチします。
これらの繰り返し項目は必ず最も長いマッチ可能な並びにマッチします。
</li>

<li>
単一の文字クラスに '<code>+</code>' が続いたもの。
そのクラス中の文字の1回以上の繰り返しにマッチします。
これらの繰り返し項目は必ず最も長いマッチ可能な並びにマッチします。
</li>

<li>
単一の文字クラスに '<code>-</code>' が続いたもの。
そのクラス中の文字の0回以上の繰り返しにマッチします。
'<code>*</code>' と異なり、
これらの繰り返し項目は必ず最も短いマッチ可能な並びにマッチします。
</li>

<li>
単一の文字クラスに '<code>?</code>' が続いたもの。
そのクラス中の文字の0回または1回の出現にマッチします。
可能であれば常に1回の出現にマッチします。
</li>

<li>
<code>%<em>n</em></code>
(ただし<em>n</em>は1から9)
この項目は<em>n</em>番目のキャプチャした文字列 (後述)
と等しい部分文字列にマッチします。
</li>

<li>
<code>%b<em>xy</em></code>
(ただし<em>x</em>と<em>y</em>は2つの別々の文字)
この項目は、<em>x</em>で始まり<em>y</em>で終わる、<em>x</em>と<em>y</em>の<em>釣り合いが取れている</em>文字列にマッチします。
つまり、文字列を左から右に読み進み、<em>x</em>のときに<em>+1</em>、<em>y</em>のときに<em>-1</em>をカウントするとき、最初にカウントが0になった<em>y</em>が終わりの<em>y</em>になります。
例えば、項目 <code>%b()</code> は括弧の釣り合いが取れている式にマッチします。
</li>

<li>
<code>%f[<em>set</em>]</code>
(<em>境界パターン</em>)
この項目は、次の文字が<em>set</em>に属し、前の文字が<em>set</em>に属しない、任意の位置の空文字列にマッチします。
集合<em>set</em>は先程説明したように解釈されます。
対象の先頭と末尾は文字 '<code>\0</code>' があるかのように処理されます。
</li>

</ul>




<h4>パターン</h4><p>
<em>パターン</em>はパターン項目の並びです。
パターンの先頭にキャレット '<code>^</code>'
があれば、マッチが対象文字列の先頭に固定されます。
パターンの最後に '<code>$</code>'
があれば、マッチが対象文字列の最後に固定されます。
それ以外の場所では、 '<code>^</code>' および '<code>$</code>'
は特別な意味を持たず、それ自身を表します。





<h4>キャプチャ</h4><p>
パターンには括弧で囲ったサブパターンを含めることができます。
これは<em>キャプチャ</em>を表します。
マッチが成功すると、対象文字列のうちキャプチャにマッチした部分の文字列が、後の使用のために保存されます
(<em>キャプチャされ</em>ます)。
キャプチャは、その左括弧によって番号付けされます。
例えばパターン <code>"(a*(.)%w(%s*))"</code> の場合、
<code>"a*(.)%w(%s*)"</code> にマッチした部分の文字列が最初のキャプチャ
(つまり番号1) として保存され、
"<code>.</code>" にマッチした文字が番号2でキャプチャされ、
"<code>%s*</code>" にマッチした部分が番号3になります。


<p>
特別な場合として、空のキャプチャ <code>()</code>
を使うと現在の文字列位置 (数値) をキャプチャします。
例えば、パターン <code>"()aa()"</code> を文字列 <code>"flaaap"</code>
に適用すると、2つのキャプチャ3と5が得られます。







<h3>6.4.2 &ndash; <a name="6.4.2">packおよびunpackの書式文字列</a></h3>

<p>
<a href="#pdf-string.pack"><code>string.pack</code></a>、
<a href="#pdf-string.packsize"><code>string.packsize</code></a>、
<a href="#pdf-string.unpack"><code>string.unpack</code></a>
の第1引数は書式文字列で、作成する (または読み込む) 構造体のレイアウトを記述します。


<p>
書式文字列は変換オプションの並びです。
変換オプションは以下のものが指定できます。

<ul>
<li><b><code>&lt;</code>: </b>リトルエンディアンに設定します。</li>
<li><b><code>&gt;</code>: </b>ビッグエンディアンに設定します。</li>
<li><b><code>=</code>: </b>ネイティブエンディアンに設定します。</li>
<li><b><code>![<em>n</em>]</code>: </b>アラインメントを <code>n</code> に設定します
(デフォルトはネイティブアラインメント)。</li>
<li><b><code>b</code>: </b>符号付きバイト (<code>char</code>)。</li>
<li><b><code>B</code>: </b>符号無しバイト (<code>char</code>)。</li>
<li><b><code>h</code>: </b>符号付き<code>short</code> (ネイティブサイズ)。</li>
<li><b><code>H</code>: </b>符号無し<code>short</code> (ネイティブサイズ)。</li>
<li><b><code>l</code>: </b>符号付き<code>long</code> (ネイティブサイズ)。</li>
<li><b><code>L</code>: </b>符号無し<code>long</code> (ネイティブサイズ)。</li>
<li><b><code>j</code>: </b><code>lua_Integer</code>。</li>
<li><b><code>J</code>: </b><code>lua_Unsigned</code>。</li>
<li><b><code>T</code>: </b><code>size_t</code> (ネイティブサイズ)。</li>
<li><b><code>i[<em>n</em>]</code>: </b><code>n</code>バイトの符号付き<code>int</code>
(デフォルトはネイティブサイズ)。</li>
<li><b><code>I[<em>n</em>]</code>: </b><code>n</code>バイトの符号無し<code>int</code>
(デフォルトはネイティブサイズ)。</li>
<li><b><code>f</code>: </b><code>float</code> (ネイティブサイズ)。</li>
<li><b><code>d</code>: </b><code>double</code> (ネイティブサイズ)。</li>
<li><b><code>n</code>: </b><code>lua_Number</code>。</li>
<li><b><code>c<em>n</em></code>: </b><code>n</code>バイトの固定長文字列。</li>
<li><b><code>z</code>: </b>ゼロ終端文字列。</li>
<li><b><code>s[<em>n</em>]</code>: </b>長さを前置した文字列。
長さは<code>n</code>バイトの符号無し整数
(デフォルトは<code>size_t</code>)
として符号化されます。</li>
<li><b><code>x</code>: </b>1バイトのパディング。</li>
<li><b><code>X<em>op</em></code>: </b>オプション<code>op</code>に従ってアラインメントした空項目
(<code>op</code> はアラインメント以外は無視されます)。</li>
<li><b>'<code> </code>': </b>(空白) 無視されます。</li>
</ul><p>
("<code>[<em>n</em>]</code>" は省略可能な整数値を表しています。)
パディング、空白、設定
(オプション "<code>xX &lt;=&gt;!</code>")
を除き、各オプションに引数がひとつずつ
(<a href="#pdf-string.pack"><code>string.pack</code></a> の場合)
または結果がひとつずつ
(<a href="#pdf-string.unpack"><code>string.unpack</code></a> の場合)
対応します。


<p>
オプション
"<code>!<em>n</em></code>"、"<code>s<em>n</em></code>"、"<code>i<em>n</em></code>"、"<code>I<em>n</em></code>"
において、
<code>n</code> は1から16までの任意の整数を指定できます。
整数オプションはすべてオーバーフローのチェックが行われます。
<a href="#pdf-string.pack"><code>string.pack</code></a>
では指定した値が指定したサイズに収まるかチェックされ、
<a href="#pdf-string.unpack"><code>string.unpack</code></a>
では読み込んだ値がLuaの整数に収まるかチェックされます。


<p>
書式文字列はいずれも先頭に
"<code>!1=</code>"
が付いているかのように解釈されます。
つまり最大アラインメントは1 (アラインメントなし) で、ネイティブエンディアンです。


<p>
アラインメントは以下のように動作します。
各オプションに対して、そのオプションのサイズと最大アラインメントの間で最小の倍数のオフセットからデータが開始されるまでの間に、パディングが追加されます。
この最小は2の乗数でなければなりません。
オプション "<code>c</code>" および "<code>z</code>" はアラインメントされません。
オプション "<code>s</code>" は最初の整数のアラインメントに従います。


<p>
すべてのパディングは
<a href="#pdf-string.pack"><code>string.pack</code></a>
によってゼロで埋められます
(そして
<a href="#pdf-string.unpack"><code>string.unpack</code></a>
によって無視されます。)







<h2>6.5 &ndash; <a name="6.5">UTF-8サポート</a></h2>

<p>
このライブラリはUTF-8エンコーディングの基本的なサポートを提供します。
このライブラリの関数はすべてテーブル
<a name="pdf-utf8"><code>utf8</code></a>
の中に提供されます。
このライブラリにはエンコーディング処理以外のUnicodeに対するサポートはありません。
文字の意味が必要な操作、例えば文字の分類などは対象外です。


<p>
特に明記されない限り、引数としてバイト位置を受け取る関数はすべて、その位置はバイトシーケンスの開始位置であるか、対象文字列の長さプラス1であるとみなされます。
文字列ライブラリと同様に、負のインデックスは文字列の終わりから数えられます。


<p>
<hr><h3><a name="pdf-utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
ゼロ個以上の整数を受け取り、それぞれを対応するUTF-8バイトシーケンスに変換し、それらのシーケンスをすべて連結した文字列を返します。




<p>
<hr><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>
対象が有効なUTF-8文字列であると仮定したときの、ちょうどひとつのUTF-8バイトシーケンスにマッチするパターン
(<a href="#6.4.1">&sect;6.4.1</a> を参照)
"<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>"
です (文字列です。
関数ではありません)。




<p>
<hr><h3><a name="pdf-utf8.codes"><code>utf8.codes (s)</code></a></h3>


<p>
以下の構文

<pre>
     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>
で文字列 <code>s</code> 中のすべての文字を巡回できるような値を返します。
ただし <code>p</code> は位置 (バイト単位) で、
<code>c</code> は各文字のコードポイントです。
無効なバイトシーケンスに遭遇した場合はエラーが発生します。




<p>
<hr><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j]])</code></a></h3>
バイト位置 <code>i</code> と <code>j</code> の間 (両端を含む) で始まる
<code>s</code> 中のすべての文字のコードポイントを (整数として) 返します。
<code>i</code> のデフォルト値は1、
<code>j</code> のデフォルト値は <code>i</code> です。
無効なバイトシーケンスに遭遇した場合はエラーが発生します。




<p>
<hr><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j]])</code></a></h3>
バイト位置 <code>i</code> と <code>j</code> の間 (両端を含む)
で始まる文字列 <code>s</code> 中のUTF-8文字の数を返します。
<code>i</code> のデフォルト値は1、
<code>j</code> のデフォルト値は-1です。
無効なバイトシーケンスが見つかった場合は、偽の値に加えて、最初の無効なバイトの位置を返します。




<p>
<hr><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>
<code>s</code> の <code>n</code> 文字目
(位置 <code>i</code> から数えて)
のエンコーディングが始まる位置 (バイト単位) を返します。
<code>n</code> に負の値を指定すると、位置
<code>i</code> より前の文字になります。
<code>i</code> のデフォルト値は、
<code>n</code> が負でなければ1で、
負の場合は <code>#s + 1</code> です。
例えば、
<code>utf8.offset(s, -n)</code>
はその文字列の終わりから <code>n</code> 文字目のオフセットになります。
対象中に指定された文字が無いか、終端の直後の場合は、
<b>nil</b> を返します。


<p>
特殊な場合として、
<code>n</code> が0のときは、
<code>s</code> の <code>i</code>
番目のバイトを含む文字のエンコーディング開始位置を返します。


<p>
<code>s</code> は有効なUTF-8文字列であると仮定しています。







<h2>6.6 &ndash; <a name="6.6">テーブル操作</a></h2>

<p>
このライブラリはテーブル操作のための汎用的な機能を提供します。
このライブラリの関数はすべてテーブル
<a name="pdf-table"><code>table</code></a> の中に提供されます。


<p>
操作がテーブルの長さを必要とするときは、テーブルは正規のシーケンスであるか、
<code>__len</code> メタメソッドを持たなければなりません
(<a href="#3.4.7">&sect;3.4.7</a> を参照)。
いずれの関数においても、指定されたテーブル中の数値でないキーは無視されます。


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>
すべての要素が文字列か数値であるリストを受け取り、文字列
<code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code>
を返します。
<code>sep</code> のデフォルト値は空文字列、
<code>i</code> のデフォルト値は1、
<code>j</code> のデフォルト値は <code>#list</code> です。
<code>i</code> が <code>j</code> より大きい場合は空文字列を返します。




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p>
要素
<code>list[pos]</code>、<code>list[pos+1]</code>、<code>&middot;&middot;&middot;</code>、<code>list[#list]</code>
を上に移動し、
<code>list</code> の位置 <code>pos</code> に要素 <code>value</code> を挿入します。
<code>pos</code> のデフォルト値は <code>#list+1</code> なので、
<code>table.insert(t,x)</code> はリスト <code>t</code> の最後に
<code>x</code> を挿入します。




<p>
<hr><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>


<p>
テーブル <code>a1</code> の要素をテーブル <code>a2</code> に移動します。
多重代入
<code>a2[t],&middot;&middot;&middot; = a1[f],&middot;&middot;&middot;,a1[e]</code>
と同等です。
<code>a2</code> のデフォルト値は <code>a1</code> です。
移動先の範囲と移動元の範囲は重なっていても構いません。
移動する要素の数はLuaの整数に収まらなければなりません。




<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>


<p>
すべての引数をキー 1、2、&middot;&middot;&middot;
に格納し、その引数の合計個数をフィールド "<code>n</code>"
に格納した、新しいテーブルを返します。
結果のテーブルはシーケンスでない場合があります。




<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p>
<code>list</code> から位置 <code>pos</code>
の要素を削除し、その削除した要素の値を返します。
<code>pos</code> が1と <code>#list</code> の間の整数であれば、要素
<code>list[pos+1]</code>、<code>list[pos+2]</code>、<code>&middot;&middot;&middot;</code>、<code>list[#list]</code>
は下へ移動し、要素 <code>list[#list]</code> は消去されます。
インデックス <code>pos</code> には <code>#list + 1</code>
も指定でき、また <code>#list</code> が0のときには0も指定できます。
これらの場合は要素 <code>list[pos]</code> が消去されます。


<p>
<code>pos</code> のデフォルト値は <code>#list</code>
なので、呼び出し <code>table.remove(l)</code> はリスト
<code>l</code> の最後の要素を削除します。




<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>
<code>list[1]</code> から <code>list[#list]</code>
のリスト要素を、指定した順番に<em>その場で</em>ソートします。
<code>comp</code> を指定する場合、それは関数でなければなりません。
この関数は、リストの要素を2個受け取り、1番目の要素が2番目の要素より前に来て欲しい場合に真を返さなければなりません
(つまりソート後に <code>not comp(list[i+1],list[i])</code> が真になるようにします)。
<code>comp</code> を指定しない場合は、標準のLuaの演算子
<code>&lt;</code> が代わりに使われます。


<p>
ソートのアルゴリズムは安定ではありません。
つまり、指定された順序において等しいとみなされる要素は、ソートによってその相対位置が変化する場合があります。




<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>
指定されたリストの要素を返します。
以下と同等です。

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
デフォルトでは
<code>i</code> は1で、
<code>j</code> は <code>#list</code> です。







<h2>6.7 &ndash; <a name="6.7">数学関数</a></h2>

<p>
このライブラリは基本的な数学関数を提供します。
このライブラリの関数と定数はすべてテーブル
<a name="pdf-math"><code>math</code></a>
の中に提供されます。
"<code>integer/float</code>"
という注釈が付いている関数は、整数の引数には整数の結果を、浮動小数点数の引数
(または両方が混在した引数) には浮動小数点数の結果を返します。
丸め関数
(<a href="#pdf-math.ceil"><code>math.ceil</code></a>、
<a href="#pdf-math.floor"><code>math.floor</code></a>、
<a href="#pdf-math.modf"><code>math.modf</code></a>)
は、結果が整数の範囲に収まる場合は整数を返し、そうでなければ浮動小数点数を返します。


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
<code>x</code> の絶対値を返します。
(integer/float)




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
<code>x</code> の逆余弦を (ラジアンで) 返します。




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
<code>x</code> の逆正弦を (ラジアンで) 返します。




<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>


<p>

<code>y/x</code> の逆正接を (ラジアンで) 返します。
ただし結果の象限を決めるために両方の引数の符号が使われます。
(<code>x</code> がゼロの場合も正確に処理されます。)


<p>
<code>x</code> のデフォルト値は1です。
そのため呼び出し <code>math.atan(y)</code> は
<code>y</code> の逆正接を返します。




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
<code>x</code> より大きいまたは等しい最小の整数値を返します。




<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
<code>x</code> (ラジアン) の余弦を返します。




<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
角度 <code>x</code> をラジアンから度に変換します。




<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
<em>e<sup>x</sup></em>の値を返します
(ただし <code>e</code> は自然対数の底です)。




<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
<code>x</code> より小さいまたは等しい最大の整数を返します。




<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
<code>x</code> を <code>y</code> で割った商をゼロに向かって丸めた余りを返します。
(integer/float)




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
他のいかなる数値よりも大きな浮動小数点数の値 <code>HUGE_VAL</code> です。




<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>
指定されたbaseを底とする <code>x</code> の対数を返します。
<code>base</code> のデフォルト値は<em>e</em>です
(つまり <code>x</code> の自然対数を返します)。




<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Luaの演算子 <code>&lt;</code> に従って最大の値を持つ引数を返します。
(integer/float)




<p>
<hr><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>
最も大きな整数です。




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Luaの演算子 <code>&lt;</code> に従って最小の値を持つ引数を返します。
(integer/float)




<p>
<hr><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>
最も小さな整数です。




<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
<code>x</code> の整数部と <code>x</code> の小数部を返します。
2番目の戻り値は常に浮動小数点数です。




<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
円周率<em>&pi;</em>の値です。




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
角度 <code>x</code> を度からラジアンに変換します。




<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
引数を指定せずに呼ぶと、範囲
<em>[0,1)</em> に一様に分布する浮動小数点数の擬似乱数を返します。
2つの整数 <code>m</code> と <code>n</code> を指定して呼ぶと、範囲
<em>[m, n]</em> に一様に分布する整数の擬似乱数を返します。
(<em>m-n</em> の値を負にすることはできず、またLuaの整数に収まらなければなりません。)
呼び出し <code>math.random(n)</code> は
<code>math.random(1,n)</code> と同等です。


<p>
この関数は基となるCが提供している擬似乱数生成関数へのインタフェースです。
統計的な性質については保証されていません。




<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
<code>x</code> を擬似乱数生成器の「種」として設定します。
同じ種を指定すると同じ数列が生成されます。




<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
<code>x</code> (ラジアン) の正弦を返します。




<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
<code>x</code> の平方根を返します。
(この値は式 <code>x^0.5</code> を使っても計算できます。)




<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
<code>x</code> (ラジアン) の正接を返します。




<p>
<hr><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>


<p>
値 <code>x</code> が整数に変換可能であれば、その整数を返します。
そうでなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>


<p>
<code>x</code> が整数であれば "<code>integer</code>"
を返し、浮動小数点数であれば "<code>float</code>" を返し、
<code>x</code> が数値でなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>


<p>
符号無しとして比較したとき
<code>m</code> が <code>n</code> より下であれば真を返します。







<h2>6.8 &ndash; <a name="6.8">入出力機能</a></h2>

<p>
入出力ライブラリは2種類のスタイルのファイル操作を提供します。
ひとつめは暗黙のファイルハンドルを使うもので、デフォルト入力ファイルとデフォルト出力ファイルを設定し、すべての入出力操作をこのデフォルトファイルに対して行います。
ふたつめのスタイルは明示的なファイルハンドルを使うものです。


<p>
暗黙のファイルハンドルを使うときは、すべての操作がテーブル
<a name="pdf-io"><code>io</code></a> に提供されます。
明示的なファイルハンドルを使うときは、
<a href="#pdf-io.open"><code>io.open</code></a>
からファイルハンドルが返され、すべての操作はそのファイルハンドルのメソッドとして提供されます。


<p>
テーブル <code>io</code> にはCの通常の意味を持つ3つの定義済みファイルハンドル
<a name="pdf-io.stdin"><code>io.stdin</code></a>、
<a name="pdf-io.stdout"><code>io.stdout</code></a>、
<a name="pdf-io.stderr"><code>io.stderr</code></a>
も提供されています。
入出力ライブラリがこれらのファイルを閉じることはありません。


<p>
特に明記されない限り、すべての入出力関数は失敗時に <b>nil</b>
(に加えて2番目の戻り値としてエラーメッセージと、3番目の戻り値としてシステム依存のエラーコード)
を返し、
成功時は <b>nil</b> でない値を返します。
エラー発生時のエラーメッセージとエラーコードの計算はCのグローバル変数
<code>errno</code>
に依存しているため、POSIX以外のシステムではスレッドセーフでない場合があります。


<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p>
<code>file:close()</code> と同等です。
<code>file</code> を指定しない場合はデフォルト出力ファイルを閉じます。




<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>
<code>io.output():flush()</code> と同等です。




<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>
ファイル名を指定して呼ぶと、その名前のファイルを (テキストモードで)
開き、そのハンドルをデフォルト入力ファイルとして設定します。
ファイルハンドルを指定して呼ぶと、単にそのファイルハンドルをデフォルト入力ファイルとして設定します。
引数を指定せずに呼ぶと、現在のデフォルト入力ファイルを返します。


<p>
エラーの場合、この関数はエラーコードを返す代わりにエラーを発生させます。




<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename &middot;&middot;&middot;])</code></a></h3>


<p>
指定されたファイル名を読み込みモードで開き、その開いたファイルに対して
<code>file:lines(&middot;&middot;&middot;)</code>
のように動作するイテレータ関数を返します。
イテレータ関数がファイルの終端を検出すると、
(ループを終えるため) 何の値も返さず、ファイルを自動的に閉じます。


<p>
呼び出し <code>io.lines()</code> (ファイル名を指定しない場合) は
<code>io.input():lines("*l")</code> と同等です。
つまりデフォルト入力ファイルの各行を巡回します。
この場合、ループの終了時にファイルを閉じません。


<p>
エラーの場合、この関数はエラーコードを返す代わりにエラーを発生させます。




<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
文字列 <code>mode</code> で指定されたモードでファイルを開きます。
新しいファイルハンドルを返します。
エラーの場合は <b>nil</b> とエラーメッセージを返します。


<p>
<code>mode</code> 文字列には以下のいずれかを指定できます。

<ul>
<li><b>"<code>r</code>": </b> 読み込みモード (デフォルト)。</li>
<li><b>"<code>w</code>": </b> 書き込みモード。</li>
<li><b>"<code>a</code>": </b> 追記モード。</li>
<li><b>"<code>r+</code>: </b> 更新モード。 以前のデータは維持されます。</li>
<li><b>"<code>w+</code>": </b> 更新モード。 以前のデータは消去されます。</li>
<li><b>"<code>a+</code>": </b> 追記モード。 以前のデータは維持されます。
ファイルの終端にのみ書き込むことができます。</li>
</ul><p>
また <code>mode</code> 文字列の最後に '<code>b</code>' を付けることもできます。
これはシステムによってはバイナリモードでファイルを開く場合に必要です。




<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
<a href="#pdf-io.input"><code>io.input</code></a>
と同様ですが、デフォルト出力ファイルに対して動作します。




<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
この関数はシステム依存であり、プラットフォームによっては利用できません。


<p>
別のプロセスでプログラム <code>prog</code>
を開始し、そのプログラムからデータを読み込む
(<code>mode</code> が <code>"r"</code> の場合、デフォルト)
またはそのプログラムにデータを書き込む
(<code>mode</code> が <code>"w"</code> の場合)
ために使えるファイルハンドルを返します。




<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>


<p>
<code>io.input():read(&middot;&middot;&middot;)</code> と同等です。




<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
テンポラリファイルのハンドルを返します。
このファイルは更新モードで開かれ、プログラム終了時に自動的に削除されます。




<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
<code>obj</code> が有効なファイルハンドルであるかどうかを確認します。
<code>obj</code> が開かれているファイルハンドルであれば文字列 <code>"file"</code>、
<code>obj</code> が閉じられたファイルハンドルであれば <code>"closed file"</code>、
<code>obj</code> がファイルハンドルでなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>
<code>io.output():write(&middot;&middot;&middot;)</code> と同等です。




<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
<code>file</code> を閉じます。
ハンドルがガベージコレクタに回収されればファイルは自動的に閉じられますが、そうなるまでの時間は予測できないことに注意してください。


<p>
<a href="#pdf-io.popen"><code>io.popen</code></a>
で作成されたファイルハンドルを閉じるとき、
<a href="#pdf-file:close"><code>file:close</code></a>
は
<a href="#pdf-os.execute"><code>os.execute</code></a>
が返すのと同じ値を返します。




<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
<code>file</code> に書き込まれたデータを保存します。




<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines (&middot;&middot;&middot;)</code></a></h3>


<p>
呼ばれるたびに指定された書式に従ってファイルを読み込むイテレータ関数を返します。
書式が指定されない場合はデフォルトとして "<code>l</code>" が使われます。
例えば以下の構文は

<pre>
     for c in file:lines(1) do <em>body</em> end
</pre><p>
そのファイルの現在の位置から始まるすべての文字を巡回します。
<a href="#pdf-io.lines"><code>io.lines</code></a>
と異なり、この関数はループ終了時にファイルを閉じません。


<p>
エラーの場合、この関数はエラーコードを返す代わりにエラーを発生させます。




<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>


<p>
指定された書式に従ってファイル <code>file</code> を読み込みます。
書式は読み込む内容を指定します。
各書式に対して、読み込んだ内容の文字列または数値を返します。
指定された書式でデータを読めなかった場合は <b>nil</b> を返します。
(後者の場合、残りの書式に対する読み込みは実行されません。)
書式を指定せずに読んだ場合はデフォルトの書式 (次の行を読み込む) が使用されます
(下記参照)。


<p>
以下の書式が利用可能です。

<ul>

<li><b>"<code>n</code>": </b>
数値を読み込み、それをLuaの字句規約に従って浮動小数点数または整数として返します。
(数値の前に空白や符号があっても構いません。)
この書式は必ず、数値として有効な部分を可能な限り長く読み込みます。
それが有効な数値を成していなければ
(空文字、"<code>0x</code>"、"<code>3.4e-</code>" など)、それは読み捨てられ、
<b>nil</b> を返します。
</li>

<li><b>"<code>a</code>": </b>
現在の位置から始めてファイル全体を読み込みます。
ファイルの終端では空文字列を返します。
</li>

<li><b>"<code>l</code>": </b>
次の行を読み込みますが、行末は読み飛ばします。
ファイルの終端では <b>nil</b> を返します。
これはデフォルトの書式です。
</li>

<li><b>"<code>L</code>": </b>
行末文字 (もしあれば) を維持したまま次の行を読み込みます。
ファイルの終端では <b>nil</b> を返します。
</li>

<li><b><em>数値</em>: </b>
指定した数値のバイト数 (最大) の文字列を読み込みます。
数値がゼロの場合は、何も読み込まず空文字列を返します。
いずれの場合もファイルの終端では <b>nil</b> を返します。
</li>

</ul><p>
書式 "<code>l</code>" および "<code>L</code>"
はテキストファイルに対してのみ使うべきです。




<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
ファイルの位置を設定および取得します。
ファイルの位置はファイルの先頭から測られ、
<code>offset</code> で指定された位置に以下に示す文字列 <code>whence</code>
で指定された基準点を加えた位置に設定されます。

<ul>
<li><b>"<code>set</code>": </b> 基準は0 (ファイルの先頭)</li>
<li><b>"<code>cur</code>": </b> 基準は現在位置</li>
<li><b>"<code>end</code>": </b> 基準はファイルの終端</li>
</ul><p>
成功した場合はファイルの先頭からバイト単位で測った最終的なファイルの位置を返します。
失敗した場合は <b>nil</b> とエラーを説明する文字列を返します。


<p>
<code>whence</code> のデフォルト値は <code>"cur"</code> で、
<code>offset</code> のデフォルト値は0です。
例えば、呼び出し <code>file:seek()</code>
は現在のファイルの位置を変更せずに返します。
呼び出し <code>file:seek("set")</code>
は位置をファイルの先頭に設定します
(そして0を返します)。
また、呼び出し <code>file:seek("end")</code>
は位置をファイルの終端に設定し、そのサイズを返します。




<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
出力ファイルのバッファリングモードを設定します。
以下の3つのモードが利用可能です。

<ul>

<li><b>"<code>no</code>": </b>
バッファリングなし。
いかなる出力操作の結果も直ちに現れます。
</li>

<li><b>"<code>full</code>": </b>
完全バッファリング。
出力操作は、バッファが満杯になるか、そのファイルを明示的に
<code>flush</code> したときだけ行われます
(<a href="#pdf-io.flush"><code>io.flush</code></a> を参照)。
</li>

<li><b>"<code>line</code>": </b>
行バッファリング。
出力は、改行が出力されるか、何らかのスペシャルファイル
(端末デバイスなど) から読み取りを行うまでバッファリングされます。
</li>

</ul><p>
最後の2つの場合、
<code>size</code> はバッファのサイズ (バイト単位) を指定します。
デフォルトは適当なサイズです。




<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>


<p>
各引数の値を <code>file</code> に出力します。
引数は文字列か数値でなければなりません。


<p>
成功した場合は <code>file</code> を返します。
そうでない場合は <b>nil</b> とエラーを説明する文字列を返します。







<h2>6.9 &ndash; <a name="6.9">OS機能</a></h2>

<p>
このライブラリはテーブル
<a name="pdf-os"><code>os</code></a>
を通して実装されています。


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
プログラムが使用したCPU時間のおよその量を秒単位で返します。




<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
指定された文字列 <code>format</code> に従って書式化された日付と時刻を含む文字列またはテーブルを返します。


<p>
<code>time</code> 引数を指定した場合はその時刻が書式化されます
(この値の説明は
<a href="#pdf-os.time"><code>os.time</code></a>
関数を参照)。
そうでなければ現在時刻が書式化されます。


<p>
<code>format</code> が '<code>!</code>'
で始まる場合、日付は協定世界時で書式化されます。
このオプション文字の後、
<code>format</code> が文字列 "<code>*t</code>"
であれば、以下のフィールドを持つテーブルを返します。
<ul>
<li><code>year</code> (4桁)
<li><code>month</code> (1&ndash;12)
<li><code>day</code> (1&ndash;31)
<li><code>hour</code> (0&ndash;23)
<li><code>min</code> (0&ndash;59)
<li><code>sec</code> (0&ndash;61)
<li><code>wday</code> (曜日、日曜日が1)
<li><code>yday</code> (通日)
<li><code>isdst</code> (夏時間フラグ、ブーリアン)
</ul>
<p>
夏時間の情報が利用できない場合、最後のフィールドは存在しません。


<p>
<code>format</code> が "<code>*t</code>"
でなければ、ISO Cの関数 <code>strftime</code>
と同じルールに従って書式化した日付を文字列として返します。


<p>
引数を指定せずに呼ぶと、ホストシステムと現在のロケールに依存した適当な日付時刻の表現を返します
(つまり <code>os.date()</code> は <code>os.date("%c")</code> と同等です)。


<p>
この関数はCの関数 <code>gmtime</code>
およびCの関数 <code>localtime</code>
に依存しているため、POSIX以外のシステムではスレッドセーフでない場合があります。




<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
時刻 <code>t1</code> から時刻 <code>t2</code> までの差を秒単位で返します
(ただし時刻の値は <a href="#pdf-os.time"><code>os.time</code></a> から返された値です)。
POSIX、Windows、その他いくつかのシステムでは、この値は正確に
<code>t2</code><em>-</em><code>t1</code> です。




<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
この関数はISO Cの関数 <code>system</code> と同等です。
OSのシェルによって実行される <code>command</code> を渡します。
最初の戻り値は、コマンドが正常終了した場合は
<b>true</b>、そうでなければ <b>nil</b> です。
この最初の戻り値の後、以下のような文字列と数値が返されます。

<ul>

<li><b>"<code>exit</code>": </b>
コマンドは正常に終了しました。
後の数値はコマンドの終了ステータスです。
</li>

<li><b>"<code>signal</code>": </b>
コマンドはシグナルによって終了しました。
後の数値はコマンドが終了した原因のシグナルです。
</li>

</ul>

<p>
<code>command</code> を指定せずに呼ぶと、シェルが利用可能であれば真を返します。




<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
ISO Cの関数 <code>exit</code> を呼んでホストプログラムを終了させます。
<code>code</code> が <b>true</b>
の場合、返されるステータスは <code>EXIT_SUCCESS</code> です。
<code>code</code> が <b>false</b>
の場合、返されるステータスは <code>EXIT_FAILURE</code> です。
<code>code</code> が数値の場合、返されるステータスはその数値です。
<code>code</code> のデフォルト値は <b>true</b> です。


<p>
省略可能な第2引数 <code>close</code>
が真であれば、終了前にLuaのステートが閉じられます。




<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
プロセスの環境変数 <code>varname</code> の値を返します。
その変数が定義されていなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
指定した名前のファイル
(または空のディレクトリ (POSIXシステムの場合))
を削除します。
失敗した場合は <b>nil</b>
に加え、エラーを説明する文字列とエラーコードが返されます。




<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
<code>oldname</code> という名前のファイルまたはディレクトリを
<code>newname</code> にリネームします。
失敗した場合は <b>nil</b>
に加え、エラーを説明する文字列とエラーコードが返されます。




<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
プログラムの現在のロケールを設定します。
<code>locale</code>
はロケールを指定するシステム依存の文字列です。
<code>category</code>
は変更するカテゴリを指定する省略可能な文字列で、以下のいずれかです。
<ul>
<li><code>"all"</code>
<li><code>"collate"</code>
<li><code>"ctype"</code>
<li><code>"monetary"</code>
<li><code>"numeric"</code>
<li><code>"time"</code>
</ul>
<p>
デフォルトのカテゴリは <code>"all"</code> です。
この関数は新しいロケールの名前を返します。
要求に沿えない場合は <b>nil</b> を返します。


<p>
<code>locale</code>
が空文字列の場合、現在のロケールは実装依存のネイティブなロケールに設定されます。
<code>locale</code> が文字列 "<code>C</code>"
の場合、現在のロケールは標準規格のCロケールに設定されます。


<p>
最初の引数に <b>nil</b>
を指定して呼ぶと、指定したカテゴリに対する現在のロケールの名前を返します。


<p>
この関数はCの関数 <code>setlocale</code>
に依存しているため、スレッドセーフでない場合があります。




<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
引数を指定せずに呼ぶと現在時刻を返します。
そうでなければ、指定されたテーブルで表されたローカル日時に対応する時刻の値を返します。
このテーブルには以下のフィールドが必須です。
<ul>
<li><code>year</code>
<li><code>month</code>
<li><code>day</code>
</ul>
<p>
以下のフィールドは省略可能です。
<ul>
<li><code>hour</code> (デフォルトは 12)
<li><code>min</code> (デフォルトは 0)
<li><code>sec</code> (デフォルトは 0)
<li><code>isdst</code> (デフォルトは <b>nil</b>)
</ul>
<p>
それ以外のフィールドは無視されます。
これらのフィールドの説明は
<a href="#pdf-os.date"><code>os.date</code></a>
関数を参照してください。


<p>
これらのフィールドの値は有効な範囲内である必要はありません。
例えば <code>sec</code>
が-10であれば、それ以外のフィールドで指定された時刻から-10秒を表します。
<code>hour</code>
が1000であれば、それ以外のフィールドで指定された時刻から+1000時間を表します。


<p>
戻り値はシステム依存の意味を持つ数値です。
POSIX、Windows、その他いくつかのシステムでは、この数値は特定の開始点
(「エポック」) からの秒数です。
それ以外のシステムでは、その意味は規定されておらず、
<a href="#pdf-os.date"><code>os.date</code></a>
および
<a href="#pdf-os.difftime"><code>os.difftime</code></a>
への引数としてのみ使うことができます。




<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
テンポラリファイルとして使うことのできるファイル名を持った文字列を返します。
このファイルは使用前に明示的に開かなければならず、必要なくなったときには明示的に削除しなければなりません。


<p>
POSIXシステムでは、セキュリティリスクを回避するため、その名前のファイルが作成されます。
(名前取得とファイル作成の間に他の誰かが間違ったパーミッションでファイルを作成する可能性があるためです。)
その場合でもやはり使用前にはそのファイルを開く必要があり、
(結局使わなかったとしても) そのファイルを削除する必要があります。


<p>
可能であれば
<a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>
を使う方がよいかもしれません。
こちらはプログラム終了時に自動的にファイルが削除されます。







<h2>6.10 &ndash; <a name="6.10">デバッグライブラリ</a></h2>

<p>
このライブラリはデバッグインタフェース
(<a href="#4.9">&sect;4.9</a>)
の機能をLuaのプログラムに提供します。
このライブラリを使うときは気を付けてください。
これらの関数の中には、Luaのコードに関する基本的な想定
(関数ローカルな変数は外側からアクセスできない、ユーザーデータのメタテーブルはLuaのコードから変更できない、Luaのプログラムはクラッシュしない、など)
を破るものがあり、安全なはずのコードを破壊する可能性があります。
また、このライブラリの関数の中には性能的の良くないものもあります。


<p>
このライブラリの関数はすべて
<a name="pdf-debug"><code>debug</code></a>
テーブルの中に提供されます。
スレッドに対して動作する関数はすべて、省略可能な最初の引数として操作対象のスレッドを取ります。
デフォルトは常に現在のスレッドです。


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
ユーザーとの対話モードに入ります。
対話モードではユーザーが入力した文字列が実行されます。
単純なコマンドや様々なデバッグ機能を使うことで、ユーザーがグローバル変数やローカル変数を調査したり、その値を変更したり、式を評価したりできます。
単語 <code>cont</code>
だけを含む行を入力するとこの関数を終了し、呼び出し元の実行を続けます。


<p>
<code>debug.debug</code>
に対するコマンドは、どの関数の内部にも字句的にネストしていないため、ローカル変数に直接アクセスすることはできないことに注意してください。




<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
スレッドの現在のフック設定を3つの値、現在のフック関数、現在のフックマスク、現在のフックカウントとして返します
(<a href="#pdf-debug.sethook"><code>debug.sethook</code></a>
関数で設定するものと同様です)。




<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
関数に関する情報をテーブルに格納して返します。
関数は直接指定するか、 <code>f</code> の値として数値を指定できます。
数値の場合は、指定されたスレッドのコールスタックのレベル
<code>f</code> で実行中の関数を表します。
レベル0は現在の関数 (<code>getinfo</code> 自身)、レベル1は
<code>getinfo</code> の呼び出し元の関数
(スタックに残らない末尾呼び出しは除きます)、以下同様です。
<code>f</code> がアクティブな関数の数よりも大きい場合は
<b>nil</b> を返します。


<p>
戻り値のテーブルには、埋めるフィールドを表す文字列 <code>what</code> に従って、
<a href="#lua_getinfo"><code>lua_getinfo</code></a>
が返すフィールドがすべて含まれる可能性があります。
<code>what</code> のデフォルト値は、有効な行番号のテーブル以外の利用可能なすべての情報を取得します。
オプション '<code>f</code>' を指定すると、
<code>func</code> という名前のフィールドにその関数自身が追加されます。
オプション '<code>L</code>' を指定すると、
<code>activelines</code> という名前のフィールドに有効な行番号のテーブルが追加されます。


<p>
例えば、式 <code>debug.getinfo(1,"n").name</code>
は現在の関数の名前 (もし適当な名前が見つかれば) を返します。
式 <code>debug.getinfo(print)</code> は
<a href="#pdf-print"><code>print</code></a>
関数に関する利用可能なすべての情報を持ったテーブルを返します。




<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
スタックのレベル <code>f</code> の関数のインデックス <code>local</code>
のローカル変数の名前と値を返します。
明示的なローカル変数だけでなく引数や一時変数などもアクセスできます。


<p>
最初の引数またはローカル変数はインデックス1で、以下同様です。
その関数の現在のスコープで有効な変数のみが数えられ、コード中で宣言された順番に従って番号付けられます。
負のインデックスは可変長引数を参照します。
-1は最初の可変長引数です。
指定されたインデックスの変数が存在しなければ <b>nil</b> を返します。
範囲外のレベルが指定された場合はエラーが発生します。
(レベルが有効かどうかを確認するには
<a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a>
を呼びます。)


<p>
'<code>(</code>' (開き括弧) で始まる変数名は名前のわからない変数を表します。
ループ制御変数のような内部変数やデバッグ情報が保存されていないチャンクの変数などです。


<p>
引数 <code>f</code> には関数も指定できます。
この場合は関数の引数の名前のみが返されます。




<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
指定された <code>value</code> のメタテーブルを返します。
メタテーブルがなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
レジストリテーブル (<a href="#4.5">&sect;4.5</a> を参照) を返します。




<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
関数 <code>f</code> のインデックス <code>up</code> の上位値の名前と値を返します。
指定したインデックスの上位値が存在しなければ <b>nil</b> を返します。


<p>
'<code>(</code>' (開き括弧) で始まる変数名は名前のわからない変数を表します。
デバッグ情報の保存されていないチャンクの変数などです。




<p>
<hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3>


<p>
<code>u</code> に関連付けられているLuaの値を返します。
<code>u</code> がユーザーデータでなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
指定された関数をフックとして設定します。
文字列 <code>mask</code> および数値 <code>count</code>
は、いつフックが呼ばれるかを指定します。
文字列maskは以下の文字の任意の組み合わせを指定できます。

<ul>
<li><b>'<code>c</code>': </b> 関数が呼ばれるたびにフックが呼ばれます。</li>
<li><b>'<code>r</code>': </b> 関数から戻るたびにフックが呼ばれます。</li>
<li><b>'<code>l</code>': </b> コードの新しい行に入るたびにフックが呼ばれます。</li>
</ul><p>
さらに、
<code>count</code> がゼロでなければ、
<code>count</code> 個の命令を実行するたびにフックが呼ばれます。


<p>
引数を指定せずに呼ぶとフックは無効化されます。


<p>
フックが呼ばれたとき、最初の引数は呼び出しの原因となったイベントを表す以下の文字列です。
<ul>
<li><code>"call"</code> (または <code>"tail call"</code>)
<li><code>"return"</code>
<li><code>"line"</code>
<li><code>"count"</code>
</ul>
<p>
lineイベントの場合、フックには第2引数として新しい行番号が渡されます。
フック内でレベルに2を指定して <code>getinfo</code>
を呼ぶことで、実行中の関数に関する情報をさらに取得できます
(レベル0は <code>getinfo</code> で、レベル1はフック関数です)。




<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
スタックのレベル <code>level</code> の関数のインデックス <code>local</code>
のローカル変数の値に <code>value</code> を代入します。
指定したインデックスのローカル変数が存在しない場合は <b>nil</b> を返します。
<code>level</code> が範囲外の場合はエラーが発生します。
(レベルが有効かどうかを確認するには
<code>getinfo</code> を呼びます。)
そうでなければ、そのローカル変数の名前を返します。


<p>
変数のインデックスと名前についての詳しい情報は
<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>
を参照してください。




<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
指定された <code>value</code>
に対するメタテーブルを指定された <code>table</code>
(<b>nil</b> も指定できます)
に設定します。
<code>value</code> を返します。




<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
関数 <code>f</code> のインデックス <code>up</code> の上位値に値
<code>value</code> を代入します。
指定したインデックスの上位値が存在しない場合は <b>nil</b> を返します。
そうでなければ、その上位値の名前を返します。




<p>
<hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3>


<p>
指定された <code>udata</code>
に指定されたLuaの値 <code>value</code>
を関連付けます。
<code>udata</code> はフルユーザーデータでなければなりません。


<p>
<code>udata</code> を返します。




<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
<code>message</code> が存在し、文字列でも <b>nil</b> でもなければ、
<code>message</code> を返します。
この場合はそれ以上何も処理しません。
そうでなければ、コールスタックのスタックトレースを表す文字列を返します。
省略可能な <code>message</code> 文字列はスタックトレースの先頭に追加されます。
省略可能な <code>level</code> の数値はスタックトレースを開始するレベルを表します
(デフォルトは1で、 <code>traceback</code> の呼び出し元関数です)。




<p>
<hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
指定された関数の <code>n</code> 番目の上位値に対する一意な識別子を
(ライトユーザーデータとして) 返します。


<p>
この一意な識別子を使うと、異なるクロージャが上位値を共有しているかどうかを確認することができます。
ひとつの上位値を共有している
(つまり同じ外部ローカル変数にアクセスする)
Luaのクロージャは、その上位値のインデックスに対して同一の識別子を返します。




<p>
<hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
Luaのクロージャ <code>f1</code> の <code>n1</code>
番目の上位値がLuaのクロージャ <code>f2</code> の <code>n2</code>
番目の上位値を参照するようにします。







<h1>7 &ndash; <a name="7">スタンドアロンの Lua</a></h1>

<p>
LuaはCのホストプログラムに組み込まれる拡張言語として設計されていますが、スタンドアロンの言語としても使われています。
スタンドアロンのLuaインタプリタは単純に
<code>lua</code> という名前で、標準の配布物に含まれています。
スタンドアロンのインタプリタには、デバッグライブラリも含めて標準ライブラリがすべて含まれています。
使い方は以下の通りです。

<pre>
     lua [options] [script [args]]
</pre><p>
オプションは以下の通りです。

<ul>
<li><b><code>-e <em>stat</em></code>: </b> 文字列 <em>stat</em> を実行します。</li>
<li><b><code>-l <em>mod</em></code>: </b> <em>mod</em> を "require" します。</li>
<li><b><code>-i</code>: </b> <em>スクリプト</em>の実行後に対話モードに入ります。</li>
<li><b><code>-v</code>: </b> バージョン情報を表示します。</li>
<li><b><code>-E</code>: </b> 環境変数を無視します。</li>
<li><b><code>--</code>: </b> オプションの処理を停止します。</li>
<li><b><code>-</code>: </b> <code>stdin</code> をファイルとして実行し、オプションの処理を停止します。</li>
</ul><p>
オプションを処理した後、指定された<em>スクリプト</em>が実行されます。
引数なしで起動すると、標準入力 (<code>stdin</code>) が端末の場合は
<code>lua -v -i</code> のように動作し、そうでなければ
<code>lua -</code> のように動作します。


<p>
オプション <code>-E</code>
を付けずに起動すると、いかなる引数も実行する前に、環境変数
<a name="pdf-LUA_INIT_5_3"><code>LUA_INIT_5_3</code></a>
(バージョン名付きの変数が定義されていない場合は
<a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>)
がチェックされます。
この変数の内容が <code>@<em>filename</em></code>
という書式であれば、そのファイルが実行されます。
そうでなければ、その文字列自身が実行されます。


<p>
オプション <code>-E</code> を付けて実行すると、
<code>LUA_INIT</code> を無視する以外に
<code>LUA_PATH</code> および <code>LUA_CPATH</code> の値も無視されます。
<a href="#pdf-package.path"><code>package.path</code></a>
および
<a href="#pdf-package.cpath"><code>package.cpath</code></a>
の値には、
<code>luaconf.h</code> で定義されているデフォルトのパスが設定されます。


<p>
<code>-i</code> と <code>-E</code>
を除き、すべてのオプションは順番に処理されます。
例えば以下のようなコマンドは

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
まず <code>a</code> を1に設定し、次に <code>a</code>
の値を表示し、最後にファイル <code>script.lua</code>
を引数なしで実行します。
(ただし <code>$</code> はシェルプロンプトです。
これは環境によって異なる場合があります。)


<p>
いかなるコードも実行する前に、 <code>arg</code>
という名前のグローバルなテーブルにすべてのコマンドライン引数が集められます。
スクリプトの名前がインデックス0に格納され、最初の引数はスクリプト名の後のインデックス1に格納され、以下同様です。
スクリプト名より前の引数
(つまりインタプリタ名およびオプション)
はすべて負のインデックスに格納されます。
例えば以下のコマンドでは

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
このテーブルは以下のようになります。

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
スクリプトが指定されていない場合は、インタプリタ名がインデックス0に格納され、残りの引数がそれに続きます。
例えば以下のコマンドは

<pre>
     $ lua -e "print(arg[1])"
</pre><p>
"<code>-e</code>" を表示します。
スクリプトがある場合、そのスクリプトには引数
<code>arg[1]</code>、&middot;&middot;&middot;、<code>arg[#arg]</code>
が渡されます。
(Luaのすべてのチャンクと同様に、スクリプトは可変長引数の関数としてコンパイルされます。)


<p>
対話モードではプロンプトの表示と行の待ち受けが繰り返されます。
行を読み込んだ後、その行が式として解釈されます。
成功した場合はその値が表示されます。
そうでなければその行が文として解釈されます。
不完全な文が入力された場合は、異なるプロンプトを表示し、文が完全になるまで待ち受けます。


<p>
スクリプト内で保護されていないエラーが発生した場合は、そのエラーが標準エラー出力に報告されます。
エラーオブジェクトが文字列でなく、メタメソッド <code>__tostring</code>
があれば、そのメタメソッドが呼ばれて最終的なメッセージが生成されます。
そうでなければ、そのエラーオブジェクトが文字列に変換され、それにスタックトレースが付け加えられます。


<p>
正常に終了するとメインのLuaステートが閉じられます
(<a href="#lua_close"><code>lua_close</code></a> を参照)。
<a href="#pdf-os.exit"><code>os.exit</code></a>
を呼んで終了するとこの処理を回避できます。


<p>
LuaをUnixシステムのスクリプトインタプリタとして使用できるように、スタンドアロンのインタプリタはチャンクの最初の行が
<code>#</code> で始まる場合、その行を読み飛ばします。
つまり、 <code>chmod +x</code> と以下のような <code>#!</code>
形式を使うと、Luaのスクリプトを実行可能なプログラムにすることができます。

<pre>
     #!/usr/local/bin/lua
</pre><p>
(Luaのインタプリタの場所は環境によって異なる場合があります。
<code>lua</code> が <code>PATH</code> の通った場所にあるならば、

<pre>
     #!/usr/bin/env lua
</pre><p>
がより移植性の高い方法です。)



<h1>8 &ndash; <a name="8">前バージョンとの非互換な点</a></h1>

<p>
この節ではLua 5.2からLua 5.3にプログラムを移植する際に遭遇するかもしれない非互換な点の一覧を掲載しています。
非互換のいくつかは、適切なオプション (ファイル <code>luaconf.h</code> を参照)
を使ってLuaをコンパイルすると回避できます。
しかし、これらの互換オプションは将来のバージョンでは削除される予定です。


<p>
LuaのバージョンごとにCのAPIが変更される可能性があります。
これはプログラムのソースコードを変更することを暗黙に意味するわけではなく、定数の数値やマクロとして実装された関数なども含まれています。
そのため、Luaの異なるバージョン間でのバイナリ互換は仮定するべきではありません。
新しいバージョンを使うときは、LuaのAPIを使うプログラムを必ず再コンパイルしてください。


<p>
同様に、Luaのバージョンごとにコンパイル済みチャンクの内部表現も変更される可能性があります。
コンパイル済みチャンクはLuaの異なるバージョン間での互換性はありません。


<p>
公式の配布物の標準のパスはバージョン間で変更される場合があります。



<h2>8.1 &ndash; <a name="8.1">言語の変更</a></h2>
<ul>

<li>
Lua 5.2とLua 5.3の主な違いは、数値のサブタイプである整数の導入です。
この変更が「通常の」計算に影響することはないと思われますが、場合によっては
(主にオーバーフロー関係の影響で)
異なる結果になることがあります。


<p>
この差異は数値を強制的に浮動小数点数にすることで修正できます
(Lua 5.2ではすべての数値が浮動小数点数でした)。
例えば定数の最後に <code>.0</code> を付けたり、
<code>x = x + 0.0</code> で変数を変換したりできます。
(これらは非互換に対応するための臨時的な応急処理にすぎません。
良いプログラミングの一般的なガイドラインではありません。
良いプログラミングのためには、浮動小数点数が必要なところでは浮動小数点数を使い、整数が必要なところでは整数を使ってください。)
</li>

<li>
浮動小数点数を文字列に変換するとき、整数のように見える場合は結果に接尾辞
<code>.0</code> が追加されるようになりました。
(例えば、浮動小数点数の 2.0 は <code>2</code> ではなく
<code>2.0</code> と表示されます。)
数値に対して特定の書式が必要な場合は、必ず明示的な書式を使ってください。


<p>
(正確にはこれは非互換ではありません。
数値を文字列として書式化する方法は規定されていないためです。
しかし特定の書式を想定しているプログラムも存在していました。)
</li>

<li>
ガベージコレクタの世代別モードは削除されました。
(これはLua 5.2の実験的な機能でした。)
</li>

</ul>




<h2>8.2 &ndash; <a name="8.2">ライブラリの変更</a></h2>
<ul>

<li>
<code>bit32</code> ライブラリは廃止されました。
互換性のある外部のライプラリをrequireするか、あるいはより良い方法として、その関数を適切なビット演算子に置き換えてください。
(<code>bit32</code> は32ビット整数を扱っていましたが、Lua 5.3のビット演算子はLuaの整数
(デフォルトでは64ビット) を扱うことに気を付けてください。)
</li>

<li>
テーブルライブラリは要素の設定や取得の際にメタメソッドを考慮するようになりました。
</li>

<li>
<a href="#pdf-ipairs"><code>ipairs</code></a>
のイテレータはメタメソッドを考慮するようになりました。
<code>__ipairs</code> メタメソッドは廃止されました。
</li>

<li>
<a href="#pdf-io.read"><code>io.read</code></a>
のオプション名の最初の '<code>*</code>' は無くなりました。
互換性のため、この文字は引き続き受け付けられます (そして無視されます)。
</li>

<li>
数学ライブラリの以下の関数は廃止されました。
<ul>
<li><code>atan2</code>
<li><code>cosh</code>
<li><code>sinh</code>
<li><code>tanh</code>
<li><code>pow</code>
<li><code>frexp</code>
<li><code>ldexp</code>
</ul>
<p>
<code>math.pow(x,y)</code> は <code>x^y</code> で置き換えることができます。
<code>math.atan2</code> は <code>math.atan</code> で置き換えることができます。
<code>math.atan</code> は引数1個と引数2個のどちらでも受け付けるようになりました。
<code>math.ldexp(x,exp)</code> は
<code>x * 2.0^exp</code> で置き換えることができます。
それ以外の演算については、外部のライブラリを使うかLuaで実装してください。
</li>

<li>
<a href="#pdf-require"><code>require</code></a>
で使われるCのローダーの検索関数でバージョン名の処理方法が変わりました。
バージョンは (他の多くのツールと同様に)
モジュール名の後に来るようになりました。
互換性のため、この検索関数は新しい形式に従ったオープン関数が見つからなかった場合、古い書式も試みます。
(Lua 5.2ではすでにそのように動作していましたが、ドキュメントは変更されていませんでした。)
</li>

<li>
呼び出し <code>collectgarbage("count")</code>
の戻り値はひとつだけになりました。
(最初の戻り値の小数部から2番目の戻り値を計算できます。)
</li>

</ul>




<h2>8.3 &ndash; <a name="8.3">APIの変更</a></h2>


<ul>

<li>
継続関数は <code>lua_getctx</code>
を使って取得する必要があった値を引数として受け取るようになりました。
そのため <code>lua_getctx</code> は削除されました。
それに合わせてコードを変更してください。
</li>

<li>
関数 <a href="#lua_dump"><code>lua_dump</code></a>
に引数 <code>strip</code> が追加されました。
以前の動作をするにはこの引数に0を渡してください。
</li>

<li>
符号無し整数を扱う関数
(<code>lua_pushunsigned</code>、
<code>lua_tounsigned</code>、
<code>lua_tounsignedx</code>、
<code>luaL_checkunsigned</code>、
<code>luaL_optunsigned</code>)
は廃止されました。
同等の符号付きバージョンを型キャストと共に使ってください。
</li>

<li>
デフォルトでない整数型を変換するマクロ
(<code>luaL_checkint</code>、
<code>luaL_optint</code>、
<code>luaL_checklong</code>、
<code>luaL_optlong</code>)
は廃止されました。
<a href="#lua_Integer"><code>lua_Integer</code></a>
に対する同等のものを型キャストと共に使ってください
(または、可能であれば、あなたのコードで
<a href="#lua_Integer"><code>lua_Integer</code></a>
を使ってください)。
</li>

</ul>




<h1>9 &ndash; <a name="9">Lua の完全な構文</a></h1>

<p>
Luaの完全な構文を拡張BNF記法で以下に掲載します。
一般的な拡張BNF記法と同様に、
{A} はAの0回以上の繰り返しを表し、
[A] はAが省略可能であることを表します。
(演算子の優先順位は <a href="#3.4.8">&sect;3.4.8</a> を参照。
終端記号Name、Numeral、LiteralStringの説明は <a href="#3.1">&sect;3.1</a> を参照。)




<pre>

	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  &lsquo;<b>;</b>&rsquo; |
		 varlist &lsquo;<b>=</b>&rsquo; explist |
		 functioncall |
		 label |
		 <b>break</b> |
		 <b>goto</b> Name |
		 <b>do</b> block <b>end</b> |
		 <b>while</b> exp <b>do</b> block <b>end</b> |
		 <b>repeat</b> block <b>until</b> exp |
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> |
		 <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b> |
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> |
		 <b>function</b> funcname funcbody |
		 <b>local</b> <b>function</b> Name funcbody |
		 <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]

	retstat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]

	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;

	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]

	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}

	var ::=  Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefixexp &lsquo;<b>.</b>&rsquo; Name

	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}

	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | &lsquo;<b>...</b>&rsquo; | functiondef |
		 prefixexp | tableconstructor | exp binop exp | unop exp

	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;

	functioncall ::=  prefixexp args | prefixexp &lsquo;<b>:</b>&rsquo; Name args

	args ::=  &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo; | tableconstructor | LiteralString

	functiondef ::= <b>function</b> funcbody

	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>

	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;

	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp

	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;

	binop ::=  &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>//</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>%</b>&rsquo; |
		 &lsquo;<b>&amp;</b>&rsquo; | &lsquo;<b>~</b>&rsquo; | &lsquo;<b>|</b>&rsquo; | &lsquo;<b>&gt;&gt;</b>&rsquo; | &lsquo;<b>&lt;&lt;</b>&rsquo; | &lsquo;<b>..</b>&rsquo; |
		 &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo; | &lsquo;<b>~=</b>&rsquo; |
		 <b>and</b> | <b>or</b>

	unop ::= &lsquo;<b>-</b>&rsquo; | <b>not</b> | &lsquo;<b>#</b>&rsquo; | &lsquo;<b>~</b>&rsquo;

</pre>

</body></html>

