<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<title>Lua 5.2 リファレンスマニュアル</title>
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=shift_jis">
</head>

<body>

<H1>
Lua 5.2 リファレンスマニュアル
</H1>

<P>
このリファレンスマニュアルは Lua 言語の公式の定義です。
Lua プログラミングの完全な導入には
<A href="http://www.lua.org/docs.html#books">Programming in Lua</A>
を参照してください。

<P>
<A HREF="#start">スタート</A>
&middot;
<A HREF="#contents">目次</A>
&middot;
<A HREF="#index">索引</A>
<HR>
<SMALL>
Copyright &copy; 2011 Lua.org, PUC-Rio.
Freely available under the terms of the
<A HREF="http://www.lua.org/license.html#5">Lua license</A>.
</SMALL>

<DIV class="contents">
<H2><A NAME="contents">目次</A></H2>
<UL style="padding: 0">
<LI><A HREF="#0">0 &ndash; 日本語訳について</A>
<P>
<LI><A HREF="#1">1 &ndash; 序文</A>
<P>
<LI><A HREF="#2">2 &ndash; 基本コンセプト</A>
<UL>
<LI><A HREF="#2.1">2.1 &ndash; 値と型</A>
<LI><A HREF="#2.2">2.2 &ndash; 環境とグローバル環境</A>
<LI><A HREF="#2.3">2.3 &ndash; エラー処理</A>
<LI><A HREF="#2.4">2.4 &ndash; メタテーブルとメタメソッド</A>
<LI><A HREF="#2.5">2.5 &ndash; ガベージコレクション</A>
<UL>
<LI><A HREF="#2.5.1">2.5.1 &ndash; ガベージコレクションメタメソッド</A>
<LI><A HREF="#2.5.2">2.5.2 &ndash; 弱参照テーブル</A>
</UL>
<LI><A HREF="#2.6">2.6 &ndash; コルーチン</A>
</UL>
<P>
<LI><A HREF="#3">3 &ndash; 言語</A>
<UL>
<LI><A HREF="#3.1">3.1 &ndash; 字句構造</A>
<LI><A HREF="#3.2">3.2 &ndash; 変数</A>
<LI><A HREF="#3.3">3.3 &ndash; 文</A>
<UL>
<LI><A HREF="#3.3.1">3.3.1 &ndash; ブロック</A>
<LI><A HREF="#3.3.2">3.3.2 &ndash; チャンク</A>
<LI><A HREF="#3.3.3">3.3.3 &ndash; 代入</A>
<LI><A HREF="#3.3.4">3.3.4 &ndash; 制御構造</A>
<LI><A HREF="#3.3.5">3.3.5 &ndash; for 文</A>
<LI><A HREF="#3.3.6">3.3.6 &ndash; 文としての関数呼び出し</A>
<LI><A HREF="#3.3.7">3.3.7 &ndash; ローカル宣言</A>
</UL>
<LI><A HREF="#3.4">3.4 &ndash; 式</A>
<UL>
<LI><A HREF="#3.4.1">3.4.1 &ndash; 算術演算子</A>
<LI><A HREF="#3.4.2">3.4.2 &ndash; 強制型変換</A>
<LI><A HREF="#3.4.3">3.4.3 &ndash; 関係演算子</A>
<LI><A HREF="#3.4.4">3.4.4 &ndash; 論理演算子</A>
<LI><A HREF="#3.4.5">3.4.5 &ndash; 連結</A>
<LI><A HREF="#3.4.6">3.4.6 &ndash; 長さ演算子</A>
<LI><A HREF="#3.4.7">3.4.7 &ndash; 優先順位</A>
<LI><A HREF="#3.4.8">3.4.8 &ndash; テーブルコンストラクタ</A>
<LI><A HREF="#3.4.9">3.4.9 &ndash; 関数呼び出し</A>
<LI><A HREF="#3.4.10">3.4.10 &ndash; 関数定義</A>
</UL>
<LI><A HREF="#3.5">3.5 &ndash; 可視性ルール</A>
</UL>
<P>
<LI><A HREF="#4">4 &ndash; API</A>
<UL>
<LI><A HREF="#4.1">4.1 &ndash; スタック</A>
<LI><A HREF="#4.2">4.2 &ndash; スタックサイズ</A>
<LI><A HREF="#4.3">4.3 &ndash; 有効なおよび受け入れ可能なインデックス</A>
<LI><A HREF="#4.4">4.4 &ndash; C のクロージャ</A>
<LI><A HREF="#4.5">4.5 &ndash; レジストリ</A>
<LI><A HREF="#4.6">4.6 &ndash; C でのエラー処理</A>
<LI><A HREF="#4.7">4.7 &ndash; C での yield 処理</A>
<LI><A HREF="#4.8">4.8 &ndash; 関数と型</A>
<LI><A HREF="#4.9">4.9 &ndash; デバッグインタフェイス</A>
</UL>
<P>
<LI><A HREF="#5">5 &ndash; 補助ライブラリ</A>
<UL>
<LI><A HREF="#5.1">5.1 &ndash; 関数と型</A>
</UL>
<P>
<LI><A HREF="#6">6 &ndash; 標準ライブラリ</A>
<UL>
<LI><A HREF="#6.1">6.1 &ndash; 基本関数</A>
<LI><A HREF="#6.2">6.2 &ndash; コルーチン操作</A>
<LI><A HREF="#6.3">6.3 &ndash; モジュール</A>
<LI><A HREF="#6.4">6.4 &ndash; 文字列操作</A>
<UL>
<LI><A HREF="#6.4.1">6.4.1 &ndash; パターン</A>
</UL>
<LI><A HREF="#6.5">6.5 &ndash; テーブル操作</A>
<LI><A HREF="#6.6">6.6 &ndash; 数学関数</A>
<LI><A HREF="#6.7">6.7 &ndash; ビット演算</A>
<LI><A HREF="#6.8">6.8 &ndash; 入出力機能</A>
<LI><A HREF="#6.9">6.9 &ndash; OS機能</A>
<LI><A HREF="#6.10">6.10 &ndash; デバッグライブラリ</A>
</UL>
<P>
<LI><A HREF="#7">7 &ndash; スタンドアロンの Lua</A>
<P>
<LI><A HREF="#8">8 &ndash; 前のバージョンと非互換な点</A>
<UL>
<LI><A HREF="#8.1">8.1 &ndash; 言語の変更</A>
<LI><A HREF="#8.2">8.2 &ndash; ライブラリの変更</A>
<LI><A HREF="#8.3">8.3 &ndash; API の変更</A>
</UL>
<P>
<LI><A HREF="#9">9 &ndash; Lua の完全な構文</A>
</UL>
</DIV>

<H2><A NAME="index">索引</A></H2>
<TABLE WIDTH="100%">
<TR VALIGN="top">
<TD>
<H3><A NAME="functions">Lua の関数</A></H3>
<P>
<A HREF="#pdf-_G">_G</A><BR>
<A HREF="#pdf-_VERSION">_VERSION</A><BR>

<P>
<A HREF="#pdf-assert">assert</A><BR>
<A HREF="#pdf-collectgarbage">collectgarbage</A><BR>
<A HREF="#pdf-dofile">dofile</A><BR>
<A HREF="#pdf-error">error</A><BR>
<A HREF="#pdf-getmetatable">getmetatable</A><BR>
<A HREF="#pdf-ipairs">ipairs</A><BR>
<A HREF="#pdf-loadfile">loadfile</A><BR>
<A HREF="#pdf-load">load</A><BR>
<A HREF="#pdf-next">next</A><BR>
<A HREF="#pdf-pairs">pairs</A><BR>
<A HREF="#pdf-pcall">pcall</A><BR>
<A HREF="#pdf-print">print</A><BR>
<A HREF="#pdf-rawequal">rawequal</A><BR>
<A HREF="#pdf-rawget">rawget</A><BR>
<A HREF="#pdf-rawlen">rawlen</A><BR>
<A HREF="#pdf-rawset">rawset</A><BR>
<A HREF="#pdf-require">require</A><BR>
<A HREF="#pdf-select">select</A><BR>
<A HREF="#pdf-setmetatable">setmetatable</A><BR>
<A HREF="#pdf-tonumber">tonumber</A><BR>
<A HREF="#pdf-tostring">tostring</A><BR>
<A HREF="#pdf-type">type</A><BR>
<A HREF="#pdf-xpcall">xpcall</A><BR>

<P>
<A HREF="#pdf-bit32.arshift">bit32.arshift</A><BR>
<A HREF="#pdf-bit32.band">bit32.band</A><BR>
<A HREF="#pdf-bit32.bnot">bit32.bnot</A><BR>
<A HREF="#pdf-bit32.bor">bit32.bor</A><BR>
<A HREF="#pdf-bit32.btest">bit32.btest</A><BR>
<A HREF="#pdf-bit32.bxor">bit32.bxor</A><BR>
<A HREF="#pdf-bit32.extract">bit32.extract</A><BR>
<A HREF="#pdf-bit32.lrotate">bit32.lrotate</A><BR>
<A HREF="#pdf-bit32.lshift">bit32.lshift</A><BR>
<A HREF="#pdf-bit32.replace">bit32.replace</A><BR>
<A HREF="#pdf-bit32.rrotate">bit32.rrotate</A><BR>
<A HREF="#pdf-bit32.rshift">bit32.rshift</A><BR>

<P>
<A HREF="#pdf-coroutine.create">coroutine.create</A><BR>
<A HREF="#pdf-coroutine.resume">coroutine.resume</A><BR>
<A HREF="#pdf-coroutine.running">coroutine.running</A><BR>
<A HREF="#pdf-coroutine.status">coroutine.status</A><BR>
<A HREF="#pdf-coroutine.wrap">coroutine.wrap</A><BR>
<A HREF="#pdf-coroutine.yield">coroutine.yield</A><BR>

<P>
<A HREF="#pdf-debug.debug">debug.debug</A><BR>
<A HREF="#pdf-debug.getuservalue">debug.getuservalue</A><BR>
<A HREF="#pdf-debug.gethook">debug.gethook</A><BR>
<A HREF="#pdf-debug.getinfo">debug.getinfo</A><BR>
<A HREF="#pdf-debug.getlocal">debug.getlocal</A><BR>
<A HREF="#pdf-debug.getmetatable">debug.getmetatable</A><BR>
<A HREF="#pdf-debug.getregistry">debug.getregistry</A><BR>
<A HREF="#pdf-debug.getupvalue">debug.getupvalue</A><BR>
<A HREF="#pdf-debug.setuservalue">debug.setuservalue</A><BR>
<A HREF="#pdf-debug.sethook">debug.sethook</A><BR>
<A HREF="#pdf-debug.setlocal">debug.setlocal</A><BR>
<A HREF="#pdf-debug.setmetatable">debug.setmetatable</A><BR>
<A HREF="#pdf-debug.setupvalue">debug.setupvalue</A><BR>
<A HREF="#pdf-debug.traceback">debug.traceback</A><BR>
<A HREF="#pdf-debug.upvalueid">debug.upvalueid</A><BR>
<A HREF="#pdf-debug.upvaluejoin">debug.upvaluejoin</A><BR>

<P>
<A HREF="#pdf-file:close">file:close</A><BR>
<A HREF="#pdf-file:flush">file:flush</A><BR>
<A HREF="#pdf-file:lines">file:lines</A><BR>
<A HREF="#pdf-file:read">file:read</A><BR>
<A HREF="#pdf-file:seek">file:seek</A><BR>
<A HREF="#pdf-file:setvbuf">file:setvbuf</A><BR>
<A HREF="#pdf-file:write">file:write</A><BR>

<P>
<A HREF="#pdf-io.close">io.close</A><BR>
<A HREF="#pdf-io.flush">io.flush</A><BR>
<A HREF="#pdf-io.input">io.input</A><BR>
<A HREF="#pdf-io.lines">io.lines</A><BR>
<A HREF="#pdf-io.open">io.open</A><BR>
<A HREF="#pdf-io.output">io.output</A><BR>
<A HREF="#pdf-io.popen">io.popen</A><BR>
<A HREF="#pdf-io.read">io.read</A><BR>
<A HREF="#pdf-io.stderr">io.stderr</A><BR>
<A HREF="#pdf-io.stdin">io.stdin</A><BR>
<A HREF="#pdf-io.stdout">io.stdout</A><BR>
<A HREF="#pdf-io.tmpfile">io.tmpfile</A><BR>
<A HREF="#pdf-io.type">io.type</A><BR>
<A HREF="#pdf-io.write">io.write</A><BR>

</TD>
<TD>
<H3>&nbsp;</H3>
<P>
<A HREF="#pdf-math.abs">math.abs</A><BR>
<A HREF="#pdf-math.acos">math.acos</A><BR>
<A HREF="#pdf-math.asin">math.asin</A><BR>
<A HREF="#pdf-math.atan">math.atan</A><BR>
<A HREF="#pdf-math.atan2">math.atan2</A><BR>
<A HREF="#pdf-math.ceil">math.ceil</A><BR>
<A HREF="#pdf-math.cos">math.cos</A><BR>
<A HREF="#pdf-math.cosh">math.cosh</A><BR>
<A HREF="#pdf-math.deg">math.deg</A><BR>
<A HREF="#pdf-math.exp">math.exp</A><BR>
<A HREF="#pdf-math.floor">math.floor</A><BR>
<A HREF="#pdf-math.fmod">math.fmod</A><BR>
<A HREF="#pdf-math.frexp">math.frexp</A><BR>
<A HREF="#pdf-math.huge">math.huge</A><BR>
<A HREF="#pdf-math.ldexp">math.ldexp</A><BR>
<A HREF="#pdf-math.log">math.log</A><BR>
<A HREF="#pdf-math.max">math.max</A><BR>
<A HREF="#pdf-math.min">math.min</A><BR>
<A HREF="#pdf-math.modf">math.modf</A><BR>
<A HREF="#pdf-math.pi">math.pi</A><BR>
<A HREF="#pdf-math.pow">math.pow</A><BR>
<A HREF="#pdf-math.rad">math.rad</A><BR>
<A HREF="#pdf-math.random">math.random</A><BR>
<A HREF="#pdf-math.randomseed">math.randomseed</A><BR>
<A HREF="#pdf-math.sin">math.sin</A><BR>
<A HREF="#pdf-math.sinh">math.sinh</A><BR>
<A HREF="#pdf-math.sqrt">math.sqrt</A><BR>
<A HREF="#pdf-math.tan">math.tan</A><BR>
<A HREF="#pdf-math.tanh">math.tanh</A><BR>

<P>
<A HREF="#pdf-os.clock">os.clock</A><BR>
<A HREF="#pdf-os.date">os.date</A><BR>
<A HREF="#pdf-os.difftime">os.difftime</A><BR>
<A HREF="#pdf-os.execute">os.execute</A><BR>
<A HREF="#pdf-os.exit">os.exit</A><BR>
<A HREF="#pdf-os.getenv">os.getenv</A><BR>
<A HREF="#pdf-os.remove">os.remove</A><BR>
<A HREF="#pdf-os.rename">os.rename</A><BR>
<A HREF="#pdf-os.setlocale">os.setlocale</A><BR>
<A HREF="#pdf-os.time">os.time</A><BR>
<A HREF="#pdf-os.tmpname">os.tmpname</A><BR>

<P>
<A HREF="#pdf-package.config">package.config</A><BR>
<A HREF="#pdf-package.cpath">package.cpath</A><BR>
<A HREF="#pdf-package.loaded">package.loaded</A><BR>
<A HREF="#pdf-package.loadlib">package.loadlib</A><BR>
<A HREF="#pdf-package.path">package.path</A><BR>
<A HREF="#pdf-package.preload">package.preload</A><BR>
<A HREF="#pdf-package.searchers">package.searchers</A><BR>
<A HREF="#pdf-package.searchpath">package.searchpath</A><BR>

<P>
<A HREF="#pdf-string.byte">string.byte</A><BR>
<A HREF="#pdf-string.char">string.char</A><BR>
<A HREF="#pdf-string.dump">string.dump</A><BR>
<A HREF="#pdf-string.find">string.find</A><BR>
<A HREF="#pdf-string.format">string.format</A><BR>
<A HREF="#pdf-string.gmatch">string.gmatch</A><BR>
<A HREF="#pdf-string.gsub">string.gsub</A><BR>
<A HREF="#pdf-string.len">string.len</A><BR>
<A HREF="#pdf-string.lower">string.lower</A><BR>
<A HREF="#pdf-string.match">string.match</A><BR>
<A HREF="#pdf-string.rep">string.rep</A><BR>
<A HREF="#pdf-string.reverse">string.reverse</A><BR>
<A HREF="#pdf-string.sub">string.sub</A><BR>
<A HREF="#pdf-string.upper">string.upper</A><BR>

<P>
<A HREF="#pdf-table.concat">table.concat</A><BR>
<A HREF="#pdf-table.insert">table.insert</A><BR>
<A HREF="#pdf-table.pack">table.pack</A><BR>
<A HREF="#pdf-table.remove">table.remove</A><BR>
<A HREF="#pdf-table.sort">table.sort</A><BR>
<A HREF="#pdf-table.unpack">table.unpack</A><BR>

</TD>
<TD>
<H3>C の API</H3>
<P>
<A HREF="#lua_Alloc">lua_Alloc</A><BR>
<A HREF="#lua_CFunction">lua_CFunction</A><BR>
<A HREF="#lua_Debug">lua_Debug</A><BR>
<A HREF="#lua_Hook">lua_Hook</A><BR>
<A HREF="#lua_Integer">lua_Integer</A><BR>
<A HREF="#lua_Number">lua_Number</A><BR>
<A HREF="#lua_Reader">lua_Reader</A><BR>
<A HREF="#lua_State">lua_State</A><BR>
<A HREF="#lua_Unsigned">lua_Unsigned</A><BR>
<A HREF="#lua_Writer">lua_Writer</A><BR>

<P>
<A HREF="#lua_absindex">lua_absindex</A><BR>
<A HREF="#lua_arith">lua_arith</A><BR>
<A HREF="#lua_atpanic">lua_atpanic</A><BR>
<A HREF="#lua_call">lua_call</A><BR>
<A HREF="#lua_callk">lua_callk</A><BR>
<A HREF="#lua_checkstack">lua_checkstack</A><BR>
<A HREF="#lua_close">lua_close</A><BR>
<A HREF="#lua_compare">lua_compare</A><BR>
<A HREF="#lua_concat">lua_concat</A><BR>
<A HREF="#lua_copy">lua_copy</A><BR>
<A HREF="#lua_createtable">lua_createtable</A><BR>
<A HREF="#lua_dump">lua_dump</A><BR>
<A HREF="#lua_error">lua_error</A><BR>
<A HREF="#lua_gc">lua_gc</A><BR>
<A HREF="#lua_getallocf">lua_getallocf</A><BR>
<A HREF="#lua_getctx">lua_getctx</A><BR>
<A HREF="#lua_getfield">lua_getfield</A><BR>
<A HREF="#lua_getglobal">lua_getglobal</A><BR>
<A HREF="#lua_gethook">lua_gethook</A><BR>
<A HREF="#lua_gethookcount">lua_gethookcount</A><BR>
<A HREF="#lua_gethookmask">lua_gethookmask</A><BR>
<A HREF="#lua_getinfo">lua_getinfo</A><BR>
<A HREF="#lua_getlocal">lua_getlocal</A><BR>
<A HREF="#lua_getmetatable">lua_getmetatable</A><BR>
<A HREF="#lua_getstack">lua_getstack</A><BR>
<A HREF="#lua_gettable">lua_gettable</A><BR>
<A HREF="#lua_gettop">lua_gettop</A><BR>
<A HREF="#lua_getupvalue">lua_getupvalue</A><BR>
<A HREF="#lua_getuservalue">lua_getuservalue</A><BR>
<A HREF="#lua_insert">lua_insert</A><BR>
<A HREF="#lua_isboolean">lua_isboolean</A><BR>
<A HREF="#lua_iscfunction">lua_iscfunction</A><BR>
<A HREF="#lua_isfunction">lua_isfunction</A><BR>
<A HREF="#lua_islightuserdata">lua_islightuserdata</A><BR>
<A HREF="#lua_isnil">lua_isnil</A><BR>
<A HREF="#lua_isnone">lua_isnone</A><BR>
<A HREF="#lua_isnoneornil">lua_isnoneornil</A><BR>
<A HREF="#lua_isnumber">lua_isnumber</A><BR>
<A HREF="#lua_isstring">lua_isstring</A><BR>
<A HREF="#lua_istable">lua_istable</A><BR>
<A HREF="#lua_isthread">lua_isthread</A><BR>
<A HREF="#lua_isuserdata">lua_isuserdata</A><BR>
<A HREF="#lua_len">lua_len</A><BR>
<A HREF="#lua_load">lua_load</A><BR>
<A HREF="#lua_newstate">lua_newstate</A><BR>
<A HREF="#lua_newtable">lua_newtable</A><BR>
<A HREF="#lua_newthread">lua_newthread</A><BR>
<A HREF="#lua_newuserdata">lua_newuserdata</A><BR>
<A HREF="#lua_next">lua_next</A><BR>
<A HREF="#lua_pcall">lua_pcall</A><BR>
<A HREF="#lua_pcallk">lua_pcallk</A><BR>
<A HREF="#lua_pop">lua_pop</A><BR>
<A HREF="#lua_pushboolean">lua_pushboolean</A><BR>
<A HREF="#lua_pushcclosure">lua_pushcclosure</A><BR>
<A HREF="#lua_pushcfunction">lua_pushcfunction</A><BR>
<A HREF="#lua_pushfstring">lua_pushfstring</A><BR>
<A HREF="#lua_pushinteger">lua_pushinteger</A><BR>
<A HREF="#lua_pushlightuserdata">lua_pushlightuserdata</A><BR>
<A HREF="#lua_pushliteral">lua_pushliteral</A><BR>
<A HREF="#lua_pushlstring">lua_pushlstring</A><BR>
<A HREF="#lua_pushnil">lua_pushnil</A><BR>
<A HREF="#lua_pushnumber">lua_pushnumber</A><BR>
<A HREF="#lua_pushstring">lua_pushstring</A><BR>
<A HREF="#lua_pushthread">lua_pushthread</A><BR>
<A HREF="#lua_pushvalue">lua_pushvalue</A><BR>
<A HREF="#lua_pushvfstring">lua_pushvfstring</A><BR>
<A HREF="#lua_rawequal">lua_rawequal</A><BR>
<A HREF="#lua_rawget">lua_rawget</A><BR>
<A HREF="#lua_rawgeti">lua_rawgeti</A><BR>
<A HREF="#lua_rawlen">lua_rawlen</A><BR>
<A HREF="#lua_rawset">lua_rawset</A><BR>
<A HREF="#lua_rawseti">lua_rawseti</A><BR>
<A HREF="#lua-rawgetp">lua_rawgetp</A><BR>
<A HREF="#lua-rawsetp">lua_rawsetp</A><BR>
<A HREF="#lua_register">lua_register</A><BR>
<A HREF="#lua_remove">lua_remove</A><BR>
<A HREF="#lua_replace">lua_replace</A><BR>
<A HREF="#lua_resume">lua_resume</A><BR>
<A HREF="#lua_setallocf">lua_setallocf</A><BR>
<A HREF="#lua_setfield">lua_setfield</A><BR>
<A HREF="#lua_setglobal">lua_setglobal</A><BR>
<A HREF="#lua_sethook">lua_sethook</A><BR>
<A HREF="#lua_setlocal">lua_setlocal</A><BR>
<A HREF="#lua_setmetatable">lua_setmetatable</A><BR>
<A HREF="#lua_settable">lua_settable</A><BR>
<A HREF="#lua_settop">lua_settop</A><BR>
<A HREF="#lua_setupvalue">lua_setupvalue</A><BR>
<A HREF="#lua_setuservalue">lua_setuservalue</A><BR>
<A HREF="#lua_status">lua_status</A><BR>
<A HREF="#lua_toboolean">lua_toboolean</A><BR>
<A HREF="#lua_tocfunction">lua_tocfunction</A><BR>
<A HREF="#lua_tointeger">lua_tointeger</A><BR>
<A HREF="#lua_tointegerx">lua_tointegerx</A><BR>
<A HREF="#lua_tolstring">lua_tolstring</A><BR>
<A HREF="#lua_tonumber">lua_tonumber</A><BR>
<A HREF="#lua_tonumberx">lua_tonumberx</A><BR>
<A HREF="#lua_topointer">lua_topointer</A><BR>
<A HREF="#lua_tostring">lua_tostring</A><BR>
<A HREF="#lua_tothread">lua_tothread</A><BR>
<A HREF="#lua_tounsigned">lua_tounsigned</A><BR>
<A HREF="#lua_tounsignedx">lua_tounsignedx</A><BR>
<A HREF="#lua_touserdata">lua_touserdata</A><BR>
<A HREF="#lua_type">lua_type</A><BR>
<A HREF="#lua_typename">lua_typename</A><BR>
<A HREF="#lua_upvalueid">lua_upvalueid</A><BR>
<A HREF="#lua_upvalueindex">lua_upvalueindex</A><BR>
<A HREF="#lua_upvaluejoin">lua_upvaluejoin</A><BR>
<A HREF="#lua_version">lua_version</A><BR>
<A HREF="#lua_xmove">lua_xmove</A><BR>
<A HREF="#lua_yield">lua_yield</A><BR>
<A HREF="#lua_yieldk">lua_yieldk</A><BR>

</TD>
<TD>
<H3>補助ライブラリ</H3>
<P>
<A HREF="#luaL_Buffer">luaL_Buffer</A><BR>
<A HREF="#luaL_Reg">luaL_Reg</A><BR>

<P>
<A HREF="#luaL_addchar">luaL_addchar</A><BR>
<A HREF="#luaL_addlstring">luaL_addlstring</A><BR>
<A HREF="#luaL_addsize">luaL_addsize</A><BR>
<A HREF="#luaL_addstring">luaL_addstring</A><BR>
<A HREF="#luaL_addvalue">luaL_addvalue</A><BR>
<A HREF="#luaL_argcheck">luaL_argcheck</A><BR>
<A HREF="#luaL_argerror">luaL_argerror</A><BR>
<A HREF="#luaL_buffinit">luaL_buffinit</A><BR>
<A HREF="#luaL_buffinitsize">luaL_buffinitsize</A><BR>
<A HREF="#luaL_callmeta">luaL_callmeta</A><BR>
<A HREF="#luaL_checkany">luaL_checkany</A><BR>
<A HREF="#luaL_checkinteger">luaL_checkinteger</A><BR>
<A HREF="#luaL_checkint">luaL_checkint</A><BR>
<A HREF="#luaL_checklong">luaL_checklong</A><BR>
<A HREF="#luaL_checklstring">luaL_checklstring</A><BR>
<A HREF="#luaL_checknumber">luaL_checknumber</A><BR>
<A HREF="#luaL_checkoption">luaL_checkoption</A><BR>
<A HREF="#luaL_checkstack">luaL_checkstack</A><BR>
<A HREF="#luaL_checkstring">luaL_checkstring</A><BR>
<A HREF="#luaL_checktype">luaL_checktype</A><BR>
<A HREF="#luaL_checkudata">luaL_checkudata</A><BR>
<A HREF="#luaL_checkunsigned">luaL_checkunsigned</A><BR>
<A HREF="#luaL_checkversion">luaL_checkversion</A><BR>
<A HREF="#luaL_dofile">luaL_dofile</A><BR>
<A HREF="#luaL_dostring">luaL_dostring</A><BR>
<A HREF="#luaL_error">luaL_error</A><BR>
<A HREF="#luaL_execresult">luaL_execresult</A><BR>
<A HREF="#luaL_fileresult">luaL_fileresult</A><BR>
<A HREF="#luaL_getmetafield">luaL_getmetafield</A><BR>
<A HREF="#luaL_getmetatable">luaL_getmetatable</A><BR>
<A HREF="#luaL_getsubtable">luaL_getsubtable</A><BR>
<A HREF="#luaL_gsub">luaL_gsub</A><BR>
<A HREF="#luaL_len">luaL_len</A><BR>
<A HREF="#luaL_loadbuffer">luaL_loadbuffer</A><BR>
<A HREF="#luaL_loadbufferx">luaL_loadbufferx</A><BR>
<A HREF="#luaL_loadfile">luaL_loadfile</A><BR>
<A HREF="#luaL_loadfilex">luaL_loadfilex</A><BR>
<A HREF="#luaL_loadstring">luaL_loadstring</A><BR>
<A HREF="#luaL_newlib">luaL_newlib</A><BR>
<A HREF="#luaL_newlibtable">luaL_newlibtable</A><BR>
<A HREF="#luaL_newmetatable">luaL_newmetatable</A><BR>
<A HREF="#luaL_newstate">luaL_newstate</A><BR>
<A HREF="#luaL_openlibs">luaL_openlibs</A><BR>
<A HREF="#luaL_optinteger">luaL_optinteger</A><BR>
<A HREF="#luaL_optint">luaL_optint</A><BR>
<A HREF="#luaL_optlong">luaL_optlong</A><BR>
<A HREF="#luaL_optlstring">luaL_optlstring</A><BR>
<A HREF="#luaL_optnumber">luaL_optnumber</A><BR>
<A HREF="#luaL_optstring">luaL_optstring</A><BR>
<A HREF="#luaL_optunsigned">luaL_optunsigned</A><BR>
<A HREF="#luaL_prepbuffer">luaL_prepbuffer</A><BR>
<A HREF="#luaL_prepbuffsize">luaL_prepbuffsize</A><BR>
<A HREF="#luaL_pushresult">luaL_pushresult</A><BR>
<A HREF="#luaL_pushresultsize">luaL_pushresultsize</A><BR>
<A HREF="#luaL_ref">luaL_ref</A><BR>
<A HREF="#luaL_requiref">luaL_requiref</A><BR>
<A HREF="#luaL_setfuncs">luaL_setfuncs</A><BR>
<A HREF="#luaL_setmetatable">luaL_setmetatable</A><BR>
<A HREF="#luaL_testudata">luaL_testudata</A><BR>
<A HREF="#luaL_tolstring">luaL_tolstring</A><BR>
<A HREF="#luaL_traceback">luaL_traceback</A><BR>
<A HREF="#luaL_typename">luaL_typename</A><BR>
<A HREF="#luaL_unref">luaL_unref</A><BR>
<A HREF="#luaL_where">luaL_where</A><BR>

</TD>
</TR>
</TABLE>

<HR>
<SMALL CLASS="footer">
Last update:
Tue Nov 29 22:30:23 BRST 2011
</SMALL>
<!--
Last change: revised for Lua 5.2.0
-->

<hr>
<h1>
Lua 5.2 リファレンスマニュアル
</h1>

by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
<p>
<small>
Copyright &copy; 2011 Lua.org, PUC-Rio.
Freely available under the terms of the
<a href="http://www.lua.org/license.html#5">Lua license</a>.
</small>
<hr>
<p>

<p>
<a href="#contents">目次</A>
&middot;
<a href="#index">索引</A>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.94 2011/12/12 15:26:26 roberto Exp $ -->




<h1>0 &ndash; <a name="0">日本語訳について</a></h1>
<p>
この文章は、
<a href="http://www.lua.org/manual/5.2/manual.html">Lua 5.2 Reference Manual</a>
を原著者に無断で日本語に訳した、
非公式の Lua 5.2 リファレンスマニュアルです。

<h1>1 &ndash; <a name="1">序文</a></h1>

<p>
Lua は拡張プログラミング言語です。
データ記述機能を持ち、 汎用的な手続き型プログラミングをサポートするよう設計されています。
また、 オブジェクト指向プログラミング、 関数型プログラミング、 データ駆動型プログラミングもサポートしています。
Lua はパワフルで軽量で、埋め込み可能なスクリプト言語として使われることを意図しており、
そういったものが必要なあらゆるプログラムで使うことができます。
Lua はライブラリとして実装されており、 <em>クリーンな C</em>、 つまり標準 C と標準 C++ の共通のサブセットで書かれています。


<p>
拡張言語であるため、 Lua には「メイン」プログラムの概念がありません。
ホストクライアント
(<em>エンベッディングプログラム</em> あるいは単に <em>ホスト</em> とも呼ばれる)
に <em>組み込まれて</em> 動くだけです。
ホストプログラムは Lua のコード片を実行するために関数を呼ぶことができ、
Lua の変数を読み書きすることができ、
Lua のコードから呼ばれる C の関数を登録することができます。
C の関数を使うことで、
構文の枠組みを共有しながらもカスタマイズしたプログラミング言語を作ることができるので、
Lua は異なる分野に幅広く対応することができます。
Lua の配布物には <code>lua</code> と呼ばれるサンプルのホストプログラムが含まれています。
これは対話的な用途あるいはバッチ的な用途のために、
Lua ライブラリを使った完全なスタンドアロンの Lua インタプリタとなっています。


<p>
ライセンスにも述べられている通り、
Lua はフリーソフトウェアであり、
慣例により無保証で提供されます。
このマニュアルに記述されている実装は
Lua の公式ウェブサイト <code>www.lua.org</code> から入手可能です。


<p>
他のどんなリファレンスマニュアルとも同様に、
この文章は所々が無味乾燥です。
Lua の設計に関する議論は、
Lua のウェブサイトから入手できる技術論文を参照してください。
Lua プログラミングの詳しい紹介は、
Roberto 著 <em>Programming in Lua</em> を参照してください。



<h1>2 &ndash; <a name="2">基本コンセプト</a></h1>

<p>
このセクションでは言語のいくつかの基本コンセプトを説明します。



<h2>2.1 &ndash; <a name="2.1">値と型</a></h2>

<p>
Lua は <em>動的型付け言語</em> です。
つまり、 変数ではなく、 値が型を持ちます。
型定義の構文はありません。
すべての値は自分自身の型を保持しています。


<p>
Lua のすべての値は <em>ファーストクラスの値</em> です。
つまり、 すべての値は変数に格納することができ、
他の関数に引数として渡すことができ、
また戻り値として返すことができます。


<p>
Lua には 8 種類の基本型があります。
<ul>
<li><em>nil</em>
<li><em>ブーリアン</em>
<li><em>数値</em>
<li><em>文字列</em>
<li><em>関数</em>
<li><em>ユーザーデータ</em>
<li><em>スレッド</em>
<li><em>テーブル</em>
</ul>
<p>
<em>nil</em> は <b>nil</b> 値の型です。
その主な性質は他のいかなる値とも異なることであり、
通常、 役に立つ値がないことを表します。
<p>
<em>ブーリアン</em> は <b>false</b> 値と <b>true</b> 値の型です。
<b>nil</b> と <b>false</b> は両方とも条件式では偽となり、
他のすべての値は真となります。
<p>
<em>数値</em> は実数 (倍精度浮動小数点) を表します。
数値演算は元になっている C の実装と同じ規則で行われ、
通常は IEEE 754 標準に従っています。
(数値に他の内部表現、
例えば単精度浮動小数点や整数を使う Lua インタプリタをビルドすることも簡単です。
ファイル <code>luaconf.h</code> を参照してください。)
<p>
<em>文字列</em> は不変のバイト列を表します。
Lua は 8 ビットクリーンであり、
文字列には埋め込まれたゼロ ('<code>\0</code>') を含む、
いかなる 8 ビット値でも格納することができます。


<p>
Lua は Lua で書かれた関数も C で書かれた関数も呼び出す (および操作する) ことができます
(<a href="#3.4.9">&sect;3.4.9</a> を参照)。


<p>
<em>ユーザーデータ</em> 型は任意の C のデータを Lua の変数に格納するための型です。
ユーザーデータは生のメモリブロックへのポインタです。
ユーザーデータには 2 種類あります。
メモリブロックを Lua が管理するものがフルユーザーデータで、
メモリブロックをホストが管理するものがライトユーザーデータです。
ユーザーデータは、 代入と等値比較を除いて、 Lua による定義済みの演算はありません。
<em>メタテーブル</em> を使うと、
フルユーザーデータに対する演算をプログラマが定義することができます
(<a href="#2.4">&sect;2.4</a> を参照)。
ユーザーデータは Lua 内で作ったり変更したりすることはできず、
C の API を使う必要があります。
これによってホストプログラムが保持するデータの完全性が保証されます。


<p>
<em>スレッド</em> 型は独立した実行のスレッドを表し、
コルーチンを実装するために使われます (<a href="#2.6">&sect;2.6</a> を参照)。
Lua のスレッドを OS のスレッドと混同しないでください。
スレッドをサポートしていないシステム上でもコルーチンはサポートされています。


<p>
<em>テーブル</em> 型は連想配列を実装しています。
つまり数値だけでなく任意の値 (<b>nil</b> と NaN を除く) をインデックスとして使えます
(NaN とは <em>Not a Number</em> の略で、
<code>0/0</code> のような未定義もしくは表現不可能な結果を表現するために使う特殊な数値です)。
テーブルは <em>異種混合</em> できます。
つまり、 任意の型の値 (<b>nil</b> を除く) を格納できます。
値に <b>nil</b> を持つキーはテーブルの一部と見なされません。
逆に言うと、 テーブルの一部でないキーは値に <b>nil</b> が関連付けられています。


<p>
テーブルは Lua で唯一のデータを構造化する仕組みです。
通常の配列のほか、 シーケンス、 記号表、 集合、 レコード、 グラフ、 ツリーなどを表現するために使うことができます。
レコードを表現する場合はフィールド名をインデックスとして使います。
このため <code>a.name</code> という表現が
<code>a["name"]</code> のシンタックスシュガーとして用意されています。
他にも Lua にはテーブルを作るための便利な方法がいくつかあります
(<a href="#3.4.8">&sect;3.4.8</a> を参照)。


<p>
すべての正の整数キーの集合が
<em>{1..n}</em>
であるようなテーブルを、
<em>シーケンス</em> と呼ぶことにします。
整数 <em>n</em> はシーケンスの長さと呼びます
(<a href="#3.4.6">&sect;3.4.6</a> を参照)。


<p>
インデックスと同様に、
テーブルフィールドにも任意の型の値を格納できます。
例えば、
テーブルフィールドに関数を格納できます。
関数がファーストクラスの値であるためです。
そのためテーブルは <em>メソッド</em> を持つことができます
(<a href="#3.4.10">&sect;3.4.10</a> を参照)。


<p>
テーブルのインデックス検索は Lua における生の等値の定義に従います。
式 <code>a[i]</code> および <code>a[j]</code> は、
<code>i</code> と <code>j</code> が生の等値
(つまりメタメソッドなしで等しい)
であるときに限り、 同じテーブル要素を指します。


<p>
テーブル、 関数、 スレッド、 および (フル) ユーザーデータの値は <em>オブジェクト</em> です。
変数はこれらの値を実際には <em>格納</em> せず、 単にそれらを <em>参照</em> するだけです。
代入、 関数の引数渡し、 および関数の戻り値の受け取りは、 常にそれらの参照を扱います。
これらの操作はいかなる意味でも値のコピーは行いません。


<p>
ライブラリ関数 <a href="#pdf-type"><code>type</code></a> は、 指定した値の型を表す文字列を返します
(<a href="#6.1">&sect;6.1</a> を参照)。





<h2>2.2 &ndash; <a name="2.2">環境およびグローバル環境</a></h2>

<p>
<a href="#3.2">&sect;3.2</a> および <a href="#3.3.3">&sect;3.3.3</a> で述べるように、
任意のグローバル変数 <code>var</code> への参照は構文的に <code>_ENV.var</code> に変換されます。
さらに、 すべてのチャンクは <code>_ENV</code> いう名前の外部ローカル変数のスコープ内でコンパイルされます
(<a href="#3.3.2">&sect;3.3.2</a> を参照)。
そのため <code>_ENV</code> 自身はチャンク内ではグローバル変数にはなれません。


<p>
この外部変数 <code>_ENV</code> の存在やグローバル変数の変換とは関係なく、
<code>_ENV</code> は完全に正規の名前です。
例えば、
そのような名前の新しい変数や引数を定義しても構いません。
グローバル変数への参照は、
Lua の通常の可視性ルールに従い、
プログラムのその地点から見える <code>_ENV</code> を使います
(<a href="#3.5">&sect;3.5</a> を参照)。


<p>
<code>_ENV</code> の値として使われるテーブルは一般的に <em>環境</em> と呼ばれます。


<p>
Lua には <em>グローバル環境</em> と呼ばれる特別な環境があります。
この値は C のレジストリの特別なインデックスに保持されています (<a href="#4.5">&sect;4.5</a> を参照)。
Lua 内では変数 <a href="#pdf-_G"><code>_G</code></a> がこの値で初期化されます。


<p>
チャンクをコンパイルすると、
そのチャンクの <code>_ENV</code> 上位値の値はグローバル環境で初期化されます
(<a href="#pdf-load"><code>load</code></a> を参照)。
そのため、 デフォルトでは、
Lua コードのグローバル変数はグローバル環境のエントリを参照します。
さらに、 すべての標準ライブラリはグローバル環境にロードされ、
それらの関数はグローバル環境で実行されます。
<a href="#pdf-load"><code>load</code></a> (または <a href="#pdf-loadfile"><code>loadfile</code></a>)
を使って異なる環境にチャンクをロードすることもできます。
(C では、 チャンクをロードしてからその最初の上位値の値を変更する必要があります。)


<p>
レジストリ内のグローバル環境を (C のコードかデバッグライブラリを使って) 変更する場合、
変更後にロードしたチャンクはすべて、 新しい環境を使います。
しかしすでにロード済みのチャンクは影響を受けません。
各チャンクは自身の <code>_ENV</code> 変数の環境を参照し続けます。
また、 変数 <a href="#pdf-_G"><code>_G</code></a>
(元のグローバル環境に格納されているもの)
は自動的には更新されません。





<h2>2.3 &ndash; <a name="2.3">エラー処理</a></h2>

<p>
Lua は組み込み用の拡張言語であるため、
すべての Lua の活動はホストプログラム内の C のコードが
Lua ライブラリの関数を呼ぶことによって始まります (<a href="#lua_pcall"><code>lua_pcall</code></a> を参照)。
Lua チャンクのコンパイル中または実行中にエラーが発生すると、
制御がホストに戻り、
適切な処置を取ることができます (例えばエラーメッセージを表示するなど)。


<p>
Lua のコードでは <a href="#pdf-error"><code>error</code></a> 関数を呼ぶことで
明示的にエラーを発生させることができます。
Lua 内でエラーをキャッチする必要がある場合は、
指定した関数を <em>保護モード</em> で実行する
<a href="#pdf-pcall"><code>pcall</code></a> 関数または
<a href="#pdf-xpcall"><code>xpcall</code></a> 関数を使います。


<p>
エラーが発生すると、
<em>エラーオブジェクト</em> (<em>エラーメッセージ</em> とも言う) が、
そのエラーに関する情報と共に伝達されます。
Lua 自身がエラーを発生させるときは、 エラーオブジェクトは常に文字列ですが、
プログラム上では任意の値をエラーオブジェクトとしてエラーを発生させることができます。


<p>
<a href="#pdf-xpcall"><code>xpcall</code></a>
または
<a href="#lua_pcall"><code>lua_pcall</code></a>
を使うと、 エラー発生時に呼ばれる <em>メッセージハンドラ</em> を指定できます。
これは元のエラーメッセージを引数に受け取って新しいエラーメッセージを返す関数です。
メッセージハンドラはスタックが巻き戻される前に呼ばれるので、
エラーに関する情報をより多く集めることができます。
例えばスタックを調査してスタックトレースを作成することができます。
このメッセージハンドラも pcall または xpcall によって保護されているので、
メッセージハンドラ内部でエラーが発生すると、 そのメッセージハンドラが再び呼び出されます。
このループが発生し続けた場合は、 あきらめて適当なメッセージが返されます。





<h2>2.4 &ndash; <a name="2.4">メタテーブルとメタメソッド</a></h2>

<p>
Lua のすべての値は <em>メタテーブル</em> を持っています。
<em>メタテーブル</em> は通常の Lua のテーブルですが、
特殊な演算を行った時の元の値の動作を定義しています。
メタテーブルの特定のフィールドを設定することで、
値に対する演算の動作をいくつかの面で変更することができます。
例えば、 数値でない値を加算すると、
その値のメタテーブルの "<code>__add</code>" フィールドに格納されている関数が調べられます。
もしそれが見つかれば、
加算を実行するためにその関数が呼び出されます。


<p>
メタテーブルのキーは <em>イベント</em> の名前によって決めれられています。
キーに対応する値は <em>メタメソッド</em> と呼ばれます。
上の例では、 イベントは <code>"add"</code> で、
メタメソッドは加算を実行する関数です。


<p>
<a href="#pdf-getmetatable"><code>getmetatable</code></a> 関数を使うと、
任意の値のメタテーブルを取得することができます。


<p>
<a href="#pdf-setmetatable"><code>setmetatable</code></a> 関数を使うと、
テーブルのメタテーブルを変更することができます。
それ以外の型のメタテーブルを Lua から変更することはできません (デバッグライブラリを使った場合を除きます)。
そのためには C の API を使わなければなりません。


<p>
テーブルとフルユーザーデータはそれぞれ独自のメタテーブルを持ちます
(複数のテーブルやユーザーデータの間でひとつのメタテーブルを共有することもできます)。
他の型の値はすべて、 型ごとにひとつのメタテーブルを共有します。
つまり、 すべての数値に対してひとつのメタテーブルがあり、
すべての文字列に対してひとつのメタテーブルがあり、 以下同様です。
デフォルトでは、 値にメタテーブルは設定されていません。
ただし文字列ライブラリは文字列型に対してメタテーブルを設定します
(<a href="#6.4">&sect;6.4</a> を参照)。


<p>
メタテーブルは算術演算、 順序比較、 連結、 長さ演算、
およびインデックス検索に対するオブジェクトの動作をコントロールします。
メタテーブルはユーザーデータまたはテーブルがガベージコレクタに回収される時に呼ばれる関数も定義できます。
値に対してこれらのどれかの操作が実行されると、
その値のメタテーブルに対応するイベントがあるか調べられます。
もしあれば、 そのキーに関連付けられた値 (メタメソッド) が演算の実行をコントロールします。


<p>
メタテーブルは以下の一覧にある演算をコントロールします。
それぞれの演算は対応する名前で区別します。
それぞれの演算に対応するキーは、 その名前の前に 2 つのアンダースコア '<code>__</code>' を付けた文字列です。
例えば、"add" 演算のキーは文字列 "<code>__add</code>" です。


<p>
これらの演算の意味は、 インタプリタが演算をどのように実行するかを示す Lua の関数で説明するのが良いでしょう。
ただし以下の示す Lua で書かれたコードは、 単に説明のためだけのものです。
実際の動作はインタプリタにハードコーディングされており、 ここに示した疑似コードよりも効率的に動作します。
この説明に使われているすべての関数
(<a href="#pdf-rawget"><code>rawget</code></a>、 <a href="#pdf-tonumber"><code>tonumber</code></a> など)
は <a href="#6.1">&sect;6.1</a> に記載されています。
ちなみに、 指定したオブジェクトのメタメソッドを取得するために以下の表現を使っていますが、

<pre>
     metatable(obj)[event]
</pre><p>
これは以下のように読み替えてください。

<pre>
     rawget(getmetatable(obj) or {}, event)
</pre><p>

つまり、 メタメソッドへのアクセスは他のメタメソッドを呼び出さず、
またメタテーブルを持たないオブジェクトにアクセスする場合でもエラーを発生しません
(単純に <b>nil</b> を返します)。


<p>
単項演算子 <code>-</code> および <code>#</code> については、
メタメソッドにはダミーの第 2 引数が渡されます。
この余分の引数は Lua の内部構造を簡単化するためだけのもので、
将来のバージョンでは削除されるかもしれません。
そのため以下のコードでは表していません
(ほとんどの場合この余分の引数は無意味です)。



<ul>

<li><b>"add": </b>
<code>+</code> 演算。



<p>
以下の関数 <code>getbinhandler</code> は、 二項演算子のハンドラがどのように選択されるかを定義しています。
まず第 1 引数を見ます。
その型が演算に対するハンドラを定義していなければ、
第 2 引数を見ます。

<pre>
     function getbinhandler (op1, op2, event)
       return metatable(op1)[event] or metatable(op2)[event]
     end
</pre><p>
この関数を使うことによって、
<code>op1 + op2</code> の演算は以下のように書けます。

<pre>
     function add_event (op1, op2)
       local o1, o2 = tonumber(op1), tonumber(op2)
       if o1 and o2 then  -- 両方の引数が数値か?
         return o1 + o2   -- この '+' はプリミティブの加算
       else  -- 少なくとも片方の引数が数値でない
         local h = getbinhandler(op1, op2, "__add")
         if h then
           -- 両方の引数を渡してハンドラを呼ぶ
           return (h(op1, op2))
         else  -- ハンドラが利用不可能、 デフォルトの動作
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"sub": </b>
<code>-</code> 演算。

"add" 演算と同様の動作。
</li>

<li><b>"mul": </b>
<code>*</code> 演算。

"add" 演算と同様の動作。
</li>

<li><b>"div": </b>
<code>/</code> 演算。

"add" 演算と同様の動作。
</li>

<li><b>"mod": </b>
<code>%</code> 演算。

"add" 演算と同様の動作。
ただしプリミティブの演算は
<code>o1 - floor(o1/o2)*o2</code>
のように行われます。
</li>

<li><b>"pow": </b>
<code>^</code> (累乗) 演算。

"add" 演算と同様の動作。
ただしプリミティブの演算には <code>pow</code> 関数 (C の数学ライブラリ) を用います。
</li>

<li><b>"unm": </b>
単項 <code>-</code> 演算。


<pre>
     function unm_event (op)
       local o = tonumber(op)
       if o then  -- 引数は数値か?
         return -o  -- この '-' はプリミティブの符号反転
       else  -- 引数は数値でない
         -- 引数からハンドラの取得を試みる
         local h = metatable(op).__unm
         if h then
           -- 引数を渡してハンドラを呼ぶ
           return (h(op))
         else  -- ハンドラが利用不可能、 デフォルトの動作
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"concat": </b>
<code>..</code> (連結) 演算。


<pre>
     function concat_event (op1, op2)
       if (type(op1) == "string" or type(op1) == "number") and
          (type(op2) == "string" or type(op2) == "number") then
         return op1 .. op2  -- プリミティブの文字列連結
       else
         local h = getbinhandler(op1, op2, "__concat")
         if h then
           return (h(op1, op2))
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

<li><b>"len": </b>
<code>#</code> 演算。


<pre>
     function len_event (op)
       if type(op) == "string" then
         return strlen(op)      -- プリミティブの文字列の長さ
       else
         local h = metatable(op).__len
         if h then
           return (h(op))       -- 引数を渡してハンドラを呼ぶ
         elseif type(op) == "table" then
           return #op              -- プリミティブのテーブルの長さ
         else  -- ハンドラが利用不可能、 エラー
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
テーブルの長さについての説明は <a href="#3.4.6">&sect;3.4.6</a> を参照してください。
</li>

<li><b>"eq": </b>
<code>==</code> 演算。

関数 <code>getequalhandler</code> は等値比較のメタメソッドがどのように選択されるかを定義しています。
メタメソッドは比較しようとする両方の値が同じ型であり、
その演算に対するメタメソッドが同じであり、
両方の値がテーブルまたはユーザーデータである場合だけ選択されます。

<pre>
     function getequalhandler (op1, op2)
       if type(op1) ~= type(op2) or
          (type(op1) ~= "table" and type(op1) ~= "userdata") then
         return nil     -- 異なる型
       end
       local mm1 = metatable(op1).__eq
       local mm2 = metatable(op2).__eq
       if mm1 == mm2 then return mm1 else return nil end
     end
</pre><p>
"eq" イベントは以下のように定義されます。

<pre>
     function eq_event (op1, op2)
       if op1 == op2 then   -- プリミティブの等価比較
         return true   -- 値は等しい
       end
       -- メタメソッドを試みる
       local h = getequalhandler(op1, op2)
       if h then
         return not not h(op1, op2)
       else
         return false
       end
     end
</pre><p>
ちなみに結果は常にブーリアンです。
</li>

<li><b>"lt": </b>
<code>&lt;</code> 演算。


<pre>
     function lt_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt; op2   -- 数値の比較
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt; op2   -- 辞書順の比較
       else
         local h = getbinhandler(op1, op2, "__lt")
         if h then
           return not not h(op1, op2)
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
ちなみに結果は常にブーリアンです。
</li>

<li><b>"le": </b>
<code>&lt;=</code> 演算。


<pre>
     function le_event (op1, op2)
       if type(op1) == "number" and type(op2) == "number" then
         return op1 &lt;= op2   -- 数値の比較
       elseif type(op1) == "string" and type(op2) == "string" then
         return op1 &lt;= op2   -- 辞書順の比較
       else
         local h = getbinhandler(op1, op2, "__le")
         if h then
           return not not h(op1, op2)
         else
           h = getbinhandler(op1, op2, "__lt")
           if h then
             return not h(op2, op1)
           else
             error(&middot;&middot;&middot;)
           end
         end
       end
     end
</pre><p>
"le" メタメソッドが無い場合は、
<code>a &lt;= b</code> と <code>not (b &lt; a)</code> が同等であると仮定して
"lt" が呼ばれることに注意してください。


<p>
他の比較演算子と同じく、結果は常にブーリアンです。
</li>

<li><b>"index": </b>
インデックスアクセス <code>table[key]</code>。
メタメソッドは <code>table</code> に <code>key</code> が存在しない場合だけ呼ばれることに注意してください。
(<code>table</code> がテーブルでない場合は、
キーは決して存在しないため、
常にメタメソッドが呼ばれます。)


<pre>
     function gettable_event (table, key)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         -- キーが存在する場合は、 その生の値を返す
         if v ~= nil then return v end
         h = metatable(table).__index
         if h == nil then return nil end
       else
         h = metatable(table).__index
         if h == nil then
           error(&middot;&middot;&middot;)
         end
       end
       if type(h) == "function" then
         return (h(table, key))     -- ハンドラを呼び出す
       else return h[key]           -- または演算を繰り返す
       end
     end
</pre><p>
</li>

<li><b>"newindex": </b>
インデックス付き代入 <code>table[key] = value</code>。
メタメソッドは <code>table</code> に <code>key</code> が存在しない場合だけ呼ばれることに注意してください。


<pre>
     function settable_event (table, key, value)
       local h
       if type(table) == "table" then
         local v = rawget(table, key)
         -- キーが存在する場合は、 生の代入を行う
         if v ~= nil then rawset(table, key, value); return end
         h = metatable(table).__newindex
         if h == nil then rawset(table, key, value); return end
       else
         h = metatable(table).__newindex
         if h == nil then
           error(&middot;&middot;&middot;)
         end
       end
       if type(h) == "function" then
         h(table, key,value)           -- ハンドラを呼び出す
       else h[key] = value             -- または演算を繰り返す
       end
     end
</pre><p>
</li>

<li><b>"call": </b>
値が呼ばれたときに呼ばれます。


<pre>
     function function_event (func, ...)
       if type(func) == "function" then
         return func(...)   -- プリミティブの call
       else
         local h = metatable(func).__call
         if h then
           return h(func, ...)
         else
           error(&middot;&middot;&middot;)
         end
       end
     end
</pre><p>
</li>

</ul>




<h2>2.5 &ndash; <a name="2.5">ガベージコレクション</a></h2>

<p>
Lua は自動メモリ管理を行います。
つまり、
新しいオブジェクトのためにメモリを確保したり、
オブジェクトを使わなくなったときに解放したりすることについて、 悩まなくていいということです。
すべての <em>死んだオブジェクト</em>
(もう Lua からアクセスできなくなったオブジェクト)
を回収する <em>ガベージコレクタ</em> によって、 自動的にメモリを管理します。
テーブル、 ユーザーデータ、 関数、 スレッド、 文字列、 内部構造体などの Lua で使われるメモリはすべて、
自動管理の対象です。




<p>
Lua ではインクリメンタルマークアンドスイープコレクタが実装されています。
ガベージコレクションのサイクルを制御するために
<em>ガベージコレクタ停止期間</em>
および
<em>ガベージコレクタステップ係数</em>
の 2 つの数値が使われます。
両方とも単位はパーセントです
(つまり 100 の値が内部的な 1 を意味します)。


<p>
ガベージコレクタ停止期間は
新しいサイクルを開始するまでに待つ時間の長さをコントロールします。
大きな値を指定するほどコレクタは消極的になります。
100 より小さな値を指定するとコレクタはすぐに新しいサイクルを開始します。
200 を指定すると 2 倍の合計メモリが使われるまで新しいサイクルを開始しません。


<p>
ガベージコレクタステップ係数は
メモリ割り当てに対するコレクタの動作速度をコントロールします。
大きな値を指定するほどコレクタは積極的になりますが、
各インクリメンタルステップのサイズも増加します。
100 より小さな値を指定するとコレクタが非常に遅くなり、 コレクタのサイクルが終わらなくなる場合があります。
デフォルトは 200 です。
これはメモリ割り当ての「2倍」の速度でコレクタが走ることになります。


<p>
ステップ係数を非常に大きな数
(プログラムが使う可能性のあるバイト数の最大値より 10% 以上大きな数)
にすると、 コレクタはストップザワールドコレクタのように動作します。
さらに停止期間を 200 にすると、
コレクタは毎回の完全なコレクションごとにメモリ使用量を 2 倍にする、
前のバージョンの Lua と同じような動作になります。


<p>
これらの数値を変更するには、
C で <a href="#lua_gc"><code>lua_gc</code></a> を呼ぶか、
Lua で <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> を呼びます。
またこれらの関数を使うと、 コレクタを直接コントロール (停止したり再開したり) することもできます。


<p>
Lua 5.2 における実験的な機能として、
コレクタの動作モードをインクリメンタルから <em>世代別</em> に変更できます。
<em>世代別コレクタ</em> はほとんどのオブジェクトが若くして死ぬと仮定し、
そのため若い (最近作られた) オブジェクトのみを巡回します。
この動作はコレクタが使う時間を減らしますが、
(年老いて死んだオブジェクトが溜まる可能性があるため) メモリ使用量は増えます。
2 つめの問題を軽減するため、世代別コレクタは時々フルコレクションを行います。
これは実験的な機能であることを忘れないでください。
大いに試して頂いて構いませんが、
実際に効果があったか確認するようにしてください。


<h3>2.5.1 &ndash; <a name="2.5.1">ガベージコレクションメタメソッド</a></h3>

<p>
テーブルにガベージコレクタメタメソッドを設定することができます。
また C の API を使えば、 フルユーザーデータ (<a href="#2.4">&sect;2.4</a> を参照) にも設定することができます。
このメタメソッドは <em>ファイナライザ</em> とも呼ばれます。
ファイナライザを使うと、 外部リソースの管理
(ファイルやネットワーク接続、 データベース接続を閉じたり、 独自に確保したメモリを解放するなど)
を Lua のガベージコレクションと組み合わせることができます。


<p>
オブジェクト (テーブルまたはユーザーデータ) を回収時にファイナライズするためには、
それをファイナライズ用に <em>マーク</em> しなければなりません。

オブジェクトにメタテーブルを設定したとき、
そのメタテーブルが文字列 "<code>__gc</code>" のフィールドを持っていれば、
そのオブジェクトはファイナライズ用にマークされます。
もし設定時にメタテーブルが <code>__gc</code> フィールドを持っていなければ、
後でそのメタテーブルにそのフィールドを追加しても、
そのオブジェクトはファイナライズ用にマークされません。
しかし、 オブジェクトがいったんマークされた後でなら、
メタテーブルの <code>__gc</code> フィールドは自由に変更できます。


<p>
マークしたオブジェクトがガベージになっても、
ガベージコレクタはすぐにはそれを回収しません。
代わりにそれはリストに格納されます。
ガベージコレクションが終わった後、
そのリスト中の各オブジェクトについて、 以下の関数と同等のことが行われます。

<pre>
     function gc_event (obj)
       local h = metatable(obj).__gc
       if type(h) == "function" then
         h(obj)
       end
     end
</pre>

<p>
各ガベージコレクションサイクルの終わりに、
そのサイクルで回収されたオブジェクトに対して、
ファイナライズ用にマークしたのと逆の順序で、
各オブジェクトに対するファイナライザが呼ばれます。
つまり、 プログラム中で最後にマークされたオブジェクトに対するものが、
最初に呼ばれるファイナライザになります。
ファイナライザの呼び出しは、 通常コードの実行中に任意の時点で行われます。


<p>
回収されたオブジェクト (およびそのオブジェクトを通してアクセス可能なオブジェクト) は、
まだファイナライザによって使われるため、
Lua によって <em>蘇生</em> されます。
通常、この蘇生は短期的なものであり、
そのオブジェクトのメモリは次のガベージコレクションサイクルで解放されます。
しかし、ファイナライザがそのオブジェクトをなんらかのグローバルな場所
(グローバル変数など) に格納すると、
永続的な蘇生になります。
いずれにせよ、
オブジェクトのメモリは完全にアクセスできなくなった場合に限り解放されます。
またファイナライザは 2 回以上は呼ばれません。





<h3>2.5.2 &ndash; <a name="2.5.2">弱参照テーブル</a></h3>

<p>
<em>弱参照テーブル</em> は要素が <em>弱参照</em> であるテーブルです。
弱参照はガベージコレクタに無視されます。
言い換えると、
オブジェクトへの参照が弱参照だけになった場合、
ガベージコレクタはそのオブジェクトを回収します。


<p>
弱参照テーブルは、 弱参照のキー、 弱参照の値、 またはその両方を持つことができます。
弱参照キーを持つテーブルは、 キーは回収されますが、 値は回収されません。
弱参照キーと弱参照値の両方を持つテーブルは、 キーと値の両方が回収されます。
どの場合でも、 キーか値のいずれかが回収されれば、 そのペア全体がテーブルから取り除かれます。
テーブルの弱参照の性質はメタテーブルの <code>__mode</code> フィールドでコントロールします。
<code>__mode</code> フィールドが文字列で、 文字 '<code>k</code>' が含まれていれば、
そのテーブルはキーが弱参照になります。
<code>__mode</code> フィールドに '<code>v</code>' が含まれていれば、
そのテーブルは値が弱参照になります。


<p>
弱参照のキーと <em>強参照</em> の値を持つテーブルは、
<em>短命テーブル</em> と呼ばれます。
短命テーブルでは、 キーが到達可能な場合だけ、 値が到達可能です。
具体的に言うと、
キーが値を通してのみ参照可能な場合は、
そのペアは削除されます。


<p>
テーブルの弱参照性の変更は、 次のコレクションサイクル以降に限り効果を発揮する可能性があります。
特に、弱参照モードから強参照モードに変更する場合、
変更が効果を発揮するまでの間に、
そのテーブルからいくつかの要素が回収されてしまう場合があります。


<p>
明示的に生成するタイプのオブジェクトのみが弱参照テーブルから削除されます。
数値や軽量 C 関数のようなオブジェクトはガベージコレクションの対象ではなく、
そのため弱参照テーブルから削除されません
(対応する側の値が回収された場合を除く)。
文字列はガベージコレクションの対象ですが、
明示的に生成するものではないため、
弱参照テーブルから削除されません。


<p>
蘇生したオブジェクト
(つまりファイナライズされたオブジェクト、
およびファイナライズされたオブジェクトを通してのみアクセス可能なオブジェクト)
は弱参照テーブルでは特殊な動作をします。
これらの弱参照の値はファイナライザ実行前に削除されますが、
弱参照のキーである場合はファイナライザ実行後の次のコレクションサイクル
(実際にオブジェクトが解放される前)
のときに削除されます。
この動作は、
弱参照テーブルによってそのオブジェクトに関連付けられたプロパティに、
ファイナライザからアクセスできるようにするためのものです。


<p>
弱参照テーブル自身が蘇生オブジェクトである場合は、
次のコレクションサイクルまで適切にクリアされない場合があります。







<h2>2.6 &ndash; <a name="2.6">コルーチン</a></h2>

<p>
Lua ではコルーチンがサポートされています。
<em>協調的マルチスレッド</em> とも呼ばれます。
Lua のコルーチンは独立した実行のスレッドを表します。
マルチスレッドシステムのスレッドとは異なり、
コルーチンは yield 関数を明示的に呼ぶことによってのみ実行が中断されます。


<p>
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a> を呼ぶとコルーチンを作成できます。
その唯一の引数にはコルーチンのメイン関数を指定します。
この <code>create</code> 関数は、
新しいコルーチンを作成し、 そのハンドル
(<em>スレッド</em> 型のオブジェクト)
を返すだけで、 コルーチンの実行は開始しません。


<p>
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> を呼ぶと、
コルーチンを実行できます。
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
から返されたスレッドを最初の引数にして、 1 回目の
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
を呼ぶと、
コルーチンはそのメイン関数の最初の行から実行を開始します。
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
に追加の引数を渡すと、 それらはコルーチンのメイン関数に渡されます。
コルーチンが実行を開始すると、
それが終了するか <em>yield</em> を呼ぶまで実行を続けます。


<p>
コルーチンの実行終了には 2 種類あります。
メイン関数から
(明示的に、 または最後の命令が終わって暗黙に)
return した場合の通常終了と、
保護されないエラーが発生した場合の異常終了です。
正常終了の場合、
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
は <b>true</b> とコルーチンのメイン関数からの戻り値を返します。
エラーの場合、
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
は <b>false</b> とエラーメッセージを返します。


<p>
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
を呼ぶと、 コルーチンは中断されます。
コルーチンが中断されると、 対応する
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
から直ちに戻ります。
たとえ中断がネストした関数呼び出しの中
(つまりメイン関数ではなく、 メイン関数から直接または間接的に呼ばれた別の関数の中)
で起きた場合でも、 同様です。
中断した場合、
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
は <b>true</b> と
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
に渡された引数を返します。
同じコルーチンをもう一度 resume すると、
コルーチンは中断した地点から実行を継続します。
そのとき
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
は
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
に渡された追加の引数を返します。


<p>
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
と同様に、
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
関数もコルーチンを作成します。
ただしコルーチン自身を返すのではなく、
呼ばれるとコルーチンを再開する関数を代わりに返します。
この関数に渡した引数はすべて
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
に追加の引数として渡されます。
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
は
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
から返された戻り値を、 最初の引数 (ブーリアンのエラーコード) を除いてすべて返します。
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
と異なり、
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
はエラーをキャッチしません。
エラーは呼び出し元に伝搬されます。


<p>
コルーチンがどのように動作するかの例として、
以下のコードを見てください。

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end

     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)

     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
これを実行すると、 以下のように出力されます。

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
また C の API を使ってコルーチンを作成したり操作することもできます。
<a href="#lua_newthread"><code>lua_newthread</code></a> 関数、
<a href="#lua_resume"><code>lua_resume</code></a> 関数、 および
<a href="#lua_yield"><code>lua_yield</code></a> 関数を参照してください。





<h1>3 &ndash; <a name="3">言語</a></h1>

<p>
このセクションでは、 Lua の字句、 構文、 意味論を説明します。
言い換えると、
このセクションでは、 どのようなトークンが有効か、 それらはどのように組み合わせられるのか、
またその組み合わせは何を意味するのかについて説明します。


<p>
言語構造は一般的な拡張 BNF 記法を使って説明します。
つまり、
{<em>a</em>} は <em>a</em> の 0 回以上の繰り返しを表し、
[<em>a</em>] は <em>a</em> が省略可能であることを表します。
非終端記号は non-terminal のように書き、
キーワードは <b>kword</b> のように書き、
他の終端記号は &lsquo;<b>=</b>&rsquo; のように書きます。
Lua の完全な構文はこのマニュアルの最後、 <a href="#9">&sect;9</a> に載っています。



<h2>3.1 &ndash; <a name="3.1">字句構造</a></h2>

<p>
Lua はフリーフォーマットの言語です。
名前とキーワード間のデリミタを除き、
字句要素 (トークン) 間の空白 (改行を含む) やコメントは無視されます。


<p>
Lua における <em>名前</em>
(<em>識別子</em> とも呼ばれる)
は、 文字、 数字、 アンダースコアを組み合わせた文字列です。
ただし数字で始まってはなりません。
識別子は変数やテーブルフィールド、 ラベルに名前を付けるために使われます。


<p>
以下の <em>キーワード</em> は予約されており、 名前としては使えません。


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Lua は大文字小文字を区別する言語です。
<code>and</code> は予約語ですが、 <code>And</code> と <code>AND</code> は、 2 つの異なった、 有効な名前です。
慣例により、 アンダースコアと大文字で始まる名前
(例えば <a href="#pdf-_VERSION"><code>_VERSION</code></a>)
は、 Lua 自身が使用する変数として予約されています。


<p>
以下の文字列はその他のトークンです。

<pre>
     +     -     *     /     %     ^     #
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>文字列リテラル</em> は、 対応するシングルクォートまたはダブルクォートによって区切られ、
以下に示す C のようなエスケープシーケンスを使うことができます。
<ul>
<li>'<code>\a</code>' ... ベル
<li>'<code>\b</code>' ... バックスペース
<li>'<code>\f</code>' ... 改頁
<li>'<code>\n</code>' ... 改行
<li>'<code>\r</code>' ... 復帰
<li>'<code>\t</code>' ... 水平タブ
<li>'<code>\v</code>' ... 垂直タブ
<li>'<code>\\</code>' ... バックスラッシュ (円記号)
<li>'<code>\"</code>' ... 引用符 (ダブルクォート)
<li>'<code>\'</code>' ... アポストロフィ (シングルクォート)
</ul>
<p>
バックスラッシュに本物の改行が続いたものは、 文字列中で改行になります。
<p>
エスケープシーケンス '<code>\z</code>' は、 後続のホワイトスペース (改行も含む) をスキップします。
文字列中に改行や空白を追加せずに、 複数行に渡る長い文字列を分割したりインデントしたりしたいときに、 特に便利でしょう。


<p>
リテラル文字列中のバイトは、 その数値で指定することもできます。
これにはエスケープシーケンス <code>\x<em>XX</em></code> または <code>\<em>ddd</em></code> を使います。
<em>XX</em> はぴったり 2 桁の 16 進数で、
<em>ddd</em> は最大 3 桁の 10 進数です。
(10 進数のエスケープシーケンスの直後に数字が続くときは、
ぴったり 3 桁を使わなければならないことに注意してください。)
Lua の文字列には任意の 8 ビット値を入れることができます。
'<code>\0</code>' で表される埋め込まれたゼロも入れることができます。


<p>
リテラル文字列は、 <em>長括弧</em> によって囲まれた長い形式を使って定義することもできます。
開き角括弧に <em>n</em> 個のイコール記号が続き、 さらに開き角括弧が続いたものを、
<em><em>n</em> 段の開き長括弧</em> と言います。
つまり、 0 段の開き長括弧は <code>[[</code> と書き、 1 段の開き長括弧は <code>[=[</code> と書き、 以下同様です。
<em>閉じ長括弧</em> も同様です。
例えば、 4 段の閉じ長括弧は、 <code>]====]</code> と書きます。
任意の段数の開き長括弧で始まる長い文字列は、 最初に現れた同じ段数の閉じ長括弧で終わります。
つまり正しい段数の閉じ長括弧を除く、 任意のテキストを入れることができます。
この長括弧形式のリテラルは複数行にわたって書くこともできます。
エスケープシーケンスは解釈されず、 異なる段数の長括弧も無視されます。
いかなる種類の改行シーケンス (復帰、改行、復帰+改行、改行+復帰) も、 単純な改行に変換されます。


<p>
ソース文字列の解析において、
上記のルールに明示的な影響のないリテラル文字列内のあらゆるバイトは、 それ自身を表現します。
しかしながら、 解析時はテキストモードでファイルを開くので、
いくつかの制御文字について、 システムのファイル関数が、 何らかの問題を起こす可能性があります。
そのため、 テキスト以外のデータは、
明示的に非テキスト文字用のエスケープシーケンスを使って、
引用符を用いたリテラルとして表現する方が安全です。


<p>
便利なように、 開き長括弧の直後に改行が続く場合は、 その改行は文字列に含まれません。
例えば、 ASCII コード
('<code>a</code>' が 97 で、 改行が 10 で、'<code>1</code>' が 49)
を使っているシステムでは、 以下の 5 つのリテラル文字列は同じ文字列を表現しています。

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
<em>数値定数</em> は、 省略可能な小数部と省略可能な 10 進指数を書くことができます。
10 進指数は文字 '<code>e</code>' または '<code>E</code>' で示します。
<code>0x</code> または <code>0X</code> で始まる 16 進数定数も受け付けます。
16 進定数も、 省略可能な小数部と、 さらに省略可能な 2 進指数を受け付けます。
2 進指数は '<code>p</code>' または '<code>P</code>' で示します。
有効な数値定数の例を以下に挙げます。

<pre>
     3     3.0     3.1416     314.16e-2     0.31416E1
     0xff  0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
<em>コメント</em> は二重のハイフン (<code>--</code>) で始まります (ただし文字列中を除く)。
<code>--</code> の直後のテキストが開き長括弧でなければ、
そのコメントは <em>短いコメント</em> で、 行の終わりまで続きます。
そうでなければ、 それは <em>長いコメント</em> で、 対応する閉じ長括弧まで続きます。
長いコメントはしばしばコードを一時的に無効化するために使われます。





<h2>3.2 &ndash; <a name="3.2">変数</a></h2>

<p>
変数は値を格納する場所です。
Lua にはグローバル変数、 ローカル変数およびテーブルフィールドの 3 種類の変数があります。


<p>
単一の名前はグローバル変数かローカル変数を表します
(または関数の仮引数かもしれませんが、 それはローカル変数の一種です)。

<pre>
	var ::= Name
</pre><p>
<a href="#3.1">&sect;3.1</a> で定義したように、 名前は識別子を表します。


<p>
明示的にローカルとして宣言されない限り、 変数名はグローバルと見なされます
(<a href="#3.3.7">&sect;3.3.7</a> を参照)。
ローカル変数は <em>レキシカルスコープ</em> を持ちます。
つまり、 ローカル変数はそのスコープ内部で定義された関数から自由にアクセスできます
(<a href="#3.5">&sect;3.5</a> を参照)。


<p>
最初に代入される前の変数の値は <b>nil</b> です。


<p>
角括弧はテーブルをインデックス検索するために使います。

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
テーブルフィールドにアクセスすることの意味はメタテーブルで変えることができます。
インデックス付き変数 <code>t[i]</code> へのアクセスは、 <code>gettable_event(t,i)</code> の呼び出しと同等です。
(<code>gettable_event</code> 関数の完全な説明は <a href="#2.4">&sect;2.4</a> を参照してください。
この関数は Lua の中では定義されておらず、 呼び出すことはできません。
ここで説明するためだけに用いています。)


<p>
構文 <code>var.Name</code> は <code>var["Name"]</code> の単なるシンタックスシュガーです。

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
グローバル変数 <code>x</code> へのアクセスは <code>_ENV.x</code> と同等です。
チャンクのコンパイル方法から来る理由により、
<code>_ENV</code> はグローバル変数にはなれません
(<a href="#2.2">&sect;2.2</a> を参照)。





<h2>3.3 &ndash; <a name="3.3">文</a></h2>

<p>
Lua には Pascal や C と同様の一般的な文が一通りあります。
具体的には代入、 制御構造、 関数呼び出し、 変数宣言などがあります。



<h3>3.3.1 &ndash; <a name="3.3.1">ブロック</a></h3>

<p>
ブロックは、 順番に実行される文のリストです。

<pre>
	block ::= {stat}
</pre><p>
Lua には <em>空文</em> があるので、
文を複数のセミコロンで区切ったり、 セミコロンでブロックを開始したり、
シーケンス中に 2 つのセミコロンを書いたりできます。

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
ブロックは明示的に区切って単一の文とすることができます。

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
明示的なブロックは、 変数宣言のスコープをコントロールするのに便利です。
明示的なブロックはまた、 ブロックの途中に <b>return</b> 文を入れるために使うこともあります
(<a href="#3.3.4">&sect;3.3.4</a> を参照)。





<h3>3.3.2 &ndash; <a name="3.3.2">チャンク</a></h3>

<p>
Lua の実行の単位は <em>チャンク</em> と呼ばれます。
構文的には、 チャンクは単にブロックです。

<pre>
	chunk ::= block
</pre>

<p>
チャンクは可変長引数を持つ匿名関数の本体として扱われます
(<a href="#3.4.10">&sect;3.4.10</a> を参照)。
つまり、 チャンクはローカル変数を定義したり、 引数を受け取ったり、 戻り値を返したりすることができます。
さらに、 そのような匿名関数は、
<code>_ENV</code> と呼ばれる外部ローカル変数のスコープ内にいるかのようにコンパイルされます
(<a href="#2.2">&sect;2.2</a> を参照)。
結果として得られる関数は、 例え使わなくても、
常に唯一の上位値として <code>_ENV</code> を持ちます。


<p>
チャンクはファイルやホストプログラム内の文字列に格納しておくことができます。
チャンクを実行するときは、 まずそのチャンクが仮想マシンの命令列にコンパイルされ、
そしてコンパイルされたコードが仮想マシンのインタプリタによって実行されます。


<p>
チャンクはバイナリ形式に事前コンパイルしておくこともできます。
詳細は <code>luac</code> を参照してください。
ソース形式のプログラムとコンパイル済み形式はどちらを使っても構いません。
ファイル形式は自動的に判定され、 適切に動作します。






<h3>3.3.3 &ndash; <a name="3.3.3">代入</a></h3>

<p>
Lua では多重代入が行えます。
そのため、 代入の構文は左辺に変数のリストがあり、 右辺に式のリストがあります。
両方ともリストの要素はカンマで区切ります。

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
式は <a href="#3.4">&sect;3.4</a> で説明しています。


<p>
代入を行う前に、
値のリストは変数リストの長さに <em>調節</em> されます。
必要とされるよりも値の方が多ければ、 余分な値は捨てられます。
必要とされるよりも値の方が少なければ、 必要なだけ <b>nil</b> が追加されます。
式リストが関数呼び出しで終わっている場合は、 調節の前にその呼び出しから返されたすべての値がリストに入れられます
(その呼び出しが括弧で囲まれている場合を除きます。 <a href="#3.4">&sect;3.4</a> を参照)。


<p>
代入文はまずすべての式を評価し、 それから代入を行います。
そのため以下のコードは

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
<code>a[3]</code> を 20 にセットし、 <code>a[4]</code> には影響を与えません。
<code>a[i]</code> の <code>i</code> は、 4 が代入される前に (3 に) 評価されるためです。
同様に、 以下の文は

<pre>
     x, y = y, x
</pre><p>
<code>x</code> と <code>y</code> の値を交換し、 以下の文は

<pre>
     x, y, z = y, z, x
</pre><p>
<code>x</code>、 <code>y</code>、 <code>z</code> の値を巡回置換します。


<p>
グローバル変数とテーブルフィールドへの代入の意味は、 メタテーブルによって変更できます。
インデックス付き変数への代入 <code>t[i] = val</code> は <code>settable_event(t,i,val)</code> と同等です。
(<code>settable_event</code> 関数の完全な説明は <a href="#2.4">&sect;2.4</a> を参照してください。
この関数は Lua の中では定義されておらず、 呼び出すことはできません。
ここで説明するためだけに用いています。)


<p>
グローバル変数への代入 <code>x = val</code> は、 代入 <code>_ENV.x = val</code> と同等です
(<a href="#2.2">&sect;2.2</a> を参照)。





<h3>3.3.4 &ndash; <a name="3.3.4">制御構造</a></h3>
<p>
制御構造 <b>if</b>、 <b>while</b> および <b>repeat</b> は、 一般的な意味とお馴染みの構文を持っています。




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
また 2 種類の <b>for</b> 文もあります (<a href="#3.3.5">&sect;3.3.5</a> を参照)。


<p>
制御構造の条件式は任意の値を返すことができます。
<b>false</b> と <b>nil</b> は両方とも偽とみなされます。
<b>nil</b> と <b>false</b> 以外のすべての値は真とみなされます
(例えば数値の 0 や空文字列も真です)。


<p>
<b>repeat</b>&ndash;<b>until</b> ループでは、
内部のブロックは <b>until</b> キーワードではなく、 条件式の後で終わります。
そのため、 条件式からループブロックの内部で宣言されたローカル変数を参照できます。


<p>
<b>goto</b> 文はプログラムの制御をラベルに移動する文です。
構文的な理由で、 Lua ではラベルも文とみなされます。



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
ラベルはそれが定義されたブロック全体において可視です。
ただし、 同じ名前のラベルが定義されたネストしたブロックの内部や、 ネストした関数の内部は、 除きます。
goto は、 ローカル変数のスコープの中へ入らない限り、 可視なラベルのどれにでもジャンプできます。


<p>
ラベルと空文はどちらも <em>無の文</em> と呼ばれます。
何のアクションも実行しないという意味です。


<p>
<b>break</b> 文は、
後続の文を <b>while</b>、 <b>repeat</b> または <b>for</b> ループが終わるまでスキップし、
そのループの実行を終了します。


<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b> はそれを囲んでいる最も内側のループを終了します。


<p>
<b>return</b> 文は関数やチャンク (チャンクは関数が姿を変えたものです) から値を返すために使います。

関数は 2 つ以上の値を返すこともできます。
そのため <b>return</b> 文の構文は以下のようになっています。

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
<b>return</b> 文はブロックの最後の文としてのみ書くことができます。
ブロックの途中で <b>return</b> することが本当に必要なら、 明示的な内部ブロックを使うことができます。
つまり <code>do return end</code> という慣用句を使えば、 <b>return</b> は (内部) ブロックの最後の文となります。





<h3>3.3.5 &ndash; <a name="3.3.5">for 文</a></h3>

<p>

<b>for</b> 文には数値用と汎用の 2 種類の形式があります。


<p>
数値用の <b>for</b> ループは、 制御変数が等差数列を辿りながらコードブロックを繰り返します。
以下のような構文を使います。

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
<em>name</em> が最初の <em>exp</em> で始まり、 二番目の <em>exp</em> に達するまで、 三番目の <em>exp</em> ずつ増えながら、 <em>block</em> を繰り返します。
より正確に言うと、 以下のような <b>for</b> 文は

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
以下のコードと同等です。

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       while (<em>step</em> &gt; 0 and <em>var</em> &lt;= <em>limit</em>) or (<em>step</em> &lt;= 0 and <em>var</em> &gt;= <em>limit</em>) do
         local v = <em>var</em>
         <em>block</em>
         <em>var</em> = <em>var</em> + <em>step</em>
       end
     end
</pre><p>
注意点を以下に示します。

<ul>

<li>
3 つの制御式はすべて、 ループを開始する前に一度だけ評価されます。
これらはすべて数値でなければなりません。
</li>

<li>
<code><em>var</em></code>、 <code><em>limit</em></code> および <code><em>step</em></code> は見えない変数です。
ここで示した名前は説明のためだけのものです。
</li>

<li>
三番目の式 (step) が無い場合は、 1 が使われます。
</li>

<li>
<b>for</b> ループを抜けるために <b>break</b> を使うことができます。
</li>

<li>
ループ変数 <code>v</code> はループにローカルです。
<b>for</b> の終了後または break 後にその値を使うことはできません。
もしこの値が必要なら、 ループを break または終了する前に他の変数に代入しておいてください。
</li>

</ul>

<p>
汎用 <b>for</b> 文は <em>イテレータ</em> と呼ばれる関数を用いて動作します。
繰り返しのたびに、 新しい値を生成するためにイテレータ関数が呼ばれます。
この新しい値が <b>nil</b> になると繰り返しは停止します。
汎用 <b>for</b> ループは以下のような構文です。

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
以下のような <b>for</b> 文は

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
以下のコードと同等です。

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
注意点を以下に挙げます。

<ul>

<li>
<code><em>explist</em></code> は一度だけ評価されます。
その結果は <em>イテレータ</em> 関数、 <em>状態</em>、 そして最初の <em>イテレータ変数</em> の初期値です。
</li>

<li>
<code><em>f</em></code>、 <code><em>s</em></code> および <code><em>var</em></code> は見えない変数です。
ここで示した名前は説明のためだけのものです。
</li>

<li>
<b>for</b> ループを抜けるために <b>break</b> を使うことができます。
</li>

<li>
ループ変数 <code><em>var_i</em></code> はループにローカルです。
<b>for</b> の終了後に使うことはできません。
もしこの値が必要なら、 ループを break または終了する前に他の変数に代入しておいてください。
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">文としての関数呼び出し</a></h3>
<p>
副作用目的で、 関数呼び出しを文として実行することができます。

<pre>
	stat ::= functioncall
</pre><p>
この場合、 すべての戻り値は捨てられます。
関数呼び出しは <a href="#3.4.9">&sect;3.4.9</a> で説明しています。





<h3>3.3.7 &ndash; <a name="3.3.7">ローカル宣言</a></h3>
<p>
ローカル変数はブロック内のどこでも宣言できます。
初期値を代入することもできます。

<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
初期値の代入は多重代入と同じ意味論を持ちます (<a href="#3.3.3">&sect;3.3.3</a> を参照)。
初期値がなければ、 すべての変数は <b>nil</b> で初期化されます。


<p>
チャンクもまたブロックであるため (<a href="#3.3.2">&sect;3.3.2</a> を参照)、
明示的なブロックの外側のチャンクでもローカル変数を宣言することができます。


<p>
ローカル変数の可視性ルールは <a href="#3.5">&sect;3.5</a> で説明しています。







<h2>3.4 &ndash; <a name="3.4">式</a></h2>

<p>
Lua には以下のような基本的な式があります。

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Number
	exp ::= String
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
数値およびリテラル文字列は <a href="#3.1">&sect;3.1</a> で説明しています。
変数は <a href="#3.2">&sect;3.2</a> で説明しています。
関数定義は <a href="#3.4.10">&sect;3.4.10</a> で説明しています。
関数呼び出しは <a href="#3.4.9">&sect;3.4.9</a> で説明しています。
テーブルコンストラクタは <a href="#3.4.8">&sect;3.4.8</a> で説明しています。
3 つのドット ('<code>...</code>') で表される可変長引数式は可変長引数関数の内部でだけ直接使えます。
これは <a href="#3.4.10">&sect;3.4.10</a> で説明しています。


<p>
二項演算子には算術演算子 (<a href="#3.4.1">&sect;3.4.1</a> を参照)、
関係演算子 (<a href="#3.4.3">&sect;3.4.3</a> を参照)、
論理演算子 (<a href="#3.4.4">&sect;3.4.4</a> を参照)、
および連結演算子 (<a href="#3.4.5">&sect;3.4.5</a> を参照) があります。
単項演算子には単項マイナス (<a href="#3.4.1">&sect;3.4.1</a> を参照)、
単項 <b>not</b> (<a href="#3.4.4">&sect;3.4.4</a> を参照)、
および単項 <em>長さ演算子</em> (<a href="#3.4.6">&sect;3.4.6</a> を参照) があります。


<p>
関数呼び出しと可変長引数式は共に複数の値を返す場合があります。
関数呼び出しが文として使われる場合 (<a href="#3.3.6">&sect;3.3.6</a> を参照) は、
戻り値のリストがゼロ個に調節され、 つまりすべての戻り値が捨てられます。
式が式リストの最後の (または唯一の) 要素として使われている場合は、
調節は行われません (ただし式が括弧で囲まれている場合を除きます)。
それ以外のすべての場合では、 戻り値のリストは 1 個の要素に調節され、 その 1 個以外のすべての値は捨てられます。


<p>
いくつか例を挙げます。

<pre>
     f()                -- 戻り値は 0 個に調節される
     g(f(), x)          -- f() の戻り値は 1 個に調節される
     g(x, f())          -- g は x と f() のすべての戻り値を受け取る
     a,b,c = f(), x     -- f() の戻り値は 1 個に調節される(c は nil を受け取る)
     a,b = ...          -- a は可変長引数の最初の値を受け取り、
                        -- b は 2 番目の値を受け取る (もし対応する可変長引数の値が
                        -- なければ、 a も b も nil になるかもしれない)

     a,b,c = x, f()     -- f() の戻り値は 2 個に調節される
     a,b,c = f()        -- f() の戻り値は 3 個に調節される
     return f()         -- f() のすべての戻り値を返す
     return ...         -- 受け取った可変長引数の値をすべて返す
     return x,y,f()     -- x、 y および f() のすべての戻り値を返す
     {f()}              -- f() のすべての戻り値からなるリストを作る
     {...}              -- 可変長引数のすべての値からなるリストを作る
     {f(), nil}         -- f() は 1 個の戻り値に調節される
</pre>

<p>
括弧で囲まれた式は常に 1 個の結果を返します。
そのため、 <code>f</code> が複数の値を返す場合でも、 <code>(f(x,y,z))</code> は常に 1 個の値になります。
(<code>(f(x,y,z))</code> の値は <code>f</code> が返した最初の戻り値になります。
<code>f</code> が何も返さなかった場合は <code>nil</code> になります。)



<h3>3.4.1 &ndash; <a name="3.4.1">算術演算子</a></h3>
<p>
Lua には以下ような一般的な算術演算子があります。
<ul>
<li><code>+</code> (加算)
<li><code>-</code> (減算)
<li><code>*</code> (乗算)
<li><code>/</code> (除算)
<li><code>%</code> (剰余)
<li><code>^</code> (累乗)
<li>単項の <code>-</code> (符号反転)
</ul>
<p>
引数が数値か、 数値に変換できる文字列 (<a href="#3.4.2">&sect;3.4.2</a> を参照) であれば、
すべての演算は一般的な意味を持ちます。
累乗は任意の指数に対して使えます。
例えば <code>x^(-0.5)</code> は <code>x</code> の平方根の逆数を計算します。
剰余は以下のように定義されます。

<pre>
     a % b == a - math.floor(a/b)*b
</pre><p>
つまり、 商を負の無限大に向かって丸めた除算の余りです。





<h3>3.4.2 &ndash; <a name="3.4.2">強制型変換</a></h3>

<p>
文字列と数値は実行時に自動的に変換されます。
文字列に対して算術演算が適用されると、 その文字列を Lua の字句解析のルールに沿って数値に変換しようと試みます。
(文字列には前後の空白や符号があっても構いません。)
逆に、 文字列が期待されるところで数値が使われると、 その数値は適当な形式で文字列に変換されます。
数値を文字列に変換する方法を完全にコントロールしたい場合は、
文字列ライブラリの <code>format</code> 関数を使ってください
(<a href="#pdf-string.format"><code>string.format</code></a> を参照)。





<h3>3.4.3 &ndash; <a name="3.4.3">関係演算子</a></h3>
<p>
Lua には以下の関係演算子があります。

<pre>
     ==    ~=    &lt;     &gt;     &lt;=    &gt;=
</pre><p>
これらの演算子は常に <b>false</b> か <b>true</b> を返します。


<p>
等値比較 (<code>==</code>) はまず引数の型を比較します。
型が異なっている場合、 結果は <b>false</b> です。
そうでなければ、 引数の値を比較します。
数値および文字列の場合は、 一般的な方法で比較します。
テーブル、 ユーザーデータ、 スレッドは参照を比較します。
つまり、 同じオブジェクトである場合だけ、 等しいとみなします。
新しいオブジェクト (テーブル、 ユーザーデータ、 スレッド) を作ったときは常に、
この新しいオブジェクトはそれまで存在していたオブジェクトとは異なります。
同じ参照を持つクロージャは常に等しくなります。
観測可能な差異 (異なる動作や異なる定義) を持つクロージャは常に異なります。


<p>
"eq" メタメソッドを使うと、 テーブルとユーザーデータの比較方法を変更できます (<a href="#2.4">&sect;2.4</a> を参照)。


<p>
<a href="#3.4.2">&sect;3.4.2</a> の変換規則は等値比較には適用されません。
そのため、 <code>"0"==0</code> は <b>false</b> と評価され、
<code>t[0]</code> と <code>t["0"]</code> は異なるテーブルエントリを指します。


<p>
演算子 <code>~=</code> は等値比較 (<code>==</code>) の否定です。


<p>
順序演算子は以下のように動作します。
両方の引数が数値の場合は、 それらは普通に比較されます。
そうでなく、 両方の引数が文字列の場合は、 それらは現在のロケールに従って比較されます。
そうでなければ、"lt" または "le" メタメソッドを呼び出します (<a href="#2.4">&sect;2.4</a> を参照)。
<code>a &gt; b</code> は <code>b &lt; a</code> に変換され、
<code>a &gt;= b</code> は <code>b &lt;= a</code> に変換されます。





<h3>3.4.4 &ndash; <a name="3.4.4">論理演算子</a></h3>
<p>
Lua には論理演算子 <b>and</b>、 <b>or</b> および <b>not</b> があります。
制御構造と同様に (<a href="#3.3.4">&sect;3.3.4</a> を参照)、
論理演算子はすべて <b>false</b> と <b>nil</b> の両方を偽とみなし、
それ以外のすべてを真とみなします。


<p>
否定演算子 <b>not</b> は常に <b>false</b> または <b>true</b> を返します。
論理積演算子 <b>and</b> は最初の引数が <b>false</b> または <b>nil</b> であればその値を返し、
そうでなければ 2 番目の引数を返します。
論理和演算子 <b>or</b> は最初の引数が <b>nil</b> または <b>false</b> でなければその値を返し、
そうでなければ 2 番目の引数を返します。
<b>and</b> と <b>or</b> は両方とも短絡評価を行います。
つまり、 2 番目の引数は必要な場合だけ評価されます。
いくつか例を挙げます。

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
(このマニュアルでは <code>--&gt;</code> で式の結果を示します。)





<h3>3.4.5 &ndash; <a name="3.4.5">連結</a></h3>
<p>
Lua では文字列の連結演算子は 2 つのドット ('<code>..</code>') で表します。
両方の引数が文字列か数値であれば、
それらは <a href="#3.4.2">&sect;3.4.2</a> で述べたルールに従って文字列に変換されます。
そうでなければ、<code>__concat</code> メタメソッドが呼ばれます (<a href="#2.4">&sect;2.4</a> を参照)。





<h3>3.4.6 &ndash; <a name="3.4.6">長さ演算子</a></h3>

<p>
長さ演算子は単項前置演算子 <code>#</code> で表されます。
文字列の長さは、 そのバイト数です (つまり 1 文字が 1 バイトである場合の文字列の長さです)。


<p>
<code>__len</code> メタメソッドを使うと、
文字列以外の任意の値の長さ演算子の動作を変更できます (<a href="#2.4">&sect;2.4</a> を参照)。


<p>
<code>__len</code> メタメソッドを設定しない場合、
テーブル <code>t</code> の長さは、 そのテーブルが <em>シーケンス</em> である場合だけ定義されます。
つまり、 その正の数値キーの集合が <em>{1..n}</em> と等しい場合です。
ここで、 整数 <em>n</em> がその長さになります。
以下のようなテーブルは

<pre>
     {10, 20, nil, 40}
</pre><p>
シーケンスではないことに注意してください。
キー <code>4</code> は存在しますが、 キー <code>3</code> が存在しないためです。
(すなわち、 このテーブルには正の数値キーの集合が <em>{1..n}</em> と等しくなるような <em>n</em> がありません。)
しかしながら、 数値以外のキーは、 テーブルがシーケンスであるかどうかには影響しないことも、 知っておいてください。





<h3>3.4.7 &ndash; <a name="3.4.7">優先順位</a></h3>
<p>
Lua の演算子の優先順位を低いものから高いものの順に以下の表に示します。

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     ..
     +     -
     *     /     %
     not   #     - (単項)
     ^
</pre><p>
通常の数式と同様に、 括弧で式の優先順位を変えることができます。
連結 ('<code>..</code>') と累乗 ('<code>^</code>') 演算子は右結合です。
それ以外の二項演算子はすべて左結合です。





<h3>3.4.8 &ndash; <a name="3.4.8">テーブルコンストラクタ</a></h3>
<p>
テーブルコンストラクタはテーブルを作成する式です。
コンストラクタが評価されるたびに新しいテーブルが作成されます。
空のテーブルを作ったり、 テーブルを作っていくつかのフィールドを初期化したりできます。
コンストラクタの一般的な構文は以下の通りです。

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
<code>[exp1] = exp2</code> 形式のフィールドは、
キー <code>exp1</code> と値 <code>exp2</code> からなるエントリをテーブルに追加します。
<code>name = exp</code> 形式のフィールドは、 <code>["name"] = exp</code> と同等です。
最後に、 <code>exp</code> 形式のフィールドは、 <code>[i] = exp</code> と同等です。
ただし <code>i</code> は 1 から始まって順番に増えていく整数です。
他の形式のフィールドはこのカウントに影響しません。
例を挙げます。

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
これは以下と同等です。

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1 番目の exp
       t[2] = "y"         -- 2 番目の exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3 番目の exp
       t[30] = 23
       t[4] = 45          -- 4 番目の exp
       a = t
     end
</pre>

<p>
リストの最後のフィールドが <code>exp</code> 形式で、 その式が関数呼び出しか可変長引数式である場合は、
その式のすべての戻り値が順番にリストに入れられます (<a href="#3.4.9">&sect;3.4.9</a> を参照)。


<p>
コードを自動生成するときに便利なように、
フィールドリストの最後に省略可能なセパレータを付けることができます。





<h3>3.4.9 &ndash; <a name="3.4.9">関数呼び出し</a></h3>
<p>
Lua の関数呼び出しの構文は以下の通りです。

<pre>
	functioncall ::= prefixexp args
</pre><p>
関数呼び出しでは、 まず prefixexp および args が評価されます。
prefixexp の値が <em>関数</em> 型である場合は、 その関数が指定された引数で呼び出されます。
そうでない場合は、 prefixexp の "call" メタメソッドが呼ばれ、
その最初の引数に prefixexp の値が、 2 番目以降に元の引数が渡されます (<a href="#2.4">&sect;2.4</a> を参照)。


<p>
以下の形式は、

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
「メソッド」を呼ぶために使われます。
呼び出し <code>v:name(<em>args</em>)</code> は <code>v.name(v,<em>args</em>)</code> のシンタックスシュガーです。
ただし <code>v</code> の評価が一度だけであるという点が異なります。


<p>
引数の構文は以下の通りです。

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= String
</pre><p>
呼び出しの前にすべての引数が評価されます。
<code>f{<em>fields</em>}</code> 形式の呼び出しは <code>f({<em>fields</em>})</code> のシンタックスシュガーで、
引数リストは新しいテーブルひとつになります。
<code>f'<em>string</em>'</code>
(または <code>f"<em>string</em>"</code> または <code>f[[<em>string</em>]]</code>)
形式の呼び出しは <code>f('<em>string</em>')</code> のシンタックスシュガーで、
引数リストは文字列リテラルひとつになります。


<p>
<code>return <em>functioncall</em></code> 形式の呼び出しは <em>末尾呼び出し</em> と呼ばれます。
Lua は <em>末尾呼び出し最適化</em>
(または <em>末尾再帰最適化</em>)
を実装しています。
末尾呼び出しでは、 呼ばれた関数が呼び出し元関数のスタックエントリを再利用します。
そのため、 プログラムが実行できる末尾呼び出しのネスト回数には制限がありません。
しかし、 末尾呼び出しは呼び出し元関数に関するデバッグ情報を消去してしまいます。
末尾呼び出しは、 <b>return</b> の引数が単一の関数呼び出しであるという特有の構文でのみ起きることに注意してください。
この構文では呼び出された関数の戻り値がそのまま呼び出し元関数の戻り値になります。
すなわち、 以下の例はどれも末尾呼び出しではありません。

<pre>
     return (f(x))        -- 戻り値を 1 個に調節している
     return 2 * f(x)
     return x, f(x)       -- 戻り値を追加している
     f(x); return         -- 戻り値を捨てている
     return x or f(x)     -- 戻り値を 1 個に調節している
</pre>




<h3>3.4.10 &ndash; <a name="3.4.10">関数定義</a></h3>

<p>
関数定義の構文は以下の通りです。

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
以下のシンタックスシュガーを使うと関数定義が簡単になります。

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
以下の文は

<pre>
     function f () <em>body</em> end
</pre><p>
以下のように変換されます。

<pre>
     f = function () <em>body</em> end
</pre><p>
以下の文は

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
以下のように変換されます。

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
以下の文は

<pre>
     local function f () <em>body</em> end
</pre><p>
以下のように変換されます。

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
以下のようにではありません。

<pre>
     local f = function () <em>body</em> end
</pre><p>
(これはこの関数の中から <code>f</code> を参照している場合にだけ差異が生じます。)


<p>
関数定義は実行可能な式であり、 <em>関数</em> 型の値となります。
Lua がチャンクをコンパイルするとき、 関数の本体もすべてコンパイルされます。
その後、 Lua が関数定義を実行するたびに、
関数は <em>インスタンス化</em> (または <em>クローズ</em>) されます。
この関数インスタンス (または <em>クロージャ</em>) は、 式の最終的な値です。


<p>
仮引数は、 実引数の値で初期化されたローカル変数として振る舞います。

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
関数が呼ばれると、 実引数リストは仮引数リストの長さに調節されます。
ただしその関数が <em>可変長引数関数</em> である場合は除きます。
可変長引数関数は、 仮引数リストの最後の 3 つのドット ('<code>...</code>') で表されます。
可変長引数関数では実引数リストを調節しません。
代わりに、 追加の引数をすべて集めて、 それらを <em>可変長引数式</em> を通して関数に提供します。
可変長引数式も 3 つのドットで表されます。
この式の値は、 複数の戻り値を返す関数に似た、 追加の実引数すべてのリストです。
可変長引数式が他の式の中や式リストの途中で使われた場合、 そのリストの戻り値は 1 個に調節されます。
可変長引数式が式リストの最後で使われた場合、 調節は行われません
(その最後の式が括弧で囲まれている場合を除きます)。


<p>
例えば以下の定義を考えてください。

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
このとき、 実引数から仮引数と可変長引数式への対応は以下のようになります。

<pre>
     呼び出し        引数

     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2

     g(3)             a=3, b=nil, ...=(なし)
     g(3, 4)          a=3, b=4,   ...=(なし)
     g(3, 4, 5, 8)    a=3, b=4,   ...=5, 8
     g(5, r())        a=5, b=1,   ...=2, 3
</pre>

<p>
戻り値は <b>return</b> 文を使って返します (<a href="#3.3.4">&sect;3.3.4</a> を参照)。
制御が <b>return</b> 文に出会うことなく関数の最後に達すると、
その関数は戻り値なしで返ります。


<p>

関数が返せる戻り値の数についてシステム依存の制限があります。
この制限は少なくとも 1000 より大きいことが保証されています。


<p>
<em>コロン</em> 構文は <em>メソッド</em> を定義するために使います。
メソッドとは、 暗黙の追加引数 <code>self</code> を持つ関数です。
つまり、 以下の文は

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
以下の文のシンタックスシュガーです。

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>






<h2>3.5 &ndash; <a name="3.5">可視性ルール</a></h2>

<p>

Lua はレキシカルスコープを採用した言語です。
ローカル変数のスコープはその宣言の後の最初の文から始まり、
その宣言を含む最も内側のブロックの無でない最後の文で終わります。
以下の例をみてください。

<pre>
     x = 10                -- グローバル変数
     do                    -- 新しいブロック
       local x = x         -- 新しい 'x' 、 値は 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 別のブロック
         local x = x+1     -- 別の 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (グローバル変数)
</pre>

<p>
<code>local x = x</code> のような宣言では、
右辺の <code>x</code> は外側の変数を参照することに注意してください。
いま宣言している新しい <code>x</code> は、 まだスコープに入っていません。




<p>
レキシカルスコープのルールにより、
ローカル変数はそのスコープ内部で定義された関数から自由にアクセスできます。
内部関数から使うローカル変数は、
内部関数の中からは <em>上位値</em> または <em>外部ローカル変数</em> と呼びます。


<p>
<b>local</b> 文を実行するたびに新しいローカル変数を定義することに注意してください。
以下の例をみてください。

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
このループは、 10 個のクロージャ (つまり匿名関数の 10 個のインスタンス) を作ります。
すべてのクロージャは同じ変数 <code>x</code> を共有しますが、
それぞれ異なる変数 <code>y</code> を使います。





<h1>4 &ndash; <a name="4">API</a></h1>

<p>

このセクションでは、
Lua のための C の API、
つまり Lua とやりとりするためにホストプログラムから利用可能な C の関数について説明します。
すべての API 関数と関連する型および定数は、
ヘッダファイル <a name="pdf-lua.h"><code>lua.h</code></a> で宣言されています。


<p>
「関数」という言葉を使いますが、 代わりにマクロとして提供されている機能もあります。
特に記載がない限り、
そのようなマクロはすべて、 引数をそれぞれちょうど 1 回だけ使うので、 隠れた副作用は起きません
(ただし最初の引数である Lua ステートは除きます)。


<p>
ほとんどの C のライブラリと同様に、 Lua の API は引数の正当性や一貫性をチェックしません。
ただし、 マクロ
<a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a>
を定義して Lua をコンパイルすると、 この動作を変えることもできます。



<h2>4.1 &ndash; <a name="4.1">スタック</a></h2>

<p>
Lua は C との間で値を受け渡しするために、 <em>仮想的なスタック</em> を使います。
スタック中の各要素は Lua の値 (<b>nil</b>、 数値、 文字列など) を表します。


<p>
Lua から C が呼ばれるときは、 呼び出された関数には以前のスタックやまだアクティブな C の関数のスタックとは独立した、 新しいスタックが用意されます。
このスタックは初期状態では、 その C の関数に渡された引数を持っており、 また呼び出し元に戻るときに戻り値を積む場所でもあります
(<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照)。


<p>
便利なように、 API のほとんどの問い合わせ操作は、 厳密なスタックの規則には従っていません。
代わりに <em>インデックス</em> を使って、 スタック中の任意の要素を参照できます。
正のインデックスはスタックの絶対位置 (1 から始まる) を表し、
負のインデックスはスタックトップからの相対オフセットを表します。
例えば、 スタックが <em>n</em> 個の要素を持っていた場合、
インデックス 1 は最初の要素 (つまり最初にスタックに積まれた要素) を表し、
インデックス <em>n</em> は最後の要素を表します。
インデックス -1 もまた最後の要素 (つまりスタックトップの要素) を表し、
インデックス <em>-n</em> は最初の要素を表します。





<h2>4.2 &ndash; <a name="4.2">スタックサイズ</a></h2>

<p>
Lua の API を使うときは、 一貫性を保証する責任があります。
例えば、 <em>スタックオーバーフローに対処しなければなりません</em>。
<a href="#lua_checkstack"><code>lua_checkstack</code></a> 関数を使うと、
スタックに新しい要素を積むための空きスロットがあることを保証できます。


<p>
Lua から C が呼ばれるときは、
スタックに少なくとも <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a> 個の空きスロットがあることが保証されています。
<code>LUA_MINSTACK</code> は 20 に定義されているので、
スタックに要素を積み続けるループでも書かない限り、 通常はスタック空間を気にする必要はないでしょう。


<p>
戻り値の数が固定でない Lua の関数を呼ぶときは
(<a href="#lua_call"><code>lua_call</code></a> を参照)、
スタックがすべての戻り値を格納するのに充分なサイズを持つことを Lua が保証します。
ただし、 それ以上の余分な空間は保証されません。
そのため、 そのような呼び出しの後は、 スタックに値を積む前に <a href="#lua_checkstack"><code>lua_checkstack</code></a> を使う必要があるかもしれません。





<h2>4.3 &ndash; <a name="4.3">有効なおよび受け入れ可能なインデックス</a></h2>

<p>
スタックインデックスを引数に取る API 関数はすべて
<em>有効なインデックス</em> または <em>受け入れ可能なインデックス</em>
のみ使用可能です。


<p>
<em>有効なインデックス</em> とは、 スタック中の有効な位置を指すインデックスです。
つまり、 1 とスタックトップの間
(<code>1 &le; abs(index) &le; top</code>)
の値です。

通常、 特定のスタック位置が必要な関数
(例えば <a href="#lua_remove"><code>lua_remove</code></a>)
は、 有効なインデックスを必要とします。


<p>
特定のスタック位置ではなくスタック中の値のみが必要な関数
(例えば問い合わせ系の関数)
では、 受け入れ可能なインデックスを使うことができます。
<em>受け入れ可能なインデックス</em> は、
スタックに割り当てられた空間中の位置を参照します。
つまり、 スタックサイズまでのインデックスです。
正式に言うと、 受け入れ可能なインデックスは以下のようになります。

<pre>
     (index &lt; 0 &amp;&amp; abs(index) &lt;= top) ||
     (index &gt; 0 &amp;&amp; index &lt;= stack size)
</pre><p>
(0 は受け入れ可能なインデックスではないことに注意してください。)
関数が呼ばれたときのスタックサイズは <code>top + LUA_MINSTACK</code> です。
関数 <a href="#lua_checkstack"><code>lua_checkstack</code></a>
を使ってスタックサイズを変えることができます。


<p>
受け入れ可能なインデックスは、
スタックを問い合わせるときにスタックトップに対する余計なチェックを回避する効果があります。
例えば C の関数で、
3 番目の引数が存在するかどうかをチェックすることなく、
3 番目の引数を問い合わせることができます。
つまり、 3 が有効なインデックスかどうかを調べなくて良いということです。


<p>
受け入れ可能なインデックスを使う関数では、
有効でないインデックスは
仮想の型 <a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>
の値を持つものとして扱います。


<p>
特に記載がない限り、
有効なインデックスを受け取る関数はすべて <em>疑似インデックス</em> も使用できます。
これは、 スタック中には無いものの、 C のコードからアクセス可能な、 いくつかの Lua の値を表しています。
疑似インデックスはレジストリや C の関数の上位値 (<a href="#4.4">&sect;4.4</a> を参照) にアクセスするために使われます。





<h2>4.4 &ndash; <a name="4.4">C のクロージャ</a></h2>

<p>
C の関数を作成するときに、 いくつかの値を関連付けることができます。
つまり <em>C のクロージャ</em> を作れます
(<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> を参照)。
これらの値は <em>上位値</em> と呼ばれ、
その関数が呼ばれたときにいつでもアクセスすることができます。


<p>
C の関数が呼ばれると、 その上位値が特別な疑似インデックスに配置されます。
この疑似インデックスはマクロ <a name="lua_upvalueindex"><code>lua_upvalueindex</code></a> で表されます。
関数に関連付けられた最初の値は <code>lua_upvalueindex(1)</code> の位置にあり、 以下同様です。
現在の関数の上位値の数よりも大きな <em>n</em> (ただし 255 以下) で <code>lua_upvalueindex(<em>n</em>)</code> を呼ぶと、
受け入れ可能な、 ただし有効でないインデックスが生成されます。





<h2>4.5 &ndash; <a name="4.5">レジストリ</a></h2>

<p>
<em>レジストリ</em> は Lua の値を格納するために C のコードから使うことのできる定義済みのテーブルです。
このレジストリテーブルは常に疑似インデックス <a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a> の位置にあります。
あらゆる C のライブラリがこのテーブルにデータを格納することができますが、
衝突を避けるため、 他のライブラリが使わないようなキーを注意深く選ぶべきです。
通常は、 ライブラリの名前を含む文字列や、 ライブラリ内の C のオブジェクトのアドレスに対応するライトユーザーデータをキーとして使うのがよいでしょう。
グローバル変数と同様に、 アンダースコアと大文字で始まる文字列のキーは Lua 自身が使用するために予約されています。


<p>
整数のキーは、 補助ライブラリで実装されているリファレンスメカニズムや、 定義済みの値として使われています。
そのため、 それ以外の目的で整数キーを使うべきではありません。


<p>
新しい Lua ステートを作成したとき、 レジストリにはいくつか定義済みの値が格納されています。
これら定義済みの値は、 <code>lua.h</code> で定数として定義されている整数キーでアクセスできます。
以下の定数が定義されています。

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b>
レジストリのこのインデックスにはステートのメインスレッドが格納されています。
(メインスレッドはステート作成時に作成されたスレッドです。)
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b>
レジストリのこのインデックスにはグローバル環境が格納されています。
</li>
</ul>




<h2>4.6 &ndash; <a name="4.6">C でのエラー処理</a></h2>

<p>
内部的に、 Lua はエラー処理のために C の <code>longjmp</code> の機能を使っています。
(C++を使っている場合は例外を使うこともできます。 ファイル <code>luaconf.h</code> を参照してください。)
Lua が何らかのエラー (メモリ割り当てエラー、 型エラー、 構文エラーおよび実行時エラーなど) に直面すると、
エラーを <em>発生</em> させ、 つまりロングジャンプをします。
<em>保護された環境</em> は <code>setjmp</code> を使って復帰点を設定します。
何らかのエラーが発生すると、 最も直近のアクティブな復帰点にジャンプします。


<p>
保護された環境の外側でエラーが発生すると、 Lua は <em>パニック関数</em> を呼び
(<a href="#lua_atpanic"><code>lua_atpanic</code></a> を参照してください)、
その後 <code>abort</code> を呼んでホストアプリケーションを終了させます。
パニック関数から返らないようにすれば
(Lua の外に作った独自の復帰点にロングジャンプするなど)、
終了を避けることができます。


<p>
パニック関数はメッセージハンドラ (<a href="#2.3">&sect;2.3</a> を参照) であるかのように動作します。
つまり、 エラーメッセージがスタックトップに置かれています。
しかし、 スタック空間に関する保証はありません。
スタックに何かを積む前に、
まず利用可能な空間をチェックするべきです (<a href="#4.2">&sect;4.2</a> を参照)。


<p>
API のほとんどの関数は、
何らかのエラー (例えばメモリ割り当てエラー) が発生する可能性があります。
各関数のドキュメントにエラーが発生する可能性について記載されています。


<p>
C の関数内部では <a href="#lua_error"><code>lua_error</code></a> を呼ぶとエラーを発生させることができます。





<h2>4.7 &ndash; <a name="4.7">C での yield 処理</a></h2>

<p>
内部的に、 Lua はコルーチンを yield するために C の <code>longjmp</code> の機能を使います。
そのため、 関数 <code>foo</code> が API 関数を呼び、 その API 関数が
(直接的に、 または yield する他の関数を呼ぶことによって間接的に)
yield すると、 <code>longjmp</code> が C のスタックからそのフレームを消し去ってしまうため、
Lua は <code>foo</code> に戻ることができなくなってしまいます。


<p>
この種の問題を避けるため、 API 呼び出しをまたいで yield しようとすると Lua はエラーを発生させます。
ただし以下の 3 つの関数は除きます。
<ul>
<li><a href="#lua_yieldk"><code>lua_yieldk</code></a>
<li><a href="#lua_callk"><code>lua_callk</code></a>
<li><a href="#lua_pcallk"><code>lua_pcallk</code></a>
</ul>
<p>
これらの関数はすべて、 yield 後に実行を継続するための <em>継続関数</em> を、 <code>k</code> という名前の引数に取ります。


<p>
継続を説明するために、 いくつか用語を決める必要があります。
Lua から呼ばれる C の関数は <em>元の関数</em> と呼ぶことにします。
この元の関数は、 これら 3 つの C の API 関数のうちどれかを呼びます。
その関数を <em>呼び出した関数</em> と呼ぶことにします。
その後、 現在のスレッドが中断されます。
(これは呼び出した関数が <a href="#lua_yieldk"><code>lua_yieldk</code></a> であるか、
呼び出した関数が <a href="#lua_callk"><code>lua_callk</code></a> または <a href="#lua_pcallk"><code>lua_pcallk</code></a> でありその呼ばれた関数が yield した場合のことです。)


<p>
呼び出した関数の実行中にスレッドが中断されたとしましょう。
スレッドが再開した後、 いずれその呼び出した関数の実行は終了します。
しかし、 呼び出した関数は元の関数に戻ることができません。
yield によって C のスタック上のフレームが破壊されているためです。
代わりに、 Lua は <em>継続関数</em> を呼びます。
名前が示すように、 継続関数は元の関数の処理を継続します。


<p>
Lua は継続関数を元の関数と同じに扱います。
継続関数は元の関数が持っていたのと同じスタックを受け取ります。
呼び出した関数がそのまま返ってきた場合のときと同じ状態になっています。
(例えば、 <a href="#lua_callk"><code>lua_callk</code></a> の後、 関数と引数はスタックから取り除かれ、 呼び出しからの戻り値に置き換えられます。)
上位値も同じものが用意されます。
継続関数が返した値は元の関数が返したかのように処理されます。


<p>
元の関数とその継続関数で、 Lua ステート上唯一異なる点は、 <a href="#lua_getctx"><code>lua_getctx</code></a> の戻り値です。





<h2>4.8 &ndash; <a name="4.8">関数と型</a></h2>

<p>
以下に C の API のすべての関数と型をアルファベット順に掲載します。
それぞれの関数には
[-o, +p, <em>x</em>]
のような印が付いています。


<p>
最初のフィールド <code>o</code> は、 その関数がスタックから取り除く要素の数です。
2 番目のフィールド <code>p</code> は、 その関数がスタックに積む要素の数です。
(どの関数も常に、 まず引数を取り除いてから、 その後に結果を積みます。)
<code>x|y</code> 形式のフィールドは、 状況に応じて <code>x</code> 個または <code>y</code> 個の要素を積む (または取り除く) という意味です。
疑問符 '<code>?</code>' は、 引数を見るだけではその関数が積む (または取り除く) 要素の数がわからないことを表します。
(例えばスタックに何があるかによって変わったりします。)
<p>
3 番目のフィールド <code>x</code> は、 その関数がエラーを発生するかどうかを表します。
<ul>
<li>'<code>-</code>': 決してエラーを発生しない関数です。
<li>'<code>m</code>': メモリ割り当てエラーのみ発生する可能性がある関数です。
<li>'<code>e</code>': それ以外の種類のエラーも発生する可能性がある関数です。
<li>'<code>v</code>': 意図的にエラーを発生させる関数です。
</ul>



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
受け入れ可能なインデックス <code>idx</code> を絶対位置のインデックス
(つまりスタックトップに依存しないインデックス)
に変換します。





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
Lua ステートが使うメモリアロケータ関数の型です。
アロケータ関数は <code>realloc</code> に似た機能を提供しなければなりませんが、 まったく同じではありません。
引数は以下の通りです。
<ul>
<li><code>ud</code>: <a href="#lua_newstate"><code>lua_newstate</code></a> に渡した不透明なポインタです。
<li><code>ptr</code>: 割り当て/再割り当て/解放しようとしているブロックへのポインタです。
<li><code>osize</code>: ブロックの元のサイズか、 割り当てようとしているものについてのコードです。
<li><code>nsize</code>: ブロックの新しいサイズです。
</ul>


<p>
<code>ptr</code> が <code>NULL</code> でない場合、
<code>osize</code> は <code>ptr</code> が指しているブロックのサイズ、
つまり以前に割り当て/再割り当てされたときに指定されたサイズです。


<p>
<code>ptr</code> が <code>NULL</code> の場合、
<code>osize</code> は Lua が割り当てようとしているオブジェクトの種類をコード化しています。
文字列、 テーブル、 関数、 ユーザーデータまたはスレッドを作成しようとしている場合は、 以下のいずれかになります。
<ul>
<li><a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>
<li><a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>
<li><a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>
<li><a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>
<li><a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>
</ul>
<p>
それ以外のメモリを割り当てようとしている場合は、 上記以外の何らかの値になります。


<p>
アロケータ関数は以下のように動作するものと想定されます。


<p>
<code>nsize</code> がゼロのとき、 アロケータは <code>free</code> と同様に動作し、
<code>NULL</code> を返さなければなりません。


<p>
<code>nsize</code> がゼロでないとき、
アロケータは <code>realloc</code> と同様に動作しなければなりません。
アロケータが要求を満たせない場合は、 <code>NULL</code> を返します。
<code>osize &gt;= nsize</code> のとき、 アロケータは決して失敗しないものと想定されます。


<p>
アロケータ関数の簡単な実装を以下に示します。
これは補助ライブラリの <a href="#luaL_newstate"><code>luaL_newstate</code></a> で使われています。

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* 未使用 */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
標準 C ライブラリでは、 <code>free(NULL)</code> が何もしないこと、
および <code>realloc(NULL, size)</code> が <code>malloc(size)</code> と同等であることを思い出してください。
このコードではブロックを縮小するときに <code>realloc</code> が失敗しないと想定しています。
(標準 C はこの動作について保証していませんが、 安全な想定であろうと思われます。)





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>int lua_arith (lua_State *L, int op);</pre>

<p>
スタックトップのふたつの値 (符号反転の場合はひとつ) に対して算術演算を行います。
トップの値が第 2 引数になります。
これらの値を取り除き、 演算の結果を積みます。
関数は対応する Lua の演算子の意味論に従います
(つまりメタメソッドを呼ぶ場合があります)。


<p>
<code>op</code> の値は以下の定数のいずれかでなければなりません。

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 加算 (<code>+</code>) を実行します。</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 減算 (<code>-</code>) を実行します。</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 乗算 (<code>*</code>) を実行します。</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 除算 (<code>/</code>) を実行します。</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> 剰余 (<code>%</code>) を実行します。</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 累乗 (<code>^</code>) を実行します。</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 符号反転 (単項の <code>-</code>) を実行します。</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
新しいパニック関数を設定し、 古いパニック関数を返します (<a href="#4.6">&sect;4.6</a> を参照)。





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
関数を呼びます。


<p>
関数を呼ぶには以下の手順に従う必要があります。
まず、 呼ぶ関数をスタックに積みます。
次に、 関数に渡す引数を正順に積みます。
つまり、 最初の引数を最初に積みます。
最後に、 <a href="#lua_call"><code>lua_call</code></a> を呼びます。
<code>nargs</code> はスタックに積んだ引数の数です。
すべての引数と関数は、 関数を呼ぶときにスタックから取り除かれます。
関数から戻ると、 その関数の戻り値がスタックに積まれます。
戻り値の数は <code>nresults</code> 個に調節されます。
ただし <code>nresults</code> が <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a> の場合は除きます。
この場合、 関数のすべての戻り値が積まれます。
戻り値が収まるように Lua がスタック空間の面倒を見てくれます。
関数の戻り値は正順にスタックに積まれます。
つまり最初の戻り値が最初に積まれます。
そのため呼び出し後は最後の戻り値がスタックトップです。


<p>
呼び出した関数の内部で発生したエラーは
(<code>longjmp</code> によって)
上に伝搬されます。


<p>
以下の例は、 この Lua のコードと同じことをホストプログラムでどうすればいいかを示します。

<pre>
     a = f("how", t.x, 14)
</pre><p>
C では以下のように書きます。

<pre>
     lua_getglobal(L, "f");           /* 呼ぶ関数 */
     lua_pushstring(L, "how");        /* 最初の引数 */
     lua_getglobal(L, "t");           /* インデックス検索するテーブル */
     lua_getfield(L, -1, "x");        /* t.x の結果を積む(2 番目の引数) */
     lua_remove(L, -2);               /* 't' をスタックから取り除く */
     lua_pushinteger(L, 14);          /* 3 番目の引数 */
     lua_call(L, 3, 1);               /* 3 個の引数と 1 個の戻り値で 'f' を呼ぶ */
     lua_setglobal(L, "a");           /* グローバルの 'a' に格納 */
</pre><p>
上記のコードは「バランスが取れている」ことに注目してください。
最終的にスタックは元の状態に戻っています。
これは良いプログラミング作法であると考えられます。





<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L, int nargs, int nresults, int ctx,
                lua_CFunction k);</pre>

<p>
<a href="#lua_call"><code>lua_call</code></a> とまったく同じですが、
呼んだ関数が yield できます (<a href="#4.7">&sect;4.7</a> を参照)。





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
C の関数の型です。


<p>
Lua と適切にやりとりするには、 C の関数は引数と戻り値の受け渡し方法を定める以下の手順に従う必要があります。
C の関数は Lua からの引数をスタックに正順で受け取ります
(最初の引数が最初に積まれます)。
そのため、 関数が開始したとき、
<code>lua_gettop(L)</code> は関数が受け取った引数の数を返します。
最初の引数 (もしあれば) はインデックス 1 の位置に置かれ、
最後の引数はインデックス <code>lua_gettop(L)</code> の位置に置かれます。
Lua に値を返すには、 C の関数はただそれらをスタックに正順で積み
(最初の戻り値を最初に積み)、
戻り値の数を返します。
戻り値より下にあるスタック中の値はすべて Lua が適切に破棄します。
Lua の関数と同様に、 Lua から呼ばれる C の関数も複数の値を返すことができます。


<p>
例として、 任意の数の数値引数を受け取り、 それらの平均と合計を返す関数を以下に示します。

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);            /* 引数の数 */
       lua_Number sum = 0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushstring(L, "引数が正しくありません");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);         /* 最初の戻り値 */
       lua_pushnumber(L, sum);           /* 2 番目の戻り値 */
       return 2;                         /* 戻り値の数 */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int extra);</pre>

<p>
スタックに <code>extra</code> 個の空きスロットを確保します。
要求が満たせない場合は false を返します。
スタックには固定の最大サイズがあり (通常少なくとも数千程度)、
それよりも大きくしようとしたり、 必要なメモリを割り当てられなかったときに、 そのようになります。
この関数は、 スタックを縮めることは決してしません。
もしスタックが指定したサイズよりもすでに大きければ、 何もしません。





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
指定した Lua ステートのすべてのオブジェクトを破棄し
(もしあれば対応するガベージコレクションメタメソッドも呼び)、
このステートによって使われていたすべての動的メモリを解放します。
プラットフォームによっては、
ホストプログラムの終了時にすべてのリソースが自動的に解放されるために、
この関数を呼ぶ必要がないかもしれません。
一方、 デーモンやウェブサーバのようにステートを複数作る長時間動作のプログラムでは、
必要なくなったステートはすぐに解放する必要があるかもしれません。





<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
2 つの Lua の値を比較します。
受け入れ可能なインデックス <code>index1</code> の値が
受け入れ可能なインデックス <code>index2</code> の値と比較して
<code>op</code> を満たす場合に 1 を返します。
比較は対応する Lua の演算子の意味論に従います
(つまりメタメソッドを呼ぶ場合があります)。
<code>op</code> を満たさない場合は 0 を返します。
いずれかのインデックスが有効でない場合も 0 を返します。


<p>
<code>op</code> の値は以下の定数のいずれかでなければなりません。

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> 等しい (<code>==</code>) かどうかを比較します。</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> より小さい (<code>&lt;</code>) かどうかを比較します。</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> より小さいまたは等しい (<code>&lt;=</code>) かどうかを比較します。</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
スタックトップの <code>n</code> 個の値を連結します。
それらの値を取り除き、 結果をトップに残します。
<code>n</code> が 1 の場合、 結果はそのスタック上の 1 個の値です
(つまり何もしません)。
<code>n</code> が 0 の場合、 結果は空文字列です。
連結は Lua の通常の意味論に従って行われます
(<a href="#3.4.5">&sect;3.4.5</a> を参照)。





<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
有効なインデックス <code>fromidx</code> の要素を有効なインデックス <code>toidx</code> に移動します。
どの要素もずらしません
(つまりその位置の値を置き換えます)。





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
空の新しいテーブルを作成し、 スタックトップに積みます。
引数 <code>narr</code> はテーブルがシーケンスとして持つ予定の要素数に対するヒントです。
引数 <code>nrec</code> はテーブルが持つ予定のそれ以外の要素数に対するヒントです。
Lua はこれらのヒントを使って新しいテーブル用にメモリを事前割り当てする場合があります。
この事前割り当てはテーブルが持つ予定の要素数が事前にわかっている場合に性能向上の役に立ちます。
そうでない場合は <a href="#lua_newtable"><code>lua_newtable</code></a> 関数を使うこともできます。





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>int lua_dump (lua_State *L, lua_Writer writer, void *data);</pre>

<p>
関数をバイナリチャンクとしてダンプします。
スタックトップにある Lua の関数を受け取り、 バイナリチャンクを生成します。
バイナリチャンクは、 再びロードすると、 ダンプ元のものと同等の関数が得られます。
チャンクの各部を生成するにあたって、
<a href="#lua_dump"><code>lua_dump</code></a> は出力関数 <code>writer</code> を呼びます
(<a href="#lua_Writer"><code>lua_Writer</code></a> を参照)。
<code>data</code> は <code>writer</code> に渡されます。


<p>
戻り値は writer が最後に返したエラーコードです。
0 はエラーなしを表します。


<p>
処理対象の Lua の関数はスタックから取り除かれません。





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
Lua のエラーを生成します。
エラーメッセージ (実際には Lua のどんな型の値でも良い) がスタックトップになければなりません。
この関数はロングジャンプするため、 決して戻りません
(<a href="#luaL_error"><code>luaL_error</code></a> を参照)。





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
ガベージコレクタをコントロールします。


<p>
この関数は引数 <code>what</code> の値に応じて様々な処理を行います。

<ul>

<li><b><code>LUA_GCSTOP</code>: </b>
ガベージコレクタを停止します。
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
ガベージコレクタを再開します。
</li>

<li><b><code>LUA_GCCOLLECT</code>: </b>
完全なガベージコレクションサイクルを実行します。
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
Lua が使用している現在のメモリ量を (キロバイトで) 返します。
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
Lua が使用している現在のメモリ量のバイト数を 1024 で割った余りを返します。
</li>

<li><b><code>LUA_GCSTEP</code>: </b>
ガベージコレクションのインクリメンタルステップを実行します。
ステップの「サイズ」は <code>data</code> で制御します。
大きな値は大きなステップを表しますが、 具体的には決まっていません。
ステップサイズを制御したい場合は、 <code>data</code> の値を実験的に調整する必要があります。
このステップでガベージコレクションサイクルが終了した場合は 1 を返します。
</li>

<li><b><code>LUA_GCSETPAUSE</code>: </b>
コレクタの <em>停止期間</em> の新しい値を <code>data</code> に設定します。
(<a href="#2.5">&sect;2.5</a> を参照)。
停止期間の前の値を返します。
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>: </b>
コレクタの <em>ステップ係数</em> の新しい値を <code>data</code> に設定します
(<a href="#2.5">&sect;2.5</a> を参照)。
ステップ係数の前の値を返します。
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
コレクタが実行中かどうか (つまり停止中でないか) を示すブーリアン値を返します。
</li>

<li><b><code>LUA_GCGEN</code>: </b>
コレクタを世代別モードに変更します
(<a href="#2.5">&sect;2.5</a> を参照)。
</li>

<li><b><code>LUA_GCINC</code>: </b>
コレクタをインクリメンタルモードに変更します。
これはデフォルトのモードです。
</li>
</ul>

<p>
これらのオプションについてのより詳しい情報は
<a href="#pdf-collectgarbage"><code>collectgarbage</code></a>
を参照してください。





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
指定したステートのメモリアロケータ関数を返します。
<code>ud</code> が <code>NULL</code> でない場合は、
<a href="#lua_newstate"><code>lua_newstate</code></a>
に渡された不透明なポインタを <code>*ud</code> に格納します。





<hr><h3><a name="lua_getctx"><code>lua_getctx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getctx  (lua_State *L, int *ctx);</pre>

<p>
スレッドの状態とコンテキスト情報を取得します。
この関数は継続関数から呼びます
(<a href="#4.7">&sect;4.7</a> を参照)。


<p>
元の関数から呼ばれると、
<a href="#lua_getctx"><code>lua_getctx</code></a>
は常に <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
を返し、 引数 <code>ctx</code> の値は変更しません。
継続関数から呼ばれると、
<a href="#lua_getctx"><code>lua_getctx</code></a>
は <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> を返し、
<code>ctx</code> の値にコンテキスト情報を設定します
(呼び出した関数の <code>ctx</code> 引数に継続関数と共に渡した値です)。


<p>
呼び出した関数が <a href="#lua_pcallk"><code>lua_pcallk</code></a> の場合、
呼び出しの中で発生したエラーを処理するときにも継続関数が呼ばれることがあります。
つまり、 <a href="#lua_pcallk"><code>lua_pcallk</code></a>
によって呼ばれた関数の中でエラーが発生した場合、
Lua は元の関数に戻らず、
代わりに継続関数を呼ぶことがあります。
この場合、 <a href="#lua_getctx"><code>lua_getctx</code></a> を呼び出すと、 エラーコード
(<a href="#lua_pcallk"><code>lua_pcallk</code></a> が返すはずだった値)
を返し、 <code>ctx</code> の値には yield した場合のようにコンテキスト情報が設定されます。





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
スタックに値 <code>t[k]</code> を積みます。
ただし <code>t</code> は指定した有効なインデックスの値です。
Lua 上で実行する場合と同様に、 "index" イベントのメタメソッドを呼ぶ場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_getglobal (lua_State *L, const char *name);</pre>

<p>
グローバル変数 <code>name</code> の値をスタックに積みます。





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値のメタテーブルをスタックに積みます。
その値がメタテーブルでなければ、
0 を返し、 スタックには何も積みません。





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>void lua_gettable (lua_State *L, int index);</pre>

<p>
スタックに値 <code>t[k]</code> を積みます。
ただし <code>t</code> は指定した有効なインデックスの値で、
<code>k</code> はスタックトップの値です。


<p>
キーはスタックから取り除かれます
(そしてその場所に結果が置かれます)。
Lua 上で実行する場合と同様に、 "index" イベントのメタメソッドを呼ぶ場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
スタックトップの要素のインデックスを返します。
インデックスは 1 から始まるため、 これはスタックにある要素の数と等しくなります
(0 の場合はスタックが空であることを表します)。





<hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_getuservalue (lua_State *L, int index);</pre>

<p>
指定したインデックスのユーザーデータに関連付けられた Lua の値をスタックに積みます。
この Lua の値はテーブルまたは <b>nil</b> のいずれかです。





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
トップの要素を指定した有効なインデックスの位置に移動します。
隙間を空けるために、 指定したインデックスより上の要素は上にずらされます。
疑似インデックスは実際のスタック位置を表していないため、 指定できません。





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ptrdiff_t lua_Integer;</pre>

<p>
符号付き整数値を表すために Lua の API で使われる型です。


<p>
デフォルトではこれは <code>ptrdiff_t</code> です。
これは通常そのマシンが「快適に」扱える最も大きな符号付きの型です。





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値がブーリアンの場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値が C の関数である場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値が (C または Lua いずれかの) 関数である場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値がライトユーザーデータの場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値が <b>nil</b> の場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスが有効でない
(つまり現在のスタックの外側の要素を参照している)
場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスが有効でない
(つまり現在のスタックの外側の要素を参照している)
またはそのインデックスの値が <b>nil</b> の場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値が数値または数値に変換可能な文字列の場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値が文字列または数値である場合は 1 を返し
(数値は常に文字列に変換可能)、
そうでない場合は 0 を返します。





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値がテーブルの場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値がスレッドの場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値が
(フルまたはライトいずれかの)
ユーザーデータである場合は 1 を返し、 そうでない場合は 0 を返します。





<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能インデックスの値の「長さ」を返します。
これは Lua の '<code>#</code>' 演算子と同等です
(<a href="#3.4.6">&sect;3.4.6</a> を参照)。
結果はスタックに積まれます。





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *source,
              const char *mode);</pre>

<p>
Lua のチャンクをロードします (実行はしません)。
エラーがなければ、
<code>lua_load</code>
はコンパイルしたチャンクを Lua の関数としてスタックトップに積みます。
そうでなければ、 エラーメッセージを積みます。


<p>
<code>lua_load</code> の戻り値は以下のいずれかです。

<ul>

<li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> エラーはありません。</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b>
コンパイル中に構文エラーが発生しました。</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
メモリ割り当てエラーが発生しました。</li>

<li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
<code>__gc</code> メタメソッド実行中にエラーが発生しました
(このエラーはロード中のチャンクと関係なく、
ガベージコレクタによって生成されます。)
</li>

</ul>

<p>
<code>lua_load</code> 関数はユーザー定義の <code>reader</code> 関数を使ってチャンクを読み込みます
(<a href="#lua_Reader"><code>lua_Reader</code></a> を参照)。
<code>data</code> 引数は reader 関数に渡される不透明な値です。


<p>
<code>source</code> 引数はチャンクの名前を指定します。
これはエラーメッセージやデバッグ情報で使われます (<a href="#4.9">&sect;4.9</a> を参照)。


<p>
<code>lua_load</code>
はチャンクがテキストかバイナリかを自動的に判定し、 適切にそれをロードします
(<code>luac</code> プログラムを参照)。
文字列 <code>mode</code> は <a href="#pdf-load"><code>load</code></a> と同様に動作します。
ただし <code>NULL</code> の場合は文字列 "<code>bt</code>" と同等です。


<p>
戻り値の関数は上位値をひとつ持っています。
この上位値はレジストリの
<code>LUA_RIDX_GLOBALS</code>
インデックスに格納されているグローバル環境の値に設定されます
(<a href="#4.5">&sect;4.5</a> を参照)。
メインチャンクをロードするときは、
この上位値は <code>_ENV</code> 変数になります
(<a href="#2.2">&sect;2.2</a> を参照)。





<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
新しい独立したステート上で走る、 新しいスレッドを作成します。
スレッドまたはステートを作成できない (メモリ不足のため) 場合は <code>NULL</code> を返します。
引数 <code>f</code> はアロケータ関数です。
Lua はこのステート用のすべてのメモリ割り当てをこの関数を使って行います。
2 番目の引数 <code>ud</code> は、 アロケータを呼ぶときに毎回渡される不透明なポインタです。





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
新しい空のテーブルを作成し、 スタックに積みます。
<code>lua_createtable(L, 0, 0)</code> と同等です。





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
新しいスレッドを作成し、 スタックに積みます。
また、 この新しいスレッドを表す <a href="#lua_State"><code>lua_State</code></a> へのポインタを返します。
この関数から返される新しいスレッドは、 グローバル環境を元のスレッドと共有しますが、
独立した実行スタックを持ちます。


<p>
スレッドを閉じたり破棄したりするための明示的な関数はありません。
他のあらゆる Lua のオブジェクトと同様に、 スレッドはガベージコレクションの対象です。





<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
指定したサイズの新しいメモリブロックを割り当て、
そのブロックのアドレスを持つ新しいフルユーザーデータをスタックに積みます。
また、 そのアドレスを返します。
このメモリはホストプログラムで自由に使うことができます。





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
スタックからキーを取り除き、 指定したインデックスのテーブルから、 取り除いたキーの「次の」ペアを積みます。
テーブルにそれ以上要素がない場合、 <a href="#lua_next"><code>lua_next</code></a> は何も積まず、 0 を返します。


<p>
通常、 テーブルの巡回は以下のように行います。

<pre>
     /* テーブルはスタックのインデックス 't' にあるとします */
     lua_pushnil(L);  /* 最初のキー */
     while (lua_next(L, t) != 0) {
       /* キー (インデックス -2) と値 (インデックス -1) を使います */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 値は取り除き、 キーは次の反復のために保持しておきます */
       lua_pop(L, 1);
     }
</pre>

<p>
テーブルを巡回する間、
それが実際に文字列であると判っている場合以外は、
キーに対して直に <a href="#lua_tolstring"><code>lua_tolstring</code></a> を呼んではいけません。
<a href="#lua_tolstring"><code>lua_tolstring</code></a> は指定したインデックスの値を変更することを思い出してください。
これは次の <a href="#lua_next"><code>lua_next</code></a> の呼び出しを混乱させます。


<p>
テーブル巡回中のテーブル変更に対する注意点について関数 <a href="#pdf-next"><code>next</code></a> を参照してください。





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef double lua_Number;</pre>

<p>
Lua の数値型です。
デフォルトではこれは double です。
<code>luaconf.h</code> で変更することもできます。
このコンフィグレーションファイルファイルにより、 数値を他の型 (float や long など) に変更できます。





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
保護モードで関数を呼びます。


<p>
<code>nargs</code> および <code>nresults</code> は
<a href="#lua_call"><code>lua_call</code></a>
と同じです。
呼んでいる間にエラーが発生しなかった場合、
<a href="#lua_pcall"><code>lua_pcall</code></a> は <a href="#lua_call"><code>lua_call</code></a> とまったく同様に動作します。
しかし何らかのエラーが発生した場合、
<a href="#lua_pcall"><code>lua_pcall</code></a> はそれをキャッチし、
スタックにひとつの値 (エラーメッセージ) を積み、 エラーコードを返します。
<a href="#lua_call"><code>lua_call</code></a> と同様に、
<a href="#lua_pcall"><code>lua_pcall</code></a> は関数と引数を常にスタックから取り除きます。


<p>
<code>msgh</code> が 0 の場合、 スタック上に返されるエラーメッセージは正確に元のエラーメッセージです。
そうでない場合、 <code>msgh</code> は <em>メッセージハンドラ</em> のスタックインデックスです。
(現在の実装では、 このインデックスには疑似インデックスを使えません。)
実行時エラーが発生すると、 この関数はエラーメッセージと共に呼ばれ、
その戻り値は <a href="#lua_pcall"><code>lua_pcall</code></a> がスタックに返すメッセージになります。


<p>
通常、 メッセージハンドラは、 スタックトレースのような追加のデバッグ情報をエラーメッセージに付け加えるために使います。
<a href="#lua_pcall"><code>lua_pcall</code></a> から戻った後では、
スタックが巻き戻されてしまうため、
そういった情報を集めることができません。


<p>
<a href="#lua_pcall"><code>lua_pcall</code></a> 関数は以下のコードのいずれかを返します
(<code>lua.h</code> で定義されています)。

<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b>
成功。</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b>
実行時エラー。
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
メモリ割り当てエラー。
このようなエラーの場合、 メッセージハンドラは呼ばれません。
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b>
メッセージハンドラ実行中のエラー。
</li>

<li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
<code>__gc</code> メタメソッド実行中のエラー。
(このエラーは通常、 呼んだ関数とは関係がありません。
ガベージコレクタによって生成されます。)
</li>

</ul>




<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int errfunc,
                int ctx,
                lua_CFunction k);</pre>

<p>
<a href="#lua_pcall"><code>lua_pcall</code></a> とまったく同じですが、
呼ばれた関数は yield できます (<a href="#4.7">&sect;4.7</a> を参照)。





<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, &ndash;]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
スタックから <code>n</code> 個の要素を取り除きます。





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
値 <code>b</code> のブーリアン値をスタックに積みます。





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
新しい C のクロージャをスタックに積みます。


<p>
C の関数を作成するときに、 いくつかの値を関連付けることができます。
そのため C のクロージャを作ることができます (<a href="#4.4">&sect;4.4</a> を参照)。
これらの値はその関数が呼ばれたときならいつでもアクセスできます。
値を C の関数に関連付けるためには、 最初にこれらの値をスタックに積みます
(複数の値がある場合は、 最初の値を最初に積みます)。
次に
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
を呼んで C の関数を作成し、 スタックに積みます。
このとき引数 <code>n</code> に、 この関数に関連付ける値の数を指定します。
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
はこれらの値をスタックから取り除きます。


<p>
<code>n</code> の最大値は 255 です。


<p>
<code>n</code> がゼロの場合は、 <em>軽量な C の関数</em> を作成します。
これはその C の関数への単なるポインタであり、
この場合メモリエラーは発生しません。





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
C の関数をスタックに積みます。
C の関数へのポインタを受け取り、
呼ばれたときに対応する C の関数を起動する
<em>関数</em> 型の Lua の値をスタックに積みます。


<p>
Lua に登録しようとする関数は、 引数と戻り値を受け渡す正しい手順に従わなければなりません
(<a href="#lua_CFunction"><code>lua_CFunction</code></a> を参照)。


<p>
<code>lua_pushcfunction</code> はマクロとして定義されています。

<pre>
     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</pre><p>
ちなみに <code>f</code> は 2 回使われます。





<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
書式化文字列をスタックに積み、 この文字列へのポインタを返します。
C の関数 <code>sprintf</code> に似ていますが、 いくつか重要な違いがあります。

<ul>

<li>
戻り値を受け取るための空間を確保する必要はありません。
戻り値は Lua の文字列であり、 Lua がメモリ割り当て
(およびガベージコレクションによる解放)
の面倒をみます。
</li>

<li>
変換指定子は非常に制限されています。
フラグや幅、 精度はありません。
変換指定子は以下のもののみが指定できます。
<ul>
<li>'<code>%%</code>' (文字列に '<code>%</code>' を挿入します)
<li>'<code>%s</code>' (ゼロ終端文字列を挿入します。 サイズ制限はありません)
<li>'<code>%f</code>' (<a href="#lua_Number"><code>lua_Number</code></a> を挿入します)
<li>'<code>%p</code>' (ポインタを 16 進数表記で挿入します)
<li>'<code>%d</code>' (<code>int</code> を挿入します)
<li>'<code>%c</code>' (<code>int</code> をバイトとして挿入します)
</ul>

</ul>




<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
値 <code>n</code> の数値をスタックに積みます。





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
ライトユーザーデータをスタックに積みます。


<p>
ユーザーデータは C の値を Lua で表現したものです。
<em>ライトユーザーデータ</em> はポインタ、 <code>void*</code> を表現します。
これは (数値と同様に) 値です。
作成されず、 独自のメタテーブルも持たず、 (作成されないので) 回収されることもありません。
ライトユーザーデータは同じ C のアドレスを持つ「どの」ライトユーザーデータとも等しくなります。





<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
<a href="#lua_pushlstring"><code>lua_pushlstring</code></a> と同等のマクロですが、
<code>s</code> がリテラル文字列の場合だけ使用できます。
文字列の長さは自動的に計算されます。





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
<code>s</code> が指す長さ <code>len</code> の文字列をスタックに積みます。
Lua は指定された文字列の内部コピーを作る (または再利用する) ため、
この関数から戻った直後に <code>s</code> が指すメモリを解放したり再利用してもかまいません。
文字列は埋め込まれたゼロを含めて、 任意のバイトデータを持つことができます。


<p>
文字列の内部コピーへのポインタを返します。





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
nil 値をスタックに積みます。





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
値 <code>n</code> の数値をスタックに積みます。





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
<code>s</code> が指すゼロ終端文字列をスタックに積みます。
Lua は指定された文字列の内部コピーを作成する (または再利用する) ため、
この関数から戻った直後に <code>s</code> の指すメモリを解放したり再利用してもかまいません。


<p>
文字列の内部コピーへのポインタを返します。


<p>
<code>s</code> が <code>NULL</code> の場合は、 <b>nil</b> を積み、 <code>NULL</code> を返します。





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
<code>L</code> によって表されるスレッドをスタックに積みます。
そのスレッドがこのステートのメインスレッドの場合は 1 を返します。





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, <em>-</em>]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
指定した有効なインデックスの要素のコピーをスタックに積みます。





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
<a href="#lua_pushfstring"><code>lua_pushfstring</code></a> と同等ですが、
可変長引数の代わりに <code>va_list</code> を受け取る点が異なります。





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
受け入れ可能なインデックス <code>index1</code> および <code>index2</code> の 2 つの値がプリミティブに
(つまりメタメソッドを呼ばずに)
等しい場合は、 1 を返します。
そうでない場合は、 0 を返します。
いずれかのインデックスが有効でない場合も 0 を返します。





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_rawget (lua_State *L, int index);</pre>

<p>
<a href="#lua_gettable"><code>lua_gettable</code></a> に似ていますが、 生のアクセスを行う
(つまりメタメソッドを呼ばない)
点が異なります。





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_rawgeti (lua_State *L, int index, int n);</pre>

<p>
<code>t[n]</code> の値をスタックに積みます。
ただし、 <code>t</code> は指定した有効なインデックスのテーブルです。
アクセスは生です。
つまり、 メタメソッドを呼びません。





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
<code>t[k]</code> の値をスタックに積みます。
ただし <code>t</code> は指定した有効なインデックスのテーブルで、
<code>k</code> はポインタ <code>p</code> をライトユーザーデータにしたものです。
アクセスは生です。
つまり、 メタメソッドを呼びません。





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値の生の「長さ」を返します。
文字列の場合、 これは文字列の長さです。
テーブルの場合、 これはメタメソッドを呼ばない長さ演算子 ('<code>#</code>') の結果です。
ユーザーデータの場合、 これはそのユーザーデータに割り当てたメモリブロックのサイズです。
それ以外の場合は 0 を返します。





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
<a href="#lua_settable"><code>lua_settable</code></a> と同様ですが、 生の代入を行う
(つまりメタメソッドを呼ばない)
点が異なります。





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, int n);</pre>

<p>
<code>t[n] = v</code> と同等のことを行います。
ただし、 <code>t</code> は指定した有効なインデックスのテーブルで、
<code>v</code> はスタックトップの値です。


<p>
値はスタックから取り除かれます。
代入は生です。
つまりメタメソッドを呼びません。





<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
<code>t[k] = v</code> と同等のことを行います。
ただし <code>t</code> は指定した有効なインデックスのテーブル、
<code>k</code> はポインタ <code>p</code> をライトユーザーデータにしたもの、
<code>v</code> はスタックトップの値です。


<p>
値はスタックから取り除かれます。
代入は生です。
つまりメタメソッドを呼びません。





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
<a href="#lua_load"><code>lua_load</code></a> で使うリーダー関数です。
新しいチャンク片が必要になるたびに、
<a href="#lua_load"><code>lua_load</code></a> から <code>data</code> 引数を渡されてリーダーが呼ばれます。
リーダーは新しいチャンク片を格納したメモリブロックのポインタを返し、
<code>size</code> にそのブロックのサイズを設定しなければなりません。
ブロックはリーダー関数がもう一度呼ばれるまで存在していなければなりません。
チャンクの終わりを知らせるためには、 リーダーは <code>NULL</code> を返すか、 <code>size</code> をゼロに設定してください。
リーダー関数はゼロより大きな任意のサイズのチャンク片を返してかまいません。





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>


<p>
C の関数 <code>f</code> をグローバル変数 <code>name</code> の新しい値として設定します。
これはマクロとして定義されています。

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
指定した有効なインデックスの要素を削除し、
空いた隙間を埋めるためにそのインデックスより上の要素を下にずらします。
疑似インデックスは実際のスタック位置でないため指定できません。





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
トップの要素を指定した位置へ移動します。
どの要素もずらしません
(そのため指定した位置の値を置き換えます)。
またトップの要素を取り除きます。





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int narg);</pre>

<p>
指定したスレッドのコルーチンを開始または再開します。


<p>
コルーチンを開始するには、 スレッドのスタックにメイン関数と引数を積み、
その引数の数を <code>narg</code> に指定して <a href="#lua_resume"><code>lua_resume</code></a> を呼びます。
コルーチンが中断するか実行終了すると、 この呼び出しから戻ります。
戻ったとき、 スタックには <a href="#lua_yield"><code>lua_yield</code></a> に渡されたすべての値、
または本体の関数が返したすべての値が積まれています。
コルーチンが中断した場合は <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> を返します。
コルーチンがエラーを発生せずに実行終了した場合は <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> を返します。
エラーが発生した場合はエラーコードを返します (<a href="#lua_pcall"><code>lua_pcall</code></a> を参照)。


<p>
エラーが発生した場合、 スタックは巻き戻されないので、 デバッグ API を使って調べることができます。
エラーメッセージがスタックトップに置かれています。


<p>
コルーチンを再開するには、 <code>yield</code> から返す戻り値の値だけをスタックに積み、
<a href="#lua_resume"><code>lua_resume</code></a> を呼びます。


<p>
引数 <code>from</code> は <code>L</code> を再開させる側のコルーチンを表します。
そのようなコルーチンがない場合は <code>NULL</code> を指定できます。





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
指定したステートのアロケータ関数を <code>f</code> と <code>ud</code> に変更します。





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
<code>t[k] = v</code> と同等のことを行います。
ただし <code>t</code> は指定した有効なインデックスの値で、
<code>v</code> はスタックトップの値です。


<p>
値はスタックから取り除かれます。
Lua 内で実行する場合と同様に、 "newindex" イベントのメタメソッドを呼ぶ場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
スタックから値を取り除き、 その値をグローバル変数 <code>name</code> の新しい値として設定します。
これはマクロとして定義されています。





<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>

<p>
スタックからテーブルを取り除き、 そのテーブルを指定した受け入れ可能なインデックスの値の新しいメタテーブルとして設定します。





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
<code>t[k] = v</code> と同等のことを行います。
ただし <code>t</code> は指定した有効なインデックスの値で、
<code>v</code> はスタックトップの値で、
<code>k</code> はトップのひとつ下の値です。


<p>
キーと値は両方ともスタックから取り除かれます。
Lua 内で実行する場合と同様に、 "newindex" イベントのメタメソッドを呼ぶ場合があります
(<a href="#2.4">&sect;2.4</a> を参照)。





<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
任意の受け入れ可能なインデックスまたは 0 を受け取り、 スタックトップをそのインデックスに設定します。
新しいトップが現在よりも大きければ、 新しい要素は <b>nil</b> で埋められます。
<code>index</code> が 0 の場合は、 すべてのスタック要素が取り除かれます。





<hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>

<p>
テーブルまたは <b>nil</b> をスタックから取り除き、 その値を指定したインデックスのユーザーデータに関連付ける新しい値として設定します。





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
Lua インタプリタの全状態を管理する不透明な構造体です。
Lua のライブラリは完全に再入可能です。
つまりグローバル変数は使っていません。
ステートに関するすべての情報はこの構造体内で管理されます。


<p>
Lua ステートを無から作成する <a href="#lua_newstate"><code>lua_newstate</code></a> を除いて、
このライブラリのすべての関数の最初の引数として、 このステートへのポインタを渡さなければなりません。





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
スレッド <code>L</code> の状態を返します。


<p>
通常のスレッドの場合は、 0 (<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>) を返します。
スレッドがエラーを発生して <a href="#lua_resume"><code>lua_resume</code></a> の実行を終了した場合は、 エラーコードを返します。
スレッドが中断している場合は <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> を返します。


<p>
状態 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> のスレッドに限り関数を呼ぶことができます。
状態 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> または <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> のスレッドは再開することができます。





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値を C のブーリアン値 (0 または 1) に変換します。
Lua 内での条件式と同様に、
<a href="#lua_toboolean"><code>lua_toboolean</code></a> は <b>false</b> および <b>nil</b> 以外のすべての値に対して真を返します。
そうでなければ偽を返します。
インデックスが有効でない場合も偽を返します。
(実際のブーリアン値のみを受け付けたい場合は、
<a href="#lua_isboolean"><code>lua_isboolean</code></a> を使って値の型を調べてください。)





<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値を C の関数に変換します。
この値は C の関数でなければなりません。
そうでなければ <code>NULL</code> を返します。





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
<code>isnum</code> に <code>NULL</code> を指定した場合の
<a href="#lua_tointegerx"><code>lua_tointegerx</code></a>
と同等です。





<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
指定した受け入れ可能なインデックスの Lua の値を
<a href="#lua_Integer"><code>lua_Integer</code></a> 型の符号付き整数に変換します。
この Lua の値は数値か、 数値に変換可能な文字列でなければなりません
(<a href="#3.4.2">&sect;3.4.2</a> を参照)。
そうでない場合、 <a href="#lua_tointegerx"><code>lua_tointegerx</code></a> は 0 を返します。


<p>
数値が整数でなければ、 何らかの適当な方法で丸められます。


<p>
<code>isnum</code> が <code>NULL</code> でなければ、
その参照先に操作が成功したかどうかを示すブーリアン値が代入されます。





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
指定した受け入れ可能なインデックスの Lua の値を C の文字列に変換します。
<code>len</code> が <code>NULL</code> でなければ、
文字列の長さが <code>*len</code> に設定されます。
その Lua の値は文字列か数値でなければなりません。
そうでなければ、 <code>NULL</code> を返します。
値が数値の場合、
<code>lua_tolstring</code> は、
<em>スタック内の実際の値を文字列に変換します</em>。
(テーブル巡回中のキーに対して
<a href="#lua_tolstring"><code>lua_tolstring</code></a>
を適用すると、 この変換が <code>lua_tolstring</code> を混乱させてしまいます。)


<p>
<code>lua_tolstring</code>
は Lua ステート内部の文字列への完全にアラインメントされたポインタを返します。
この文字列は (C で行われるように) 最後の文字の後ろに常にゼロ ('<code>\0</code>') が付きますが、
途中にゼロを含む場合もあります。
Lua はガベージコレクションを行うため、 対応する値をスタックから取り除いた後は
<code>lua_tolstring</code>
から返されたポインタが有効である保証がなくなります。





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
<code>isnum</code> に <code>NULL</code> を指定した場合の
<a href="#lua_tonumberx"><code>lua_tonumberx</code></a>
と同等です。





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
指定した受け入れ可能なインデックスの Lua の値を C の <a href="#lua_Number"><code>lua_Number</code></a> 型に変換します
(<a href="#lua_Number"><code>lua_Number</code></a> を参照)。
この Lua の値は数値または数値に変換可能な文字列でなければなりません
(<a href="#3.4.2">&sect;3.4.2</a> を参照)。
そうでなければ <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> は 0 を返します。


<p>
<code>isnum</code> が <code>NULL</code> でなければ、
その参照先に操作が成功したかどうかを示すブーリアン値が代入されます。





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値を汎用の C のポインタ (<code>void*</code>) に変換します。
この値にはユーザーデータ、 テーブル、 スレッド、 関数が使用できます。
それ以外の場合は <code>NULL</code> を返します。
異なるオブジェクトに対しては異なるポインタを返します。
ポインタから値に戻す方法はありません。


<p>
この関数は通常、 デバッグ情報のためだけに使われます。





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
<code>len</code> に <code>NULL</code> を指定した場合の <a href="#lua_tolstring"><code>lua_tolstring</code></a> と同等です。





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値を Lua のスレッド
(<code>lua_State*</code> で表されます)
に変換します。
この値はスレッドでなければなりません。
そうでなければ <code>NULL</code> を返します。





<hr><h3><a name="lua_tounsigned"><code>lua_tounsigned</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Unsigned lua_tounsigned (lua_State *L, int index);</pre>

<p>
<code>isnum</code> に <code>NULL</code> を指定した場合の
<a href="#lua_tounsignedx"><code>lua_tounsignedx</code></a> と同等です。





<hr><h3><a name="lua_tounsignedx"><code>lua_tounsignedx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Unsigned lua_tounsignedx (lua_State *L, int index, int *isnum);</pre>

<p>
指定した受け入れ可能なインデックスの値を
符号なし整数型 <a href="#lua_Unsigned"><code>lua_Unsigned</code></a> に変換します。
この Lua の値は数値または数値に変換可能な文字列でなければなりません
(<a href="#3.4.2">&sect;3.4.2</a> を参照)。
そうでなければ 0 を返します。


<p>
数値が整数でなければ、 何らかの適当な方法で丸められます。
数値が表現可能な値の範囲外の場合は、 表現可能な最大値+1 で割った余りに正規化されます。


<p>
<code>isnum</code> が <code>NULL</code> でなければ、
その参照先に操作が成功したかどうかを示すブーリアン値が代入されます。





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値がフルユーザーデータの場合は、 そのブロックのアドレスを返します。
その値がライトユーザーデータの場合は、 そのポインタを返します。
それ以外の場合は <code>NULL</code> を返します。





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値の型を返します。
有効なインデックスでない場合は、 <code>LUA_TNONE</code> を返します。
<a href="#lua_type"><code>lua_type</code></a> が返す型は <code>lua.h</code> で定義されている以下の定数のいずれかです。
<ul>
<li><a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>
<li><a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>
<li><a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>
<li><a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>
<li><a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>
<li><a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>
<li><a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>
<li><a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>
<li><a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>
</ul>





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename  (lua_State *L, int tp);</pre>

<p>
値 <code>tp</code> が表す型の名前を返します。
これは <a href="#lua_type"><code>lua_type</code></a> が返す値のいずれかでなければなりません。





<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef unsigned long lua_Unsigned;</pre>

<p>
符号無し整数値を表すために Lua の API で使われる型です。
少なくとも 32 ビット以上はあります。


<p>
デフォルトではこれは <code>unsigned int</code> または <code>unsigned long</code>
のどちらか 32 ビットの値を保持できる方です。





<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>

<p>
Lua コア内のバージョン番号を格納しているアドレスを返します。
有効な <a href="#lua_State"><code>lua_State</code></a> を指定した場合は、
そのステートを作成するのに使われたバージョンのアドレスを返します。
<code>NULL</code> を指定した場合は、
呼び出しを実行したバージョンのアドレスを返します。





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
<a href="#lua_dump"><code>lua_dump</code></a> で使うライター関数の型です。
新しいチャンク片が生成されるたびに書き込むべきバッファ
(<code>p</code>) 、 そのサイズ (<code>sz</code>)、
および <a href="#lua_dump"><code>lua_dump</code></a> に指定した <code>data</code> 引数
を渡されて <a href="#lua_dump"><code>lua_dump</code></a> から呼ばれます。


<p>
ライターはエラーコードを返します。
0 はエラーなしを表します。
それ以外の値はすべてエラーを表し、 <a href="#lua_dump"><code>lua_dump</code></a> がそれ以上ライターを呼ぶのを止させます。





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
同じステートを共有する異なるスレッド間で値を交換します。


<p>
<code>from</code> のスタックから <code>n</code> 個の値が取り除かれ、
その値が <code>to</code> のスタックに積まれます。





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_yield  (lua_State *L, int nresults);</pre>

<p>
<a href="#lua_yieldk"><code>lua_yieldk</code></a> と同等ですが、 継続を取りません
(<a href="#4.7">&sect;4.7</a> を参照)。
そのため、 スレッドが再開すると
<code>lua_yield</code> を呼んだ関数を呼んだ関数に戻ります。





<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_yieldk  (lua_State *L, int nresults, int ctx, lua_CFunction k);</pre>

<p>
コルーチンを中断します。


<p>
この関数は以下のように C の関数の return 式としてのみ呼ぶべきです。

<pre>
     return lua_yieldk (L, n, i, k);
</pre><p>
この方法で C の関数が <a href="#lua_yieldk"><code>lua_yieldk</code></a> を呼ぶと、
実行中のスレッドは実行を中断し、
このコルーチンを開始した <a href="#lua_resume"><code>lua_resume</code></a> の呼び出しから戻ります。
引数 <code>nresults</code> はスタック上の値の数を指定します。
これらの値は <a href="#lua_resume"><code>lua_resume</code></a> から返される戻り値になります。


<p>
コルーチンが再び再開するとき、
Lua は指定した継続関数 <code>k</code> を呼び、 中断した C の関数の実行を継続します (<a href="#4.7">&sect;4.7</a> を参照)。
この継続関数は前の関数から同じスタックを受け取ります。
ただし戻り値は取り除かれ、 <a href="#lua_resume"><code>lua_resume</code></a> に渡された引数に置き換えられます。
さらに、 継続関数は <a href="#lua_getctx"><code>lua_getctx</code></a> を呼ぶことによって値 <code>ctx</code> にアクセスできます。







<h2>4.9 &ndash; <a name="4.9">デバッグインタフェイス</a></h2>

<p>
Lua には組み込みのデバッグ機能はありません。
代わりに、 関数と <em>フック</em> による特殊なインタフェイスを提供しています。
このインタフェイスを使うと、 インタプリタの「内部情報」を必要とする様々な種類のデバッガやプロファイラ、 その他のツールを組み立てることができます。



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues の略 */
  unsigned char nparams;      /* (u) number of parameters の略 */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* プライベート部分 */
  <em>その他のフィールド</em>
} lua_Debug;</pre>

<p>
関数またはアクティベーションレコードに関する様々な情報の断片を保持するために使う構造体です。
<a href="#lua_getstack"><code>lua_getstack</code></a> 関数は後の利用のためにこの構造体のプライベート部分だけをセットします。
<a href="#lua_Debug"><code>lua_Debug</code></a> の他の部分に有益な情報をセットするには、 <a href="#lua_getinfo"><code>lua_getinfo</code></a> を呼んでください。


<p>
<a href="#lua_Debug"><code>lua_Debug</code></a> のフィールドは以下のような意味を持っています。

<ul>

<li><b><code>source</code>: </b>
その関数を作成したチャンクのソースです。
<code>source</code> が '<code>@</code>' で始まっている場合は、
関数は '<code>@</code>' に続く名前のファイルで定義されたことを表しています。
<code>source</code> が '<code>=</code>' で始まっている場合は、
残りの部分はユーザー依存の作法によるそのソースの記述です。
それ以外の場合は、 文字列によって定義された関数で、 <code>source</code> はその文字列です。
</li>

<li><b><code>short_src</code>: </b>
エラーメッセージで使用するための、 表示に適したバージョンの <code>source</code> です。
</li>

<li><b><code>linedefined</code>: </b>
その関数の定義が始まる行番号です。
</li>

<li><b><code>lastlinedefined</code>: </b>
その関数の定義が終わる行番号です。
</li>

<li><b><code>what</code>: </b>
その関数が Lua の関数の場合は、 文字列 <code>"Lua"</code> です。
C の関数の場合は、 <code>"C"</code> です。
チャンクのメイン部分の場合は、 <code>"main"</code> です。
</li>

<li><b><code>currentline</code>: </b>
その関数が実行中の現在の行です。
行番号情報が利用できない場合は -1 に設定されます。
</li>

<li><b><code>name</code>: </b>
その関数の適当な名前です。
Lua の関数はファーストクラスの値であるため、 固定の名前がありません。
複数のグローバル変数に代入される関数もあれば、
テーブルフィールドにのみ格納される関数もあります。
<code>lua_getinfo</code> 関数は、 その関数がどのように呼ばれたかを調べ、 良さそうな名前を探します。
名前を見つけられない場合は <code>NULL</code> に設定されます。
</li>

<li><b><code>namewhat</code>: </b>
<code>name</code> フィールドの説明です。
この値はその関数がどのように呼ばれたかに応じて、 以下のいずれかになります。
<ul>
<li><code>"global"</code>
<li><code>"local"</code>
<li><code>"method"</code>
<li><code>"field"</code>
<li><code>"upvalue"</code>
<li><code>""</code> (空文字列)
</ul>
(空文字列は適用できそうなものが他にない場合に使われます。)
</li>

<li><b><code>istailcall</code>: </b>
この関数が末尾呼び出しによって呼ばれた場合 true になります。
この場合、 このレベルの呼び出し元はスタックに存在しません。
</li>

<li><b><code>nups</code>: </b>
その関数の上位値の数です。
</li>

<li><b><code>nparams</code>: </b>
その関数の固定引数の数です
(C の関数では常に 0 になります)。
</li>

<li><b><code>isvararg</code>: </b>
その関数が可変長引数の場合、 真です
(C の関数では常に真になります)。
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
現在のフック関数を返します。





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
現在のフックカウントを返します。





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
現在のフックマスクを返します。





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>m</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
特定の関数または関数呼び出しに関する情報を返します。


<p>
関数呼び出しに関する情報を得るには、 引数 <code>ar</code> は、
直前の <a href="#lua_getstack"><code>lua_getstack</code></a> の呼び出しによって埋められたか、 またはフック
(<a href="#lua_Hook"><code>lua_Hook</code></a> を参照)
に引数として渡された有効なアクティベーションレコードを保持していなければなりません。


<p>
関数に関する情報を得るには、
その関数をスタックに積み、 <code>what</code> に '<code>&gt;</code>' で始まる文字列を指定します
(この場合、 <code>lua_getinfo</code> はスタックトップからその関数を取り除きます。)
例えば、 関数 <code>f</code> が定義された行を知るには、 以下のようなコードを書きます。

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* グローバル変数 'f' を取得 */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
文字列 <code>what</code> 内の文字に応じて、
<code>ar</code> 構造体のフィールドを設定したりスタックに値を積んだりします。

<ul>

<li><b>'<code>n</code>': </b> フィールド <code>name</code> と <code>namewhat</code> を設定します。
</li>

<li><b>'<code>S</code>': </b>
フィールド <code>source</code>、 <code>short_src</code>、
<code>linedefined</code>、 <code>lastlinedefined</code> および <code>what</code> を設定します。
</li>

<li><b>'<code>l</code>': </b> フィールド <code>currentline</code> を設定します。
</li>

<li><b>'<code>t</code>': </b> フィールド <code>istailcall</code> を設定します。
</li>

<li><b>'<code>u</code>': </b>
フィールド <code>nups</code>、 <code>nparams</code> および <code>isvararg</code> を設定します。
</li>

<li><b>'<code>f</code>': </b>
指定したレベルで実行中の関数をスタックに積みます。
</li>

<li><b>'<code>L</code>': </b>
関数内の有効な行番号のインデックスを持つテーブルをスタックに積みます
(<em>有効な行</em> とは、 何らかのコードに関連付いている行のことで、
つまり、 ブレークポイントを置くことができる場所のことです。
有効でない行は、 例えば空行やコメントなどです。)
</li>

</ul>

<p>
エラーが発生すると 0 を返します
(例えば <code>what</code> に無効なオプションを指定した場合)。





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, lua_Debug *ar, int n);</pre>

<p>
指定したアクティベーションレコードまたは指定した関数のローカル関数に関する情報を取得します。


<p>
最初のケースでは、 引数 <code>ar</code> は
直前の <a href="#lua_getstack"><code>lua_getstack</code></a> の呼び出しによって設定されたか、 またはフック
(<a href="#lua_Hook"><code>lua_Hook</code></a> を参照)
に引数として渡された有効なアクティベーションレコードでなければなりません。
インデックス <code>n</code> は調査するローカル変数を選択します。
変数のインデックスと名前についての詳細は
<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> を参照してください。


<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a>
はその変数の値をスタックに積み、 その名前を返します。


<p>
2 番目のケースでは、 <code>ar</code> は <code>NULL</code> とし、
調査する関数をスタックトップに置かなければなりません。
この場合、 Lua の関数の引数のみが見え
(どの変数がアクティブかについての情報はありません)、
スタックに値は積まれません。


<p>
指定したインデックスがアクティブなローカル変数の数よりも大きい場合は <code>NULL</code> を返します
(また、 何も積みません)。





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
インタプリタのランタイムスタックに関する情報を取得します。


<p>
<a href="#lua_Debug"><code>lua_Debug</code></a> 構造体の一部を、
指定したレベルで実行中の関数の <em>アクティベーションレコード</em> で埋めます。
レベル 0 は現在実行中の関数で、
レベル <em>n+1</em> はレベル <em>n</em> を呼んだ関数です
(ただし末尾呼び出しを除きます。 この場合はスタックをカウントしません。)
エラーがない場合は <a href="#lua_getstack"><code>lua_getstack</code></a> は 1 を返します。
指定したレベルがスタックの深さより大きい場合は 0 を返します。





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
クロージャの上位値に関する情報を取得します。
(Lua の関数では、 上位値はその関数が使う外部ローカル変数で、 そのためクロージャに取り込まれています。)
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> は上位値のインデックス <code>n</code> を取り、
その上位値の値をスタックに積み、 その名前を返します。
<code>funcindex</code> はスタック中のそのクロージャを指定します
(上位値はその関数全体を通してアクティブであり、 特定の順番がありません。
そのため、 アルファベット順に番号が付けられています。)


<p>
指定したインデックスが上位値の数よりも大きい場合は <code>NULL</code> を返します
(また、 何も積みません)。
C の関数に対しては、 上位値の名前はすべて空文字列 <code>""</code> になります。





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
デバッグフック関数の型です。


<p>
フックが呼ばれるとき、
引数 <code>ar</code> のフィールド <code>event</code> にフックのきっかけとなったイベントの種類が設定されます。
Lua はこれらのイベントを以下の定数で識別します。
<ul>
<li><a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>
<li><a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>
<li><a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>
<li><a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>
<li><a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>
</ul>
<p>
さらに、 line イベントの場合はフィールド <code>currentline</code> も設定されます。
<code>ar</code> の他のフィールドの値を取得するには、
<a href="#lua_getinfo"><code>lua_getinfo</code></a> を呼んでください。


<p>
call イベントの場合、 通常は <code>event</code> が <code>LUA_HOOKCALL</code> になり、
末尾呼び出しでは <code>LUA_HOOKTAILCALL</code> になります。
この場合、 対応する return イベントはありません。


<p>
フックを実行している間は、 他のフックの呼び出しは無効化されます。
そのため、 フックから関数やチャンクを実行するために Lua を呼ぶと、
それは一切フックを呼ばずに実行されます。





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
デバッグフック関数を設定します。


<p>
引数 <code>f</code> はフック関数です。
<code>mask</code> はフックが呼ばれるきっかけとなるイベントを指定します。
以下の定数のビット和を指定することができます。
<ul>
<li><a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>
<li><a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>
<li><a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>
<li><a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>
</ul>
<p>
<code>count</code> 引数はマスクが <code>LUA_MASKCOUNT</code> を含む場合だけ意味を持ちます。
それぞれのイベントについて、 フックは以下で説明するときに呼ばれます。

<ul>

<li><b>call フック: </b>
インタプリタが関数を呼び出したときに呼ばれます。
このフックは Lua が新しい関数に入った直後、 引数を受け取る前に呼ばれます。
</li>

<li><b>return フック: </b>
インタプリタが関数から戻るときに呼ばれます。
このフックは Lua が関数から出る直前に呼ばれます。
関数から返される戻り値にアクセスする標準的な方法はありません。
</li>

<li><b>line フック: </b>
インタプリタがコードの新しい行の実行を開始するとき、
またはコードを逆方向にジャンプするとき (同じ行でも) に呼ばれます。
(このイベントは Lua の関数を実行している間だけ発生します。)
</li>

<li><b>count フック: </b>
インタプリタが <code>count</code> 個の命令を実行するたびに呼ばれます。
(このイベントは Lua の関数を実行している間だけ発生します。)
</li>

</ul>

<p>
<code>mask</code> をゼロに設定するとフックは無効になります。





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, lua_Debug *ar, int n);</pre>

<p>
指定したアクティベーションレコードのローカル変数の値を設定します。
引数 <code>ar</code> および <code>n</code> は <a href="#lua_getlocal"><code>lua_getlocal</code></a> と同様です
(<a href="#lua_getlocal"><code>lua_getlocal</code></a> を参照)。
<a href="#lua_setlocal"><code>lua_setlocal</code></a> はスタックトップの値をその変数に代入し、 その名前を返します。
スタックトップの値は取り除かれます。


<p>
インデックスがアクティブなローカル変数の数よりも大きい場合は <code>NULL</code> を返します
(また、 何も積みません)。





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
クロージャの上位値の値を設定します。
スタックトップの値を上位値に代入し、 その名前を返します。
スタックトップの値は取り除かれます。
引数 <code>funcindex</code> および <code>n</code> は <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> と同様です
(<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> を参照)。


<p>
インデックスが上位値の数より大きい場合は <code>NULL</code> を返します
(また、 何も積みません)。





<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
インデックス <code>fidx</code> のクロージャの <code>n</code> 番目の上位値に対する一意な ID を返します。
引数 <code>funcindex</code> および <code>n</code> は <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> と同様です
(<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> を参照)
(ただし <code>n</code> は上位値の数より大きくてはいけません)。


<p>
この一意な識別子を使うと異なるクロージャが上位値を共有しているかどうか確認しることができます。
上位値を共有する
(つまり同じ外部ローカル変数にアクセスする)
Lua のクロージャは、 これらの上位値のインデックスに対して同じ ID を返します。





<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3>
<pre>void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
                                    int fidx2, int n2);</pre>

<p>
インデックス <code>fidx1</code> の Lua のクロージャの <code>n1</code> 番目の上位値が
インデックス <code>fidx2</code> の Lua のクロージャの <code>n2</code> 番目の上位値を参照するようにします。







<h1>5 &ndash; <a name="5">補助ライブラリ</a></h1>

<p>

<em>補助ライブラリ</em> は C と Lua がやりとりするための数々の便利な関数を提供します。
基本 API は C と Lua の間でやりとりするために必要な基本的な関数をすべて提供していますが、 補助ライブラリはいくつかの共通の処理のためにより高水準な関数を提供しています。


<p>
補助ライブラリの関数と型はすべて、 ヘッダファイル <code>lauxlib.h</code> で定義され、 プレフィクス <code>luaL_</code> が付いています。


<p>
補助ライブラリの関数はすべて、 基本 API の上に構築されています。
そのため、 基本 API でできないことは何もありません。
とはいえ、 補助ライブラリを使うとコードの一貫性を高められます。


<p>
補助ライブラリのいくつかの関数は、 いくつか追加のスタックスロットを内部的に使用します。
補助ライブラリの関数が使うスロットが 5 個未満のときは、 スタックサイズはチェックしていません。
充分なスロットがあるだろうと想定しています。


<p>
補助ライブラリのいくつかの関数は、 C の関数の引数をチェックするために使うことができます。
エラーメッセージは引数によってフォーマットされるため
(例えば "<code>bad argument #1</code>")、
他のスタックの値をチェックするためにこれらの関数を使うべきではないでしょう。


<p>
<code>luaL_check*</code> という名前の関数は、 チェック条件が満たされないときは常にエラーを発生させます。



<h2>5.1 &ndash; <a name="5.1">関数と型</a></h2>

<p>
以下に補助ライブラリのすべての関数と型をアルファベット順に掲載します。



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
バイト <code>c</code> をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。





<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
<code>s</code> が指す長さ <code>l</code> の文字列をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。
文字列は埋め込まれたゼロを含むことができます。





<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
バッファエリアにあらかじめコピーされた長さ <code>n</code> の文字列をバッファ <code>B</code> に追加します
(<a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a> を参照)。





<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
<code>s</code> が指すゼロ終端文字列をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。
この文字列は埋め込まれたゼロを含むことができません。





<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +?, <em>m</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
スタックトップの値をバッファ <code>B</code> に追加します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。
その値はスタックから取り除かれます。


<p>
これはスタック上の要素を用いて値をバッファに追加する唯一の文字列バッファ関数です。





<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int narg,
                    const char *extramsg);</pre>

<p>
<code>cond</code> が真かどうか確認します。
もしそうでなければ、 標準的なメッセージのエラーを発生させます。




<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int narg, const char *extramsg);</pre>

<p>
コメントとして <code>extramsg</code> を含む標準的なメッセージのエラーを発生させます。


<p>
この関数は決して戻りませんが、
慣例により、 C の関数内で <code>return luaL_argerror(<em>args</em>)</code> のように使います。





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
<em>文字列バッファ</em> の型です。


<p>
文字列バッファを使うと C のコードで Lua の文字列を段階的に構築することができます。
使い方を以下に示します。

<ul>

<li>
まず <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 型の変数 <code>b</code> を宣言します。
</li>

<li>
次にそれを <code>luaL_buffinit(L, &amp;b)</code> で初期化します。
</li>

<li>
それから <code>luaL_add*</code> 系の関数を好きなように使って文字列片をバッファに追加していきます。
</li>

<li>
最後に <code>luaL_pushresult(&amp;b)</code> を呼びます。
これによって最終的な文字列がスタックトップに残されます。
</li>

</ul>

<p>
結果の文字列の合計サイズがあらかじめ判っているなら、
以下のようにバッファを使うことができます。

<ul>

<li>
まず <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 型の変数 <code>b</code> を宣言します。
</li>

<li>
次に <code>luaL_buffinitsize(L, &amp;b, sz)</code> を呼んで初期化し
サイズ <code>sz</code> の空間を事前確保します。
</li>

<li>
それからその空間に文字列をコピーします。
</li>

<li>
最後に <code>luaL_pushresult(&amp;b, sz)</code> を呼びます。
<code>sz</code> はその空間にコピーした結果の文字列の合計サイズです。
</li>

</ul>

<p>
この操作をしている間、 文字列バッファは不定個のスタックスロットを使用します。
そのため、 バッファを使っている間は、 スタックトップがどこにあるかはわかりません。
バランスが取れていれば、 一連のバッファ操作の間でスタックを使うことができます。
つまり、 バッファ操作を呼ぶときは、 前回バッファ操作をした直後の状態と同じレベルにスタックを戻す必要があります。
(このルールの唯一の例外は <a href="#luaL_addvalue"><code>luaL_addvalue</code></a> です。)
<a href="#luaL_pushresult"><code>luaL_pushresult</code></a> を呼ぶと、 スタックはバッファを初期化したときのレベルに戻り、
その上に結果の文字列が置かれます。





<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
バッファ <code>B</code> を初期化します。
この関数はいかなる空間も割り当てません。
バッファは変数として宣言しなければなりません
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。





<hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>
を呼び、 その後に
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
を呼ぶのと同等です。





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
メタメソッドを呼びます。


<p>
インデックス <code>obj</code> のオブジェクトがメタテーブルを持っており、
そのメタテーブルにフィールド <code>e</code> があれば、
唯一の引数としてそのオブジェクトを渡してそのフィールドを呼びます。
この場合は真を返し、 呼び出しの戻り値がスタックに積まれます。
メタテーブルまたはメタメソッドがなければ、 偽を返します
(スタックには何も積みません)。





<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int narg);</pre>

<p>
<code>narg</code> 番目の引数が存在する (<b>nil</b> を含む) かどうか確認します。





<hr><h3><a name="luaL_checkint"><code>luaL_checkint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkint (lua_State *L, int narg);</pre>

<p>
<code>narg</code> 番目の引数が数値かどうか確認し、 その数値を <code>int</code> にキャストして返します。





<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int narg);</pre>

<p>
<code>narg</code> 番目の引数が数値かどうか確認し、 その数値を <a href="#lua_Integer"><code>lua_Integer</code></a> にキャストして返します。





<hr><h3><a name="luaL_checklong"><code>luaL_checklong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>long luaL_checklong (lua_State *L, int narg);</pre>

<p>
<code>narg</code> 番目の引数が数値かどうか確認し、 その数値を <code>long</code> にキャストして返します。





<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int narg, size_t *l);</pre>

<p>
<code>narg</code> 番目の引数が文字列かどうか確認し、 その文字列を返します。
<code>l</code> が <code>NULL</code> でなければ、 その文字列の長さを <code>*l</code> に格納します。


<p>
結果を得るために <a href="#lua_tolstring"><code>lua_tolstring</code></a> を使うので、
この関数が行う変換や問題点はすべてこちらにも適用されます。





<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int narg);</pre>

<p>
<code>narg</code> 番目の引数が数値かどうか確認し、 その数値を返します。





<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int narg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
<code>narg</code> 番目の引数が文字列かどうか確認し、 この文字列を配列 <code>lst</code> から検索します。
<code>lst</code> は NULL で終わっていなければなりません。
文字列が見つかった場合は、 その配列のインデックスを返します。
引数が文字列でないか、 文字列が見つからなかった場合は、 エラーを発生させます。


<p>
<code>def</code> が <code>NULL</code> でなければ、
<code>narg</code> 番目の引数が存在しないか <b>nil</b> の場合にデフォルト値として使われます。


<p>
この関数は文字列を C の enum に変換するのに便利です
(Lua の一般的な慣例ではオプションを選択するとき数値の代わりに文字列を使います。)





<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
スタックサイズを <code>top + sz</code> 要素に増やします。
スタックをそのサイズに増やせない場合はエラーを発生させます。
<code>msg</code> はエラーメッセージに付け加える追加のテキストです
(追加のテキストが必要なければ <code>NULL</code> を指定できます)。





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int narg);</pre>

<p>
<code>narg</code> 番目の引数が文字列かどうか確認し、 その文字列を返します。


<p>
結果を得るために <a href="#lua_tolstring"><code>lua_tolstring</code></a> を使うので、
この関数が行う変換や問題点はすべてこちらにも適用されます。





<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int narg, int t);</pre>

<p>
<code>narg</code> 番目の引数が型 <code>t</code> かどうか確認します。
<code>t</code> に指定する型コードは <a href="#lua_type"><code>lua_type</code></a> を参照してください。





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int narg, const char *tname);</pre>

<p>
<code>narg</code> 番目の引数が型 <code>tname</code> のユーザーデータかどうか確認し
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> を参照)、
そのユーザーデータのアドレスを返します
(<a href="#lua_touserdata"><code>lua_touserdata</code></a> を参照)。





<hr><h3><a name="luaL_checkunsigned"><code>luaL_checkunsigned</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Unsigned luaL_checkunsigned (lua_State *L, int narg);</pre>

<p>
<code>narg</code> 番目の引数が数値かどうか確認し、 その数値を <a href="#lua_Unsigned"><code>lua_Unsigned</code></a> にキャストして返します。





<hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_checkversion (lua_State *L);</pre>

<p>
呼び出しを行っているコア、
指定した Lua ステートを作成したコア、
および呼び出しを行っているコードがすべて同じバージョンの Lua を使用しているかどうか確認します。
また呼び出しを行っているコアと指定した Lua ステートを作成したコアが同じアドレス空間を使っているかどうかも確認します。





<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>m</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
指定したファイルをロードして実行します。
以下に示すマクロとして定義されています。

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
エラーがなければ偽を返し、
エラーの場合は真を返します。





<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
指定した文字列をロードして実行します。
以下に示すマクロとして定義されています。

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
エラーがなければ偽を返し、
エラーの場合は真を返します。





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
エラーを発生させます。
エラーメッセージは <code>fmt</code> と追加の引数で指定され、
<a href="#lua_pushfstring"><code>lua_pushfstring</code></a> と同じルールに従います。
また、 エラーが発生したファイル名と行番号が判れば、 メッセージの先頭にそれらも追加されます。


<p>
この関数は決して戻りませんが、
慣例により、 C の関数内で <code>return luaL_error(<em>args</em>)</code> のように使います。





<hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>m</em>]</span>
<pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
標準ライブラリのプロセス関連の関数
(<a href="#pdf-os.execute"><code>os.execute</code></a> および <a href="#pdf-io.close"><code>io.close</code></a>)
のための戻り値を生成する関数です。





<hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>m</em>]</span>
<pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
標準ライブラリのファイル関係の関数
(<a href="#pdf-io.open"><code>io.open</code></a>、 <a href="#pdf-os.rename"><code>os.rename</code></a>、 <a href="#pdf-file:seek"><code>file:seek</code></a> など)
のための戻り値を生成する関数です。





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
インデックス <code>obj</code> のオブジェクトのメタテーブルのフィールド <code>e</code> をスタックに積みます。
オブジェクトにメタテーブルがないかメタテーブルにそのフィールドがなければ、 偽を返し、 何も積みません。





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
レジストリ内の名前 <code>tname</code> に関連付けられたメタテーブルをスタックに積みます
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> を参照)。





<hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
値 <code>t[fname]</code> がテーブルであることを保証し、 そのテーブルをスタックに積みます。
ただし <code>t</code> は有効なインデックス <code>idx</code> の値です。
そこにすでにテーブルがあった場合は真を返し、
新しいテーブルを作成した場合は偽を返します。





<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
文字列 <code>s</code> 内に現れる文字列 <code>p</code> をすべて文字列 <code>r</code> に置き換えた文字列を作成します。
その結果の文字列をスタックに積み、 それを返します。





<hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_len (lua_State *L, int index);</pre>

<p>
指定した受け入れ可能なインデックスの値の「長さ」を数値として返します。
Lua の '<code>#</code>' 演算子と同等です (<a href="#3.4.6">&sect;3.4.6</a> を参照)。
この演算の結果が数値でなければエラーを発生します。
(メタメソッドが使われた場合にのみ発生する可能性があります。)





<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
<code>mode</code> に <code>NULL</code> を指定した場合の
<a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a>
と同等です。





<hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
バッファを Lua のチャンクとしてロードします。
この関数は
<a href="#lua_load"><code>lua_load</code></a>
を使って <code>buff</code> が指すサイズ <code>sz</code> のバッファからチャンクをロードします。


<p>
この関数は <a href="#lua_load"><code>lua_load</code></a> と同じ戻り値を返します。
<code>name</code> はチャンクの名前で、 デバッグ情報やエラーメッセージで使われます。
文字列 <code>mode</code> は関数 <a href="#lua_load"><code>lua_load</code></a> と同様に動作します。





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
<code>mode</code> に <code>NULL</code> を指定した場合の
<a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a>
と同等です。





<hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
ファイルを Lua のチャンクとしてロードします。
この関数は
<a href="#lua_load"><code>lua_load</code></a>
を使ってファイル <code>filename</code> からチャンクをロードします。
<code>filename</code> が <code>NULL</code> の場合は標準入力からロードします。
ファイルが <code>#</code> で始まっている場合はその最初の行は無視されます。


<p>
文字列 <code>mode</code> は関数 <a href="#lua_load"><code>lua_load</code></a> と同様に動作します。


<p>
この関数は <a href="#lua_load"><code>lua_load</code></a> と同じ戻り値を返します。
ただしファイルのオープン/読み込みに失敗した場合またはファイルのモードが正しくない場合は
エラーコード <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a> を返します。


<p>
<a href="#lua_load"><code>lua_load</code></a> と同様に
この関数はチャンクをロードするだけで、 実行はしません。





<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
文字列を Lua のチャンクとしてロードします。
この関数は
<a href="#lua_load"><code>lua_load</code></a>
を使ってゼロ終端文字列 <code>s</code> からチャンクをロードします。


<p>
この関数は <a href="#lua_load"><code>lua_load</code></a> と同じ戻り値を返します。


<p>
<a href="#lua_load"><code>lua_load</code></a> と同様に、
この関数もまたチャンクをロードするだけで、 実行はしません。





<hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_newlib (lua_State *L, const luaL_Reg *l);</pre>

<p>
新しいテーブルを作成し、 そこにリスト <code>l</code> 内の関数を登録します。
以下のようなマクロとして実装されています。

<pre>
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre>




<hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
配列 <code>l</code> 内のすべてのエントリを格納するために最適化されたサイズの新しいテーブルを作成します
(ただしエントリを実際に格納はしません)。
これは <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> と一緒に使うことを意図しています
(<a href="#luaL_newlib"><code>luaL_newlib</code></a> を参照)。


<p>
これはマクロとして実装されています。
配列 <code>l</code> は、 ポインタではなく、 実際の配列でなければなりません。





<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
レジストリにキー <code>tname</code> がすでにあれば、 0 を返します。
そうでなければ、 ユーザーデータのメタテーブルとして使うための新しいテーブルを作成し、
レジストリにキー <code>tname</code> でそれを登録し、 1 を返します。


<p>
いずれの場合でも、 レジストリのキー <code>tname</code> に関連付けられた最終的な値がスタックに積まれます。





<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
新しい Lua ステートを作成します。
標準 C の <code>realloc</code> 関数をベースにしたアロケータを使って
<a href="#lua_newstate"><code>lua_newstate</code></a>
を呼び、 また、 致命的なエラー発生した場合に標準エラー出力にエラーメッセージを表示するパニック関数
(<a href="#4.6">&sect;4.6</a> を参照)
を設定します。


<p>
作成した新しいステートを返します。
メモリ割り当てエラーの場合は <code>NULL</code> を返します。





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
指定したステート内にすべての標準 Lua ライブラリを開きます。





<hr><h3><a name="luaL_optint"><code>luaL_optint</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_optint (lua_State *L, int narg, int d);</pre>

<p>
<code>narg</code> 番目の引数が数値であれば、 それを <code>int</code> にキャストした数値を返します。
その引数が存在しないか <b>nil</b> であれば、 <code>d</code> を返します。
いずれでもなければエラーを発生します。





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int narg,
                             lua_Integer d);</pre>

<p>
<code>narg</code> 番目の引数が数値であれば、
それを <a href="#lua_Integer"><code>lua_Integer</code></a> にキャストした数値を返します。
その引数が存在しないか <b>nil</b> であれば、 <code>d</code> を返します。
いずれでもなければエラーを発生します。





<hr><h3><a name="luaL_optlong"><code>luaL_optlong</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>long luaL_optlong (lua_State *L, int narg, long d);</pre>

<p>
<code>narg</code> 番目の引数が数値であれば、 それを <code>long</code> にキャストした数値を返します。
その引数が存在しないか <b>nil</b> であれば、 <code>d</code> を返します。
いずれでもなければエラーを発生します。





<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int narg,
                             const char *d,
                             size_t *l);</pre>

<p>
<code>narg</code> 番目の引数が文字列であれば、 その文字列を返します。
その引数が存在しないか <b>nil</b> であれば、 <code>d</code> を返します。
いずれでもなければエラーを発生します。


<p>
<code>l</code> が <code>NULL</code> でなければ、
結果の長さを <code>*l</code> の位置に格納します。





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number d);</pre>

<p>
<code>narg</code> 番目の引数が数値であれば、 その数値を返します。
その引数が存在しないか <b>nil</b> であれば、 <code>d</code> を返します。
どちらでもなければエラーを発生します。





<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int narg,
                            const char *d);</pre>

<p>
<code>narg</code> 番目の引数が文字列であれば、 その文字列を返します。
その引数が存在しないか <b>nil</b> であれば、 <code>d</code> を返します。
どちらでもなければエラーを発生します。





<hr><h3><a name="luaL_optunsigned"><code>luaL_optunsigned</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Unsigned luaL_optunsigned (lua_State *L,
                               int narg,
                               lua_Unsigned u);</pre>

<p>
<code>narg</code> 番目の引数が数値であれば、
それを <a href="#lua_Unsigned"><code>lua_Unsigned</code></a> にキャストした数値を返します。
その引数が存在しないか <b>nil</b> であれば、 <code>u</code> を返します。
どちらでもなければエラーを発生します。





<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
に定義済みのサイズ
<a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>
を渡した場合と同等です。





<hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
バッファ <code>B</code> へ追加する文字列を格納できるサイズ <code>sz</code> の空間のアドレスを返します
(<a href="#luaL_Buffer"><code>luaL_Buffer</code></a> を参照)。
文字列を実際にバッファに追加するには、 その文字列をこの空間に格納してから、 サイズを引数に
<a href="#luaL_addsize"><code>luaL_addsize</code></a>
を呼んでください。





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
バッファ <code>B</code> の使用を終えて、 最終文字列をスタックトップに残します。





<hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
<a href="#luaL_addsize"><code>luaL_addsize</code></a>
を呼んだ後に
<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>
を呼ぶのと同等です。





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
スタックトップのオブジェクトに対する <em>リファレンス</em> を
インデックス <code>t</code> のテーブルに作成して返します
(オブジェクトはスタックから取り除かれます)。


<p>
リファレンスは一意な整数のキーです。
テーブル <code>t</code> に整数のキーを手動で追加しない限り、
<a href="#luaL_ref"><code>luaL_ref</code></a> が返すキーの一意性が保証されます。
<code>lua_rawgeti(L, t, r)</code> を呼ぶと、 リファレンス <code>r</code> で参照されるオブジェクトを取得できます。
関数 <a href="#luaL_unref"><code>luaL_unref</code></a> でリファレンスとそれに関連付けたオブジェクトを解放します。


<p>
スタックトップのオブジェクトが <b>nil</b> の場合は、
<a href="#luaL_ref"><code>luaL_ref</code></a> は定数
<a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a> を返します。
定数 <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> は、
<a href="#luaL_ref"><code>luaL_ref</code></a> が返すいかなるリファレンスとも異なることが保証されます。





<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
によって登録される関数の配列に使う型です。
<code>name</code> は関数の名前で、 <code>func</code> はその関数へのポインタです。
<a href="#luaL_Reg"><code>luaL_Reg</code></a> の配列はすべて、
<code>name</code> および <code>func</code> が両方 <code>NULL</code> の番兵エントリを最後に置かなければなりません。





<hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
<a href="#pdf-require"><code>require</code></a>
を通して呼ばれたかのように、
文字列 <code>modname</code> を引数として関数 <code>openf</code> を呼び、
その戻り値を <code>package.loaded[modname]</code> に設定します。


<p>
<code>glb</code> が真であれば、 その戻り値をグローバル変数 <code>modname</code> にも格納します。


<p>
その戻り値のコピーをスタックに残します。





<hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>e</em>]</span>
<pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
配列 <code>l</code>
(<a href="#luaL_Reg"><code>luaL_Reg</code></a> を参照)
内のすべての関数をスタックトップ
(にある省略可能な上位値の下)
のテーブルに登録します。


<p>
<code>nup</code> がゼロでなければ、
作成されるすべての関数は、 <code>nup</code> 個の上位値を共有します。
これらの上位値はライブラリテーブルの上にあらかじめ積んでおかなければなりません。
登録後、 これらの値はスタックから取り除かれます。





<hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
スタックトップのオブジェクトのメタテーブルを、
レジストリ内の名前 <code>tname</code> に関連付けられたメタテーブルに設定します
(<a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> を参照)。





<hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void *luaL_testudata (lua_State *L, int narg, const char *tname);</pre>

<p>
<a href="#luaL_checkudata"><code>luaL_checkudata</code></a> と同じ動作をします。
ただし、 判定に失敗したときはエラーを発生する代わりに <code>NULL</code> を返します。





<hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
指定した受け入れ可能なインデックスの任意の Lua の値を適当な書式で C の文字列に変換します。
結果の文字列はスタックに積まれ、 また関数からも返されます。
<code>len</code> が <code>NULL</code> でなければ、
<code>*len</code> にその文字列の長さが格納されます。


<p>
値のメタテーブルに <code>"__tostring"</code> フィールドがあれば、
その値を引数として対応するメタメソッドを呼び、 その戻り値を結果として使用します。





<hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
<code>L1</code> のスタックトレースを作成して積みます。
<code>msg</code> が <code>NULL</code> でなければ、 トレースの先頭に追加されます。
<code>level</code> 引数はトレースを開始するレベルを指定します。





<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
指定したインデックスの値の型の名前を返します。





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
インデックス <code>t</code> のテーブルからリファレンス <code>ref</code> を解放します
(<a href="#luaL_ref"><code>luaL_ref</code></a> を参照)。
そのエントリはテーブルから取り除かれ、 参照されていたオブジェクトはガベージコレクト可能になります。
リファレンス <code>ref</code> も解放され、 再利用されるようになります。


<p>
<code>ref</code> が <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a>
または <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a> の場合は、 何もしません。





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
コールスタックのレベル <code>lvl</code> の制御の現在位置を識別する文字列をスタックに積みます。
通常、 この文字列は以下のような書式です。

<pre>
     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
レベル 0 は実行中の関数で、
レベル 1 は実行中の関数を呼んだ関数で、
以下同様です。


<p>
この関数はエラーメッセージのプレフィクスを構築するために使います。







<h1>6 &ndash; <a name="6">標準ライブラリ</a></h1>

<p>
標準 Lua ライブラリは C の API を使って直接実装されている便利な関数を提供します。
これらの関数には言語に必須のサービスを提供するもの
(例えば <a href="#pdf-type"><code>type</code></a> や <a href="#pdf-getmetatable"><code>getmetatable</code></a>)、
「外部」のサービスへのアクセスを提供するもの (例えば I/O)、
Lua 自身で実装可能ではあるものの非常に有用であるか重大な性能上の理由で C で実装する価値があるもの
(例えば <a href="#pdf-table.sort"><code>table.sort</code></a>)
などがあります。


<p>
すべてのライブラリは公式な C の API を使って実装可能であり、 本体とは別の C のモジュールとして提供されています。
現在、 Lua には以下の標準ライブラリがあります。

<ul>
<li>基本ライブラリ (<a href="#6.1">&sect;6.1</a>)</li>
<li>コルーチンライブラリ (<a href="#6.2">&sect;6.2</a>)</li>
<li>パッケージライブラリ (<a href="#6.3">&sect;6.3</a>)</li>
<li>文字列操作 (<a href="#6.4">&sect;6.4</a>)</li>
<li>テーブル操作 (<a href="#6.5">&sect;6.5</a>)</li>
<li>数学関数 (<a href="#6.6">&sect;6.6</a>) (sin、 log など)</li>
<li>ビット演算 (<a href="#6.7">&sect;6.7</a>)</li>
<li>入出力 (<a href="#6.8">&sect;6.8</a>)</li>
<li>OS機能 (<a href="#6.9">&sect;6.9</a>)</li>
<li>デバッグ機能 (<a href="#6.10">&sect;6.10</a>)</li>

</ul><p>
基本ライブラリとパッケージライブラリを除いて、
各ライブラリはグローバルなテーブルのフィールドとして、
またはそのオブジェクトのメソッドとして、
そのすべての関数を提供しています。


<p>
これらのライブラリにアクセスするためには、
C のホストプログラムで <a href="#luaL_openlibs"><code>luaL_openlibs</code></a> 関数を呼ぶ必要があります。
これはすべての標準ライブラリを開きます。
代わりに、
<a href="#luaL_requiref"><code>luaL_requiref</code></a>
を使って以下の関数を呼ぶことで個別にライブラリを開くこともできます。
<ul>
<li><a name="pdf-luaopen_base"><code>luaopen_base</code></a> (基本ライブラリ)</li>
<li><a name="pdf-luaopen_package"><code>luaopen_package</code></a> (パッケージライブラリ)</li>
<li><a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> (コルーチンライブラリ)</li>
<li><a name="pdf-luaopen_string"><code>luaopen_string</code></a> (文字列ライブラリ)</li>
<li><a name="pdf-luaopen_table"><code>luaopen_table</code></a> (テーブルライブラリ)</li>
<li><a name="pdf-luaopen_math"><code>luaopen_math</code></a> (数学ライブラリ)</li>
<li><a name="pdf-luaopen_bitlib"><code>luaopen_bitlib</code></a> (ビットライブラリ)</li>
<li><a name="pdf-luaopen_io"><code>luaopen_io</code></a> (I/O ライブラリ)</li>
<li><a name="pdf-luaopen_os"><code>luaopen_os</code></a> (オペレーティングシステムライブラリ)</li>
<li><a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> (デバッグライブラリ)</li>
</ul>
<p>
これらの関数は <a name="pdf-lualib.h"><code>lualib.h</code></a> で宣言されています。



<h2>6.1 &ndash; <a name="6.1">基本関数</a></h2>

<p>
基本ライブラリは Lua のコアな機能を提供しています。
アプリケーションにこのライブラリを含めない場合は、
これらの機能の代替品を提供する必要がないか慎重に検討するべきです。


<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>
<p>
引数 <code>v</code> の値が偽 (つまり <b>nil</b> または <b>false</b>) の場合、 エラーを発生します。
そうでなければ、 引数をすべて返します。
<code>message</code> はエラーメッセージです。
省略した場合は、 デフォルトの "assertion failed!" になります。




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
この関数はガベージコレクタへの汎用インタフェイスです。
第 1 引数 <code>opt</code> に応じて様々な機能を実行します。

<ul>

<li><b>"<code>collect</code>": </b>
完全なガベージコレクションサイクルを実行します。
これはデフォルトの選択肢です。
</li>

<li><b>"<code>stop</code>": </b>
ガベージコレクタの自動実行を停止します。
再開するまで、 コレクタは明示的に呼んだときだけ実行します。
</li>

<li><b>"<code>restart</code>": </b>
ガベージコレクタの自動実行を再開します。
</li>

<li><b>"<code>count</code>": </b>
Lua が使用中の合計メモリ (キロバイト) および合計メモリのバイト数を 1024 で割った余りの値を返します。
最初の値は小数部を持っているため、 以下の等式は常に成り立ちます。

<pre>
     k, b = collectgarbage("count")
     assert(k*1024 == math.floor(k)*1024 + b)
</pre><p>
(2 番目の戻り値は、 数値に浮動小数点以外の型を使って Lua をコンパイルした場合に役に立ちます。)
</li>

<li><b>"<code>step</code>": </b>
ガベージコレクションの 1 ステップを実行します。
ステップの「サイズ」は <code>arg</code> で制御します。
大きな値は大きなステップを意味しますが、 具体的には決まっていません。
ステップサイズを制御したければ、 <code>arg</code> の値を実験的に調整する必要があります。
このステップでコレクションサイクルが終わった場合は <b>true</b> を返します。
</li>

<li><b>"<code>setpause</code>": </b>
コレクタの <em>停止期間</em> の新しい値を <code>arg</code> に設定します
(<a href="#2.5">&sect;2.5</a> を参照)。
前の <em>停止期間</em> の値を返します。
</li>

<li><b>"<code>setstepmul</code>": </b>
コレクタの <em>ステップ係数</em> の新しい値を <code>arg</code> に設定します
(<a href="#2.5">&sect;2.5</a> を参照)。
前の <em>ステップ</em> の値を返します。
</li>

<li><b>"<code>isrunning</code>": </b>
コレクタが実行中
(つまり停止中でない)
を示すブーリアンを返します。
</li>

<li><b>"<code>generational</code>": </b>
コレクタを世代別モードに変更します。
これは実験的な機能です (<a href="#2.5">&sect;2.5</a> を参照)。
</li>

<li><b>"<code>incremental</code>": </b>
コレクタをインクリメンタルモードに変更します。
これはデフォルトのモードです。
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
<p>
ファイルを開き、 その内容を Lua のチャンクとして実行します。
引数なしで呼ばれた場合は、
標準入力 (<code>stdin</code>) の内容を実行します。
チャンクが返したすべての値を返します。
エラーが発生した場合、 <code>dofile</code> は呼び出し元にエラーを伝搬します
(つまり、 <code>dofile</code> は保護モードで実行しません)。




<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
<p>
直近の保護されて呼ばれた関数を終了し、 エラーメッセージとして <code>message</code> を返します。
関数 <code>error</code> は決して戻りません。


<p>
通常、 メッセージが文字列の場合は、 メッセージの先頭にエラーの位置についての何らかの情報が追加されます。
引数 <code>level</code> はエラーの位置をどのように得るかを指定します。
レベル 1 (デフォルト) の場合、 エラーの位置は <code>error</code> 関数を呼んだ場所です。
レベル 2 は <code>error</code> を呼んだ関数を呼んだ場所で、 以下同様です。
レベルに 0 を指定するとエラーの位置情報がメッセージに追加されません。




<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
<p>
グローバル環境
(<a href="#2.2">&sect;2.2</a> を参照)
を保持するグローバル変数です (関数ではありません)。
Lua 自身はこの変数を使いません。
この値を変更しても環境には影響を与えず、
その逆も同様です。




<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
<code>object</code> にメタテーブルがなければ <b>nil</b> を返します。
そうでなく、 オブジェクトのメタテーブルに <code>"__metatable"</code> フィールドがあれば、
その関連付けられた値を返します。
そうでなければ、 指定したオブジェクトのメタテーブルを返します。




<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
<code>t</code> にメタメソッド <code>__ipairs</code> があれば、
<code>t</code> を引数としてそれを呼び、 その最初の 3 つの戻り値を返します。


<p>
そうでなければ、 イテレータ関数、 テーブル <code>t</code>、 および 0 の 3 つの値を返します。
したがって、 以下の文は

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
そのテーブルの整数キーが存在しない最初のところまで、 ペア
(<code>1,t[1]</code>)、 (<code>2,t[2]</code>)、 ...
を巡回します。




<p>
<hr><h3><a name="pdf-load"><code>load (ld [, source [, mode [, env]]])</code></a></h3>


<p>
チャンクをロードします。


<p>
<code>ld</code> が文字列の場合は、 チャンクはその文字列です。
<code>ld</code> が関数の場合は、
<code>load</code> はチャンク片を取得するためにその関数を繰り返し呼びます。
<code>ld</code> は文字列を返さなければなりません。
この文字列は前回の戻り値と連結されます。
空文字列または <b>nil</b> を返すか、 何も返さなければ、 チャンクの終わりになります。


<p>
構文エラーがなければ、 コンパイルしたチャンクを関数として返します。
そうでなければ、 <b>nil</b> およびエラーメッセージを返します。


<p>
結果の関数に上位値があれば、 その最初の上位値はグローバル環境の値、
または引数 <code>env</code> が指定されていれば、 その値に設定されます。
メインチャンクをロードする場合、 最初の上位値は <code>_ENV</code> 変数です。
<a href="#2.2">&sect;2.2</a> を参照。


<p>
<code>source</code> はチャンクのソースとして、 エラーメッセージやデバッグ情報のために使われます
(<a href="#4.9">&sect;4.9</a> を参照)。
省略した場合、 <code>ld</code> が文字列であれば、 デフォルトで <code>ld</code> になります。
そうでなければ、"<code>=(load)</code>" になります。


<p>
文字列 <code>mode</code> はチャンクにテキストやバイナリ
(つまりコンパイル済みのチャンク)
を許可するかどうかを指定します。
以下のいずれかを指定できます。
デフォルトは "<code>bt</code>" です。
<ul>
<li>文字列 "<code>b</code>" (バイナリチャンクのみ)</li>
<li>文字列 "<code>t</code>" (テキストチャンクのみ)</li>
<li>文字列 "<code>bt</code>" (バイナリとテキスト両方)</li>
</ul>




<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
<a href="#pdf-load"><code>load</code></a> と同様ですが、
ファイル <code>filename</code> から、 またはファイル名が省略された場合は標準入力から、
チャンクを取得します。




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
テーブルのすべてのフィールドを巡回します。
第 1 引数はテーブルで、 第 2 引数はそのテーブル内のインデックスです。
<code>next</code> はテーブルの次のインデックスとその関連付けられた値を返します。
第 2 引数に <b>nil</b> を指定すると、 最初のインデックスとその関連付けられた値を返します。
最後のインデックスを指定するか、 空のテーブルで <b>nil</b> を指定すると、 <b>nil</b> を返します。
第 2 引数を指定しなかった場合は <b>nil</b> と解釈されます。
例えば、 <code>next(t)</code> を使うとテーブルが空かどうかを調べられます。


<p>
インデックスの列挙の順番は
<em>数値インデックスの場合でさえ</em>
決まっていません。
(数値の順番にテーブルを巡回したい場合は数値用の <b>for</b> 文を使ってください。)


<p>
巡回中にテーブル内の存在しないフィールドに値を代入すると、 <code>next</code> の動作は未定義になります。
ただし既存のフィールドを変更することはできます。
例えば、 既存のフィールドを消去してもかまいません。




<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
<code>t</code> がメタメソッド <code>__pairs</code> を持っていれば、
<code>t</code> を引数としてそれを呼び、 その最初の 3 つの戻り値を返します。


<p>
そうでなければ、
<a href="#pdf-next"><code>next</code></a> 関数、
テーブル <code>t</code>、
および <b>nil</b> の 3 つの値を返します。
そのため、 以下の構文で

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
テーブル <code>t</code> のすべてのキー-値ペアを巡回できます。


<p>
巡回中にテーブルを変更する際の問題点は関数 <a href="#pdf-next"><code>next</code></a> を参照してください。




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
指定した引数を渡して関数 <code>f</code> を <em>保護モード</em> で呼びます。
つまり <code>f</code> の内部で何らかのエラーが発生しても伝搬されず、
代わりに <code>pcall</code> がエラーをキャッチし、 ステータスコードを返します。
最初の戻り値はステータスコード (ブーリアン) で、
呼び出しがエラーを起こさずに成功した場合は真を返します。
その場合、 <code>pcall</code> は最初の戻り値の後に、 その呼び出しからの戻り値をすべて返します。
何らかのエラーが発生した場合、
<code>pcall</code> は <b>false</b> とエラーメッセージを返します。




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
<p>
任意の数の引数を受け取り、 それらの値を
<a href="#pdf-tostring"><code>tostring</code></a>
関数で文字列に変換して <code>stdout</code> に表示します。
<code>print</code> は書式化出力を意図しておらず、
例えばデバッグ用に、 値を表示する簡便な方法として用意されているにすぎません。
出力を完全に制御するには、
<a href="#pdf-string.format"><code>string.format</code></a> および
<a href="#pdf-io.write"><code>io.write</code></a> を使用してください。




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
<p>
メタメソッドを一切呼ばずに、 <code>v1</code> と <code>v2</code> が等しいかどうかを調べます。
ブーリアンを返します。




<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
<p>
メタメソッドを一切呼ばずに、 <code>table[index]</code> の実際の値を取得します。
<code>table</code> はテーブルでなければなりません。
<code>index</code> は任意の値を指定できます。




<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
<p>
メタメソッドを一切呼ばずに、
オブジェクト <code>v</code> の長さを取得します。
<code>v</code> はテーブルまたは文字列でなければなりません。
整数を返します。




<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
<p>
メタメソッドを一切呼ばずに、
<code>table[index]</code> の実際の値を <code>value</code> に設定します。
<code>table</code> はテーブルでなければなりません。
<code>index</code> は <b>nil</b> と NaN 以外の任意の値を指定できます。
<code>value</code> は任意の値を指定できます。


<p>
<code>table</code> を返します。




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
<code>index</code> が数値であれば、
<code>index</code> 番目の引数の後にあるすべての引数を返します。
負のインデックスを指定すると後ろから数えます (-1 は最後の引数です)。
そうでなければ、 <code>index</code> は文字列 <code>"#"</code> でなければならず、
その場合 <code>select</code> は追加の引数の合計数を返します。




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
指定したテーブルにメタテーブルを設定します。
(それ以外の型のメタテーブルは Lua から変更することはできません。 C からのみできます。)
<code>metatable</code> が <b>nil</b> の場合は、
指定したテーブルからメタテーブルを取り除きます。
元のメタテーブルに <code>"__metatable"</code> フィールドがある場合はエラーが発生します。


<p>
<code>table</code> を返します。




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
<code>base</code> を指定せずに呼ぶと、 引数を数値に変換しようと試みます。
引数がすでに数値であるか、 数値に変換可能な文字列
(<a href="#3.4.2">&sect;3.4.2</a> を参照)
であれば、 その数値を返します。
そうでなければ <b>nil</b> を返します。


<p>
<code>base</code> を指定した場合、
<code>e</code> はその基数において整数として解釈可能な文字列でなければなりません。
基数には 2 から 36 までの整数を指定できます。
11 以上の基数の場合は、
'<code>A</code>' が 10 を表し、
'<code>B</code>' が 11 を表し、
以下同様で、
'<code>Z</code>' が 35 を表します
(大文字でも小文字でもかまいません)。
文字列 <code>e</code> が指定した基数において有効な数値でない場合は
<b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
<p>
任意の型の値を受け取り、 それを適当な書式で文字列に変換します。
(数値の変換方法を完全に制御したい場合は
<a href="#pdf-string.format"><code>string.format</code></a> を使用してください。)


<p>
<code>v</code> のメタテーブルに <code>"__tostring"</code> フィールドがあれば、
<code>v</code> を引数にして対応する値が呼ばれ、
その戻り値が結果として使われます。




<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
<p>
引数の型を文字列で表したものを返します。
以下のいずれかの値を返します。
<ul>
<li>"<code>nil</code>" (<b>nil</b> 値ではなく文字列)
<li>"<code>number</code>"
<li>"<code>string</code>"
<li>"<code>boolean</code>"
<li>"<code>table</code>"
<li>"<code>function</code>"
<li>"<code>thread</code>"
<li>"<code>userdata</code>"
</ul>




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
<p>
現在のインタプリタのバージョン文字列を保持しているグローバル変数です (関数ではありません)。
この変数の現在の内容は "<code>Lua 5.2</code>" です。




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
<a href="#pdf-pcall"><code>pcall</code></a> と同様です。
ただし新しいメッセージハンドラ <code>msgh</code> を設定します。







<h2>6.2 &ndash; <a name="6.2">コルーチン操作</a></h2>

<p>
コルーチンに関する操作は基本ライブラリの一部として提供され、 <a name="pdf-coroutine"><code>coroutine</code></a> テーブルに置かれます。
コルーチンの一般的な説明は <a href="#2.6">&sect;2.6</a> を参照してください。


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
本体を <code>f</code> とする新しいコルーチンを作成します。
<code>f</code> は Lua の関数でなければなりません。
この新しいコルーチンである <code>"thread"</code> 型のオブジェクトを返します。




<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>


<p>
コルーチン <code>co</code> の実行を開始または再開します。
コルーチンを初めて resume すると、 その本体の実行を開始します。
値 <code>val1</code>, ... はその本体の関数に引数として渡されます。
コルーチンが中断していた場合は、 それを再開します。
値 <code>val1</code>, ... は yield からの戻り値として渡されます。


<p>
コルーチンがエラーなく実行された場合は、
<b>true</b> および <code>yield</code> に渡されたすべての引数
(コルーチンが中断した場合) または本体の関数から返されたすべての値
(コルーチンが終了した場合) を返します。
エラーが発生した場合は、
<b>false</b> およびエラーメッセージを返します。




<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
実行中のコルーチンおよびブーリアンを返します。
ブーリアンは実行中のコルーチンがメインの場合 true になります。




<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
コルーチン <code>co</code> の状態を文字列として返します。
<ul>
<li><code>"running"</code>: コルーチンが実行中の場合。
<li><code>"suspended"</code>: コルーチンが <code>yield</code> 呼び出しで中断している場合、 またはまだ実行開始していない場合。
<li><code>"normal"</code>: コルーチンはアクティブであるが、 実行中ではない場合
(つまり他のコルーチンを再開した場合)。
<li><code>"dead"</code>: コルーチンが本体の実行を終了した場合、 またはエラーで停止した場合。
</ul>




<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
本体を <code>f</code> とする新しいコルーチンを作成します。
<code>f</code> は Lua の関数でなければなりません。
呼ばれるたびにコルーチンを再開する関数を返します。
この関数に渡された引数はすべて、 <code>resume</code> の追加の引数と同様に動作します。
最初のブーリアンを除いて、 <code>resume</code> の戻り値と同じ値を返します。
エラーが発生した場合はそのエラーを伝搬します。




<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>
呼び出し元のコルーチンの実行を中断します。
<code>yield</code> に渡した引数はすべて、 <code>resume</code> に追加の戻り値として渡されます。







<h2>6.3 &ndash; <a name="6.3">モジュール</a></h2>

<p>
パッケージライブラリは Lua でモジュールをロードするための基本的な機能を提供します。
このパッケージはグローバル環境に直接 <a href="#pdf-require"><code>require</code></a> 関数をエクスポートします。
他のものはすべて <a name="pdf-package"><code>package</code></a> テーブルに置かれます。


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
指定したモジュールをロードします。
<code>modname</code> がロード済みかどうかを知るために、
まずテーブル <a href="#pdf-package.loaded"><code>package.loaded</code></a> を調べます。
もしあれば、 <code>require</code> は <code>package.loaded[modname]</code> に格納されている値を返します。
そうでなければ、 そのモジュールのための <em>ローダー</em> を探します。


<p>
ローダーを探すにあたって、
シーケンス <a href="#pdf-package.searchers"><code>package.searchers</code></a>
がガイドとして用いられます。
このシーケンスを変更すると、 モジュールの探し方を変更できます。
以下の説明は <a href="#pdf-package.searchers"><code>package.searchers</code></a> のデフォルトの構成に基づいています。


<p>
まず <code>package.preload[modname]</code> が調べられます。
その値があった場合は、 その値 (関数であるべきです) がローダーになります。
なかった場合は、
<a href="#pdf-package.path"><code>package.path</code></a>
に格納されているパスを使って Lua のローダーを探します。
それも失敗した場合は、
<a href="#pdf-package.cpath"><code>package.cpath</code></a>
に格納されているパスを使って C のローダーを探します。
それも失敗した場合は、 <em>オールインワン</em> ローダーを試みます
(<a href="#pdf-package.searchers"><code>package.searchers</code></a> を参照)。


<p>
ローダーが見つかると、
<code>modname</code> とローダーを得た方法に依存する追加の値の 2 つを引数として、
そのローダーが呼ばれます
(ローダーがファイル由来の場合、 この追加の値はそのファイル名です)。
ローダーが nil 以外の値を返すと、
その戻り値が <code>package.loaded[modname]</code> に代入されます。
ローダーが nil 以外の値を返さず、
<code>package.loaded[modname]</code> に何も代入されていなければ、
そのエントリに <b>true</b> が代入されます。
いずれの場合でも、 <code>require</code> は
<code>package.loaded[modname]</code> の最終的な値を返します。


<p>
モジュールのロードまたは実行中に何らかのエラーが発生するか、
またはそのモジュールのためのローダーが見つからなければ、
エラーが発生します。




<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
コンパイル時のパッケージの構成を説明する文字列です。
この文字列は以下の一連の行から構成されます。

<ul>

<li>1 行目はディレクトリ区切り文字列です。
デフォルトは、 Windows では '<code>\</code>' で、 他のすべてのシステムでは '<code>/</code>' です。</li>

<li>2 行目はパス中のテンプレートを区切る文字です。
デフォルトは '<code>;</code>' です。</li>

<li>3 行目はテンプレート中の置換ポイントを示す文字列です。
デフォルトは '<code>?</code>' です。</li>

<li>4 行目は実行可能ファイルのディレクトリに置き換えられる、 Windows ではパス中の、 文字列です。
デフォルトは '<code>!</code>' です。</li>

<li>5 行目は <code>luaopen_</code> 関数の名前を構築するときにそれより前のテキストをすべて無視する印です。
デフォルトは '<code>-</code>' です。</li>

</ul>



<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
C のローダーを探すために
<a href="#pdf-require"><code>require</code></a>
が使用するパスです。


<p>
環境変数 <a name="pdf-LUA_CPATH_5_2"><code>LUA_CPATH_5_2</code></a>
または環境変数 <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>
または <code>luaconf.h</code> に定義されているデフォルトのパスを使って、
Lua のパス <a href="#pdf-package.path"><code>package.path</code></a>
を初期化するのと同じ方法で、
C のパス <a href="#pdf-package.cpath"><code>package.cpath</code></a>
は初期化されます。




<p>

<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
モジュールがロード済みであるかどうかを制御するために
<a href="#pdf-require"><code>require</code></a>
が使用するテーブルです。
モジュール <code>modname</code> が require され、
<code>package.loaded[modname]</code> が偽でなければ、
<a href="#pdf-require"><code>require</code></a> は単純にそこに格納されている値を返します。


<p>
この変数は実際のテーブルを参照しているだけです。
この変数に代入しても
<a href="#pdf-require"><code>require</code></a>
が使用するテーブルは変わりません。




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
ホストプログラムを C のライブラリ <code>libname</code> に動的リンクします。


<p>
<code>funcname</code> が "<code>*</code>" の場合は、
単にそのライブラリをリンクし、
ライブラリがエクスポートしているシンボルを他の動的リンクライブラリから利用できるようにするだけです。
そうでなければ、 そのライブラリ内の関数 <code>funcname</code> を探し、
この関数を C の関数として返します。
(そのため、 <code>funcname</code> は
<a href="#lua_CFunction"><code>lua_CFunction</code></a>
のプロトタイプに従わなければなりません。)


<p>
これは低水準な関数です。
パッケージシステムやモジュールシステムを完全に迂回します。
<a href="#pdf-require"><code>require</code></a> と異なり、
パスの検索や拡張子の自動追加は一切行いません。
<code>libname</code> は C のライブラリの完全なファイル名でなければならず、
必要であればパスや拡張子も含めなければなりません。
<code>funcname</code> は C のライブラリがエクスポートする正確な名前でなければなりません
(使用している C コンパイラやリンカに依存する場合があります)。


<p>
この機能は標準 C によってサポートされていません。
そのため、 いくつかのプラットフォーム
(Windows、 Linux、 Mac OS X、 Solaris、 BSD、
および <code>dlfcn</code> 標準をサポートするその他の Unix システム)
でのみ利用可能です。




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
Lua のローダーを探すために
<a href="#pdf-require"><code>require</code></a>
が使用するパスです。


<p>
起動時に、 この変数は環境変数 <a name="pdf-LUA_PATH_5_2"><code>LUA_PATH_5_2</code></a>、
または環境変数 <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a>、
またはこれらの環境変数が定義されていない場合 <code>luaconf.h</code> に定義されているデフォルトのパスで初期化されます。
環境変数の値の中に "<code>;;</code>" があれば、 デフォルトのパスで置き換えられます。




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
特定のモジュール用のローダーを格納するテーブルです
(<a href="#pdf-require"><code>require</code></a> を参照)。


<p>
この変数は実際のテーブルを参照しているだけです。
この変数に代入しても
<a href="#pdf-require"><code>require</code></a>
が使用するテーブルは変わりません。




<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
モジュールのロード方法を制御するために
<a href="#pdf-require"><code>require</code></a>
が使用するテーブルです。


<p>
このテーブルの各エントリは <em>検索関数</em> です。
モジュールを検索するとき、
<a href="#pdf-require"><code>require</code></a>
はモジュール名
(<a href="#pdf-require"><code>require</code></a> に指定した引数)
を引数にしてこれらの各検索関数を昇順で呼びます。
検索関数は別の関数
(モジュールの <em>ローダー</em>)
およびそのローダーに渡される追加の引数、
またはモジュールを見つけられなかった理由を説明する文字列
(または何も言うべきことがなければ <b>nil</b>)
を返すことができます。


<p>
このテーブルは 4 つの検索関数で初期化されます。


<p>
最初の検索関数は単純に
<a href="#pdf-package.preload"><code>package.preload</code></a>
テーブルからローダーを探します。


<p>
2 番目の検索関数は
<a href="#pdf-package.path"><code>package.path</code></a>
に格納されているパスを使った Lua のライブラリとしてのローダーを探します。
この検索は関数
<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>
で説明しているように行われます。


<p>
3 番目の検索関数は変数
<a href="#pdf-package.cpath"><code>package.cpath</code></a>
を使った C のライブラリとしてのローダーを探します。
同様に、 この検索は関数
<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>
で説明しているように行われます。
例えば、 C のパスが以下のような文字列であれば、

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
モジュール <code>foo</code> に対する検索関数は、
ファイル <code>./foo.so</code>、 <code>./foo.dll</code>、 および <code>/usr/local/foo/init.so</code>
のオープンをこの順序で試みます。
C のライブラリが見つかると、
まず動的リンクの機能を使ってそのライブラリをアプリケーションにリンクします。
次にローダーとして使うそのライブラリ内の C の関数を探します。
この C の関数の名前は、 文字列
"<code>luaopen_</code>"
にモジュールの名前の各ドットをアンダースコアで置き換えて連結したものです。
さらに、 モジュールの名前にハイフンがある場合は、
最初のハイフンおよびそれより前にある接頭辞は取り除かれます。
例えば、 モジュールの名前が <code>a.v1-b.c</code> であれば、
関数の名前は <code>luaopen_b_c</code> になります。


<p>
4 番目の検索関数は <em>オールインワンローダー</em> を試みます。
これは指定したモジュールのルート名に対するライブラリを C のパスから探します。
例えば、 <code>a.b.c</code> が要求された場合、
<code>a</code> に対する C のライブラリを検索します。
それが見つかれば、 そのライブラリ内からサブモジュール用のオープン関数を探します。
上の例では、 <code>luaopen_a_b_c</code> になります。
この機能は、 パッケージが複数の C のサブモジュールを、
各サブモジュールそれぞれ独自のオープン関数を維持したまま、
ひとつのライブラリにパックするために使います。


<p>
最初の検索関数 (preload) 以外はすべて、
<a href="#pdf-package.searchpath"><code>package.searchpath</code></a>
が返すのと同様に、 見つかったモジュールのファイル名を追加の値として返します。
最初の検索関数は追加の値を返しません。




<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
指定した <code>path</code> から指定した <code>name</code> を検索します。


<p>
パスはセミコロン区切りの <em>テンプレート</em> 文字列です。
各テンプレートに対して、 テンプレート内の疑問符を、
<code>name</code> 内の各 <code>sep</code> (デフォルトはドット)
をシステムのディレクトリ区切り文字で置き換えたものに置き換え、
そしてその結果のファイル名のオープンを試みます。
<code>sep</code> が空文字列であれば、 その置き換えは行われません。


<p>
例えば、 パスが以下の文字列である場合、

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
名前 <code>foo.a</code> について検索すると、
ファイル
<code>./foo/a.lua</code>、
<code>./foo/a.lc</code>、
<code>/usr/local/foo/a/init.lua</code>
に対して、 この順番でオープンを試みます。


<p>
読み込みモードで開くことのできる最初のファイルの名前を返します
(そのファイルはすぐに閉じます)。
成功しなければ <b>nil</b> およびエラーメッセージを返します
(このエラーメッセージは開こうと試みたすべてのファイル名の一覧です。)







<h2>6.4 &ndash; <a name="6.4">文字列操作</a></h2>

<p>
このライブラリは文字列操作の汎用的な関数を提供します。
検索や部分文字列の抽出、 パターンマッチングなどがあります。
Lua の文字列のインデックスは、 最初の文字が 1 の位置です (C のように 0 ではありません)。
また負のインデックスも使うことができ、
文字列の終わりから逆方向に解釈されます。
つまり最後の文字は -1 の位置で、 以下同様です。


<p>
文字列ライブラリは <a name="pdf-string"><code>string</code></a> テーブルにすべての関数を提供します。
また文字列に対するメタテーブルも設定し、 <code>__index</code> フィールドが <code>string</code> テーブルを指すようにします。
そのため、 文字列をオブジェクト指向のスタイルで扱うことができます。
例えば <code>string.byte(s,i)</code> は <code>s:byte(i)</code> と書くことができます。


<p>
文字列ライブラリはシングルバイトの文字コードを想定しています。


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
<p>
文字
<code>s[i]</code>、 <code>s[i+1]</code>、 ...、 <code>s[j]</code>
の内部の数値コードを返します。
<code>i</code> のデフォルト値は 1、
<code>j</code> のデフォルト値は <code>i</code> です。


<p>
数値コードはプラットフォームを超えられる可搬性があるとは限りません。




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
<p>
0 個以上の整数を受け取り、
対応する引数と同じ内部の数値コードを持つ文字からなる、 引数の数と等しい長さの文字列を返します。


<p>
数値コードはプラットフォームを超えられる可搬性があるとは限りません。




<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function)</code></a></h3>


<p>
指定した関数のバイナリ表現の文字列を返します。
後にこの文字列に対して <a href="#pdf-load"><code>load</code></a> を呼ぶと、
その関数のコピー (ただし新しい上位値を持つ) を得ることができます。




<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>
文字列 <code>s</code> 中の <code>pattern</code> の最初のマッチを検索します。
マッチが見つかった場合、 <code>find</code> はそのマッチした最初と最後を表す <code>s</code> のインデックスを返します。
見つからない場合は <b>nil</b> を返します。
3 番目の省略可能な数値引数 <code>init</code> は、 検索の開始位置を指定します。
デフォルト値は 1 で、 負の値を指定することもできます。
4 番目の省略可能な引数 <code>plain</code> に <b>true</b> を指定すると、
パターンマッチング機能はオフになり、
<code>pattern</code> 内のいかなる文字も魔法の文字とみなされなくなり、
普通の「部分文字列を探す」操作を実行します。
<code>plain</code> を指定する場合は <code>init</code> も指定しなければならないことに注意してください。


<p>
パターンにキャプチャがある場合は、
マッチに成功したとき、
2 つのインデックスの後にキャプチャした値も返されます。




<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>


<p>
最初の引数 (文字列でなければならない) で指定した記述に従って、 可変長引数を書式化したものを返します。
書式文字列は C の関数 <code>sprintf</code> と同様のルールに従います。
ただしオプション/修飾子の
<code>*</code>、 <code>h</code>、 <code>L</code>、 <code>l</code>、 <code>n</code>、
および <code>p</code> はサポートされておらず、
追加のオプション <code>q</code> があります。
<code>q</code> オプションは、 文字列をダブルクォートで囲って書式化します。
このとき、 Lua インタプリタによって安全に読み戻せることを保証するために、 必要な場合はエスケープシーケンスを使います。
例えば、 以下の呼び出しは

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
以下のような文字列を生成します。

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
オプション
<code>A</code> および <code>a</code> (使用可能な場合)、
<code>E</code>、 <code>e</code>、 <code>f</code>、 <code>G</code>
および <code>g</code> はすべて引数として数値を期待します。
オプション <code>c</code>、 <code>d</code>、 <code>i</code>、 <code>o</code>、 <code>u</code>、
<code>X</code> および <code>x</code> もまた引数として数値を期待しますが、
この数値の範囲は基礎となっている C の実装によって制限される場合があります。
オプション <code>o</code>、 <code>u</code>、 <code>X</code> および <code>x</code> は負の値は取れません。
オプション <code>q</code> は文字列を期待し、
オプション <code>s</code> は埋め込まれたを持たない文字列を期待します。
オプション <code>s</code> の引数が文字列でない場合は、
<a href="#pdf-tostring"><code>tostring</code></a> と同じルールに従って文字列に変換します。




<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
<p>
呼ばれるたびに文字列 <code>s</code> 中の <code>pattern</code> から次のキャプチャを返すイテレータ関数を返します。
<code>pattern</code> にキャプチャがなければ、 呼ぶたびにマッチした全体を返します。


<p>
例えば、 以下のループは文字列 <code>s</code> 中のすべての単語について巡回し、
1 行に 1 つ表示するループです。

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
次の例は指定した文字列中のすべての <code>key=value</code> ペアをテーブルに集めます。

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
パターン先頭のキャレット '<code>^</code>' は巡回を妨げるため、 この関数ではアンカーとしては働きません。




<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
<p>
<code>s</code> 中の <code>pattern</code> の出現をすべて
(指定した場合は最初の <code>n</code> 個)
<code>repl</code> で指定した置換文字列に置き換えたものを返します。
<code>repl</code> には文字列、 テーブル、 または関数を指定できます。
また <code>gsub</code> は 2 番目の戻り値としてマッチが出現した合計数も返します。
<code>gsub</code> という名前は <em>Global SUBstitution</em> から来ています。


<p>
<code>repl</code> が文字列の場合は、 その文字列が置換に使われます。
文字 <code>%</code> はエスケープ文字として働きます。
<code>repl</code> 中の <code>%<em>d</em></code>
(ただし <em>d</em> は 1 から 9)
は <em>d</em> 番目のキャプチャした部分文字列の値 (下を参照) を表します。
<code>%0</code> はマッチ全体を表し、
<code>%%</code> は単一の <code>%</code> を表します。


<p>
<code>repl</code> がテーブルの場合は、 各マッチごとに最初のキャプチャをキーとしてテーブルを引きます。
パターンにキャプチャがなければ、 マッチ全体をキーとして使います。


<p>
<code>repl</code> が関数の場合は、 その関数はマッチが現れるたびに呼ばれ、
すべてのキャプチャされた部分文字列が順番通りに引数として渡されます。
パターンにキャプチャがなければ、 マッチ全体が単一の引数として渡されます。


<p>
テーブル検索または関数呼び出しの戻り値が文字列または数値であれば、
それが置換文字列として使われます。
そうでなく、 <b>false</b> または <b>nil</b> であれば、 置換されません
(つまり、 元のマッチがそのまま文字列中に保たれます)。


<p>
以下にいくつか例を示します。

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"

     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"

     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"

     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"

     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"

     local t = {name="lua", version="5.2"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.2.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
<p>
文字列を受け取り、 その長さを返します。
空文字列 <code>""</code> の長さは 0 です。
埋め込まれたゼロもカウントされるので、
<code>"a\000bc\000"</code> の長さは 5 です。




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
<p>
文字列を受け取り、 その文字列中の大文字をすべて小文字に変更した文字列を返します。
それ以外の文字に対しては何もしません。
何が大文字であるかの定義は現在のロケールに依存します。




<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
<p>
文字列 <code>s</code> 中の <code>pattern</code> の最初の <em>マッチ</em> を検索します。
見つかった場合は、 パターン中のキャプチャを返します。
見つからない場合は <b>nil</b> を返します。
<code>pattern</code> にキャプチャがなければ、 マッチ全体が返されます。
3 番目の省略可能な引数 <code>init</code> は検索を開始する場所を指定します。
デフォルト値は 1 で、 負の値も指定できます。




<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
<p>
<code>n</code> 個の文字列 <code>s</code> を区切り文字列 <code>sep</code> で連結した文字列を返します。
<code>sep</code> のデフォルト値は空文字列です
(つまり区切り文字列はありません)。




<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
<p>
文字列 <code>s</code> を反転した文字列を返します。




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
<p>
<code>s</code> の <code>i</code> で始まり <code>j</code> で終わる部分文字列を返します。
<code>i</code> および <code>j</code> には負の値も指定できます。
<code>j</code> を省略した場合は -1
(文字列の長さと同じ)
になります。
例えば、 <code>string.sub(s,1,j)</code> は <code>s</code> の先頭 <code>j</code> 文字を返し、
<code>string.sub(s, -i)</code> は <code>s</code> の最後の <code>i</code> 文字を返します。


<p>
負のインデックスの変換後に <code>i</code> が 1 より小さくなる場合、
<code>i</code> は 1 に修正されます。
<code>j</code> が文字列の長さより大きい場合、
<code>j</code> はその長さに修正されます。
これらの修正後、 <code>i</code> が <code>j</code> より大きくなった場合は、
空文字列を返します。




<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
<p>
文字列を受け取り、 その文字列中の小文字をすべて大文字に変更した文字列を返します。
それ以外の文字に対しては何もしません。
何が小文字であるかの定義は現在のロケールに依存します。



<h3>6.4.1 &ndash; <a name="6.4.1">パターン</a></h3>


<h4>文字クラス:</h4><p>
<p>
<em>文字クラス</em> は文字の集合を表すために使われます。
文字クラスの記述では以下の組み合わせが使用できます。

<ul>

<li><b><em>x</em>: </b>
(ただし <em>x</em> は <em>魔法の文字</em> <code>^$()%.[]*+-?</code> 以外の文字)
文字 <em>x</em> 自身を表します。
</li>

<li><b><code>.</code>: </b> (ドット) すべての文字を表します。</li>

<li><b><code>%a</code>: </b> すべてのレターを表します。</li>

<li><b><code>%c</code>: </b> すべての制御文字を表します。</li>

<li><b><code>%d</code>: </b> すべての数字を表します。</li>

<li><b><code>%g</code>: </b> 空白を除くすべての印刷可能文字を表します。</li>

<li><b><code>%l</code>: </b> すべての小文字を表します。</li>

<li><b><code>%p</code>: </b> すべての句読点を表します。</li>

<li><b><code>%s</code>: </b> すべての空白文字を表します。</li>

<li><b><code>%u</code>: </b> すべての大文字を表します。</li>

<li><b><code>%w</code>: </b> すべての英数字を表します。</li>

<li><b><code>%x</code>: </b> すべての 16 進数字を表します。</li>

<li><b><code>%<em>x</em></code>: </b> (ただし <em>x</em> は英数以外の文字)
文字 <em>x</em> を表します。
これは魔法の文字をエスケープする標準の方法です。
すべての句読点 (魔法でない文字も) は '<code>%</code>' を前置してパターン中でそれ自身を表すことができます。
</li>

<li><b><code>[<em>set</em>]</code>: </b>
<em>set</em> 中のすべての文字の和であるクラスを表します。
'<code>-</code>' を使って文字の範囲を指定することができます。
<em>set</em> 中の部品として上で説明した <code>%</code><em>x</em> クラスもすべて使うことができます。
<em>set</em> 中のそれ以外の文字はすべてそれ自身を表します。
例えば <code>[%w_]</code> (または <code>[_%w]</code>) はすべての英数文字にアンダースコアを加えたものを表し、
<code>[0-7]</code> は 8 進数字を表し、
<code>[0-7%l%-]</code> は 8 進数字に小文字と '<code>-</code>' を加えたものを表します。


<p>
範囲とクラスの間の相互作用は定義されていません。
そのため <code>[%a-z]</code> や <code>[a-%%]</code> のようなパターンは無意味です。
</li>

<li><b><code>[^<em>set</em>]</code>: </b>

<em>set</em> の補集合を表します。
<em>set</em> は上で呼べたように解釈されます。
</li>

</ul><p>
単一の文字で表されるクラス
(<code>%a</code>、 <code>%c</code> など)
はすべて、 対応する大文字でそのクラスの補集合を表します。
例えば、 <code>%S</code> はすべての非空白文字を表します。


<p>
レター、 空白、 およびその他の文字グループの定義は現在のロケールに依存します。
例えば、 クラス <code>[a-z]</code> は <code>%l</code> と同等でない場合があります。





<h4>パターン項目:</h4><p>
<em>パターン項目</em> は以下のいずれかです。

<ul>

<li>
単一の文字クラス。
そのクラスの任意の文字にマッチします。
</li>

<li>
単一の文字クラスに '<code>*</code>' が続いたもの。
そのクラスの文字の 0 回以上の繰り返しにマッチします。
この繰り返し項目は常に最も長い可能なものにマッチします。
</li>

<li>
単一の文字クラスに '<code>+</code>' が続いたもの。
そのクラスの文字の 1 回以上の繰り返しにマッチします。
この繰り返し項目は常に最も長い可能なものにマッチします。
</li>

<li>
単一の文字クラスに '<code>-</code>' が続いたもの。
そのクラスの文字の 0 回以上の繰り返しにマッチします。
'<code>*</code>' と異なり、 この繰り返し項目は最も短い可能なものにマッチします。
</li>

<li>
単一の文字クラスに '<code>?</code>' が続いたもの。
そのクラスの文字の 0 回または 1 回の出現にマッチします。
</li>

<li>
<code>%<em>n</em></code>
(ただし <em>n</em> は 1 から 9)。
この項目は <em>n</em> 番目のキャプチャされた文字列と等しい部分文字列にマッチします
(下を参照)。
</li>

<li>
<code>%b<em>xy</em></code>
(ただし <em>x</em> および <em>y</em> は 2 つの異なる文字)。
この項目は <em>x</em> で始まり <em>y</em> で終わる文字列にマッチします。
<em>x</em> および <em>y</em> は <em>入れ子</em> にできます。
つまり、 文字列を左から右に読む場合、
<em>x</em> が現れたら <em>+1</em>、 <em>y</em> が現れたら <em>-1</em> を数え、
そのカウントが 0 のときの最初の <em>y</em> が終わりの <em>y</em> になります。
例えば、 項目 <code>%b()</code> は対応した括弧で囲まれた式にマッチします。
</li>

<li>
<code>%f[<em>set</em>]</code>
(<em>境界パターン</em>)。
この項目は、 次の文字が <em>set</em> に属し前の文字が <em>set</em> に属さない場所で、 空文字列にマッチします。
集合 <em>set</em> は上で述べたように解釈されます。
対象の先頭および末尾では、 文字 '<code>\0</code>' が存在するかのように扱われます。
</li>

</ul>




<h4>パターン:</h4><p>
<em>パターン</em> はパターン項目の列です。
パターンの先頭にキャレット '<code>^</code>' があると、 対象文字列の先頭にマッチが固定されます。
パターンの最後に '<code>$</code>' があると、 対象文字列の最後にマッチが固定されます。
それ以外の場所では、'<code>^</code>' および '<code>$</code>' は特別な意味を持たず、 それ自身を表します。





<h4>キャプチャ:</h4><p>
パターンは括弧で囲まれた部分パターンを持つことができます。
これらは <em>キャプチャ</em> と呼ばれます。
マッチが成功したとき、 対象文字列のうちキャプチャにマッチした部分文字列が、
後で使うために保存され (<em>キャプチャされ</em>) ます。
キャプチャはその左括弧の出現順に番号が付けられます。
例えば、 パターン <code>"(a*(.)%w(%s*))"</code> では、
<code>"a*(.)%w(%s*)"</code> にマッチした部分文字列は最初のキャプチャ (つまり番号 1) として保存され、
"<code>.</code>" にマッチした文字が番号 2 でキャプチャされ、
"<code>%s*</code>" にマッチした部分が番号 3 になります。


<p>
特殊なケースとして、 空のキャプチャ <code>()</code> は現在位置 (数値) をキャプチャします。
例えば、 文字列 <code>"flaaap"</code> にパターン <code>"()aa()"</code> を適用すると、
2 つのキャプチャ 3 および 5 が得られます。











<h2>6.5 &ndash; <a name="6.5">テーブル操作</a></h2>

<p>
このライブラリはテーブル操作のための汎用の関数を提供します。
すべての関数は <a name="pdf-table"><code>table</code></a> テーブルに提供されます。


<p>
テーブルの長さを扱う操作では、 テーブルは正しいシーケンスであるか、 または <code>__len</code> メタメソッド
(<a href="#3.4.6">&sect;3.4.6</a> を参照) を持っていなければならないことを覚えておいてください。
すべての関数は、 引数として渡されたテーブル内の、 数値以外のキーは無視します。


<p>
性能上の理由により、 これらの関数によって行われるすべてのテーブルアクセス (get および set) は生です。


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>
すべての要素が文字列か数値であるリストを受け取り、
<code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code> を返します。
<code>sep</code> のデフォルト値は空文字列、
<code>i</code> のデフォルト値は 1、
<code>j</code> のデフォルト値は <code>#list</code> です。
<code>i</code> が <code>j</code> より大きい場合は空文字列を返します。




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p>
<code>list</code> の位置 <code>pos</code> に要素 <code>value</code> を挿入し、
要素 <code>list[pos], list[pos+1], &middot;&middot;&middot;, list[#list]</code>
を上へずらします。
<code>pos</code> のデフォルト値は <code>#list+1</code> です。
そのため <code>table.insert(t,x)</code> は <code>x</code> をリスト <code>t</code> の最後に挿入します。




<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>


<p>
すべての引数をキー 1、 2、 (以下略) に格納し、
引数の数をフィールド "<code>n</code>" に格納したテーブルを返します。
返されたテーブルはシーケンスでない場合があります。




<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p>
<code>list</code> から位置 <code>pos</code> の要素を取り除き、
要素 <code>list[pos+1], list[pos+2], &middot;&middot;&middot;, list[#list]</code>
を下へずらし、 要素 <code>list[#list]</code> を消し去ります。
取り除かれた要素の値を返します。
<code>pos</code> のデフォルト値は <code>#list</code> です。
そのため <code>table.remove(t)</code> はリスト <code>t</code> の最後の要素を取り除きます。




<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>
<code>list[1]</code> から <code>list[#list]</code> までのリストの要素を、
<em>その場で</em> 指定した順番にソートします。
<code>comp</code> を指定する場合、
それは 2 つのリスト要素を受け取り、
1 番目の要素が 2 番目の要素よりも最終的に前に来なければならない場合に真を返す、
関数でなければなりません
(そのためソート後は <code>not comp(list[i+1],list[i])</code> が真になります)。
<code>comp</code> を指定しない場合は、
代わりに標準の Lua の演算子 <code>&lt;</code> が使われます。


<p>
ソートのアルゴリズムは安定ではありません。
つまり、 指定した順番において等しいとみなされる要素は、
ソートによってその相対位置が変わる可能性があります。




<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>
指定したテーブルの要素を返します。
以下と同等です。

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
デフォルトでは <code>i</code> は 1 で <code>j</code> は <code>#list</code> です。







<h2>6.6 &ndash; <a name="6.6">数学関数</a></h2>

<p>
このライブラリは標準 C の数学ライブラリへのインタフェイスです。
すべての関数は <a name="pdf-math"><code>math</code></a> テーブルに提供されます。


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
<code>x</code> の絶対値を返します。




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
<code>x</code> の逆余弦を (ラジアンで) 返します。




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
<code>x</code> の逆正弦を (ラジアンで) 返します。




<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (x)</code></a></h3>


<p>
<code>x</code> の逆正接を (ラジアンで) 返します。




<p>
<hr><h3><a name="pdf-math.atan2"><code>math.atan2 (y, x)</code></a></h3>


<p>
<code>y/x</code> の逆正接を (ラジアンで) 返します。
ただし結果の象限を決めるために両方の引数の符号を使います
(また <code>x</code> がゼロの場合も正しく処理します)。




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
<code>x</code> 以上で最も小さい整数を返します。




<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
<code>x</code> (ラジアンで指定) の余弦を返します。




<p>
<hr><h3><a name="pdf-math.cosh"><code>math.cosh (x)</code></a></h3>


<p>
<code>x</code> の双曲線余弦を返します。




<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
角度 <code>x</code> (ラジアンで指定) を度で返します。




<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
<em>e<sup>x</sup></em> の値を返します。




<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
<code>x</code> 以下で最大の整数を返します。




<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
<code>x</code> を <code>y</code> で割ってゼロに向かって丸めた商の余りを返します。




<p>
<hr><h3><a name="pdf-math.frexp"><code>math.frexp (x)</code></a></h3>


<p>
<em>x = m2<sup>e</sup></em> であるような <code>m</code> および <code>e</code> を返します。
ただし <code>e</code> は整数で、 <code>m</code> は範囲 <em>[0.5, 1)</em> の絶対値
(<code>x</code> がゼロの場合はゼロ)
です。




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
<code>HUGE_VAL</code> の値です。
他のいかなる数値よりも大きいまたは等しい値です。




<p>
<hr><h3><a name="pdf-math.ldexp"><code>math.ldexp (m, e)</code></a></h3>


<p>
<em>m2<sup>e</sup></em> を返します
(<code>e</code> は整数であるべきです)。




<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>
指定した基数における <code>x</code> の対数を返します。
<code>base</code> のデフォルト値は <em>e</em> です
(つまり <code>x</code> の自然対数を返します)。




<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
引数の最大値を返します。




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
引数の最小値を返します。




<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
2 つの値、
<code>x</code> の整数部および <code>x</code> の指数部を返します。




<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
円周率の値です。




<p>
<hr><h3><a name="pdf-math.pow"><code>math.pow (x, y)</code></a></h3>


<p>
<em>x<sup>y</sup></em> を返します。
(式 <code>x^y</code> を使ってこの値を計算することもできます。)




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
角度 <code>x</code> (度で指定) をラジアンで返します。




<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
標準 C が提供している単純な疑似乱数生成関数 <code>rand</code> へのインタフェイスです。
(統計的な性質は保証されません。)


<p>
引数なしで呼ぶと、 範囲 <em>[0,1)</em> の一様な疑似乱数の実数を返します。
ひとつの整数 <code>m</code> を指定して呼ぶと、
範囲 <em>[1, m]</em> の一様な疑似乱数の整数を返します。
2 つの整数 <code>m</code> および <code>n</code> を指定して呼ぶと、
範囲 <em>[m, n]</em> の一様な疑似乱数の整数を返します。




<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
疑似乱数生成器の「種」として <code>x</code> を設定します。
同じ種を与えると同じ数列を生成します。




<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
<code>x</code> (ラジアンで指定) の正弦を返します。




<p>
<hr><h3><a name="pdf-math.sinh"><code>math.sinh (x)</code></a></h3>


<p>
<code>x</code> の双曲線正弦を返します。




<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
<code>x</code> の平方根を返します。
(式 <code>x^0.5</code> を使ってこの値を計算することもできます。)




<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
<code>x</code> (ラジアンで指定) の正接を返します。




<p>
<hr><h3><a name="pdf-math.tanh"><code>math.tanh (x)</code></a></h3>


<p>
<code>x</code> の双曲線正接を返します。







<h2>6.7 &ndash; <a name="6.7">ビット演算</a></h2>

<p>
このライブラリはビット演算を提供します。
すべての関数は <a name="pdf-bit32"><code>bit32</code></a> テーブルに提供されます。


<p>
特に記載がない限り、 すべての関数は範囲 <em>(-2<sup>51</sup>,+2<sup>51</sup>)</em> の数値引数を受け付けますが、
各引数は <em>2<sup>32</sup></em> で割った余りに正規化され、 (何らかの適当な方法で) 整数に丸められます。
それにより最終的な値は <em>[0,2<sup>32</sup> - 1]</em> の範囲になります。
同様に、 すべての戻り値も <em>[0,2<sup>32</sup> - 1]</em> の範囲になります。
<code>bit32.bnot(0)</code> の結果である <code>0xFFFFFFFF</code> は <code>-1</code> とは異なることに注意してください。


<p>
<hr><h3><a name="pdf-bit32.arshift"><code>bit32.arshift (x, disp)</code></a></h3>


<p>
<code>x</code> を <code>disp</code> ビット右にシフトした数値を返します。
数値 <code>disp</code> は表現可能な任意の整数を指定できます。
負の変位を指定すると左へシフトします。


<p>
このシフト演算は算術シフトと呼ばれるものです。
左端の空きビットは <code>x</code> の最上位ビットのコピーで埋められ、
右端の空きビットはゼロで埋められます。
ちなみに、 変位の絶対値が 31 より大きい場合、 結果はゼロか
<code>0xFFFFFFFF</code>
になります (元のビットはすべてシフトされ追い出されます)。




<p>
<hr><h3><a name="pdf-bit32.band"><code>bit32.band (&middot;&middot;&middot;)</code></a></h3>


<p>
引数のビットごとの論理積を返します。




<p>
<hr><h3><a name="pdf-bit32.bnot"><code>bit32.bnot (x)</code></a></h3>


<p>
<code>x</code> のビットごとの否定を返します。
任意の整数 <code>x</code> について、 以下の等式が成り立ちます。

<pre>
     assert(bit32.bnot(x) == (-1 - x) % 2^32)
</pre>



<p>
<hr><h3><a name="pdf-bit32.bor"><code>bit32.bor (&middot;&middot;&middot;)</code></a></h3>


<p>
引数のビットごとの論理和を返します。




<p>
<hr><h3><a name="pdf-bit32.btest"><code>bit32.btest (&middot;&middot;&middot;)</code></a></h3>


<p>
引数のビットごとの論理積がゼロと異なるかどうかを示すブーリアンを返します。




<p>
<hr><h3><a name="pdf-bit32.bxor"><code>bit32.bxor (&middot;&middot;&middot;)</code></a></h3>


<p>
引数のビットごとの排他的論理和を返します。




<p>
<hr><h3><a name="pdf-bit32.extract"><code>bit32.extract (n, field [, width])</code></a></h3>


<p>
<code>n</code> の <code>field</code> 番目から
<code>field + width - 1</code> 番目のビットからなる符号なし整数を返します。
ビットは 0 (最下位ビット) から数え、 31 (最上位ビット) までです。
アクセスするすべてのビットは <em>[0, 31]</em> の範囲内でなければなりません。


<p>
<code>width</code> のデフォルト値は 1 です。




<p>
<hr><h3><a name="pdf-bit32.replace"><code>bit32.replace (n, v, field [, width])</code></a></h3>


<p>
<code>n</code> の
<code>field</code> 番目から <code>field + width - 1</code> 番目のビットを
<code>v</code> で置き換えた値を返します。
<code>field</code> および <code>width</code> の詳細について
<a href="#pdf-bit32.extract"><code>bit32.extract</code></a>
を参照してください。




<p>
<hr><h3><a name="pdf-bit32.lrotate"><code>bit32.lrotate (x, disp)</code></a></h3>


<p>
<code>x</code> を <code>disp</code> ビット左にローテートした数値を返します。
数値 <code>disp</code> は任意の表現可能な整数を指定できます。


<p>
任意の変位について、 以下の等式が成り立ちます。

<pre>
     assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))
</pre><p>
ちなみに、 負の変位を指定すると右へローテートします。




<p>
<hr><h3><a name="pdf-bit32.lshift"><code>bit32.lshift (x, disp)</code></a></h3>


<p>
<code>x</code> を <code>disp</code> ビット左へシフトした値を返します。
数値 <code>disp</code> は任意の表現可能な整数を指定できます。
負の変位を指定すると右へシフトします。
いずれの方向でも空きビットはゼロで埋められます。
ちなみに、 変位の絶対値が 31 より大きい場合、 結果はゼロになります
(すべてのビットがシフトされ追い出されます)。


<p>
正の変位に対しては以下の等式が成り立ちます。

<pre>
     assert(bit32.lshift(b, disp) == (b * 2^disp) % 2^32)
</pre>



<p>
<hr><h3><a name="pdf-bit32.rrotate"><code>bit32.rrotate (x, disp)</code></a></h3>


<p>
<code>x</code> を <code>disp</code> ビット右へローテートした数値を返します。
数値 <code>disp</code> は任意の表現可能な数値を指定できます。


<p>
任意の有効な変位について、 以下の等式が成り立ちます。

<pre>
     assert(bit32.rrotate(x, disp) == bit32.rrotate(x, disp % 32))
</pre><p>
ちなみに、 負の変位を指定すると左へローテートします。




<p>
<hr><h3><a name="pdf-bit32.rshift"><code>bit32.rshift (x, disp)</code></a></h3>


<p>
<code>x</code> を <code>disp</code> ビット右へシフトした数値を返します。
数値 <code>disp</code> は任意の表現可能な整数を指定できます。
負の変位を指定すると左へシフトします。
いずれの方向でも空きビットはゼロで埋められます。
ちなみに、 変位の絶対値が 31 より大きい場合、 結果はゼロになります
(すべてのビットがシフトされ追い出されます)。


<p>
正の変位に対しては以下の等式が成り立ちます。

<pre>
     assert(bit32.rshift(b, disp) == math.floor(b % 2^32 / 2^disp))
</pre>

<p>
このシフト演算は論理シフトと呼ばれるものです。







<h2>6.8 &ndash; <a name="6.8">入出力機能</a></h2>

<p>
I/O ライブラリはファイル操作のための 2 つの異なったスタイルを提供します。
ひとつめは暗黙のファイルディスクリプタを使うものです。
つまり、 デフォルト入力ファイルとデフォルト出力ファイルを設定し、
すべての入出力操作はこれらデフォルトファイルに対して行います。
ふたつめは明示的なファイルディスクリプタを使うものです。


<p>
暗黙のファイルディスクリプタを使う場合、
すべての操作は <a name="pdf-io"><code>io</code></a> テーブルによって提供されます。
明示的なファイルディスクリプタを使う場合、
<a href="#pdf-io.open"><code>io.open</code></a> 関数が返すファイルディスクリプタを受け取り、
すべての操作をこのファイルディスクリプタのメソッドによって行います。


<p>
<code>io</code> テーブルはまた C のものと同様の意味を持つ 3 つの定義済みファイルディスクリプタ
<a name="pdf-io.stdin"><code>io.stdin</code></a>、 <a name="pdf-io.stdout"><code>io.stdout</code></a> および <a name="pdf-io.stderr"><code>io.stderr</code></a>
を提供しています。
I/O ライブラリはこれらのファイルは決してクローズしません。


<p>
特に記載がない限り、 すべての I/O 関数は失敗時に <b>nil</b>
(と、 2 番目の戻り値としてエラーメッセージ、 3 番目の戻り値としてシステム依存のエラーコード)
を返し、 成功時は <b>nil</b> 以外の何らかの値を返します。


<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p>
<code>file:close()</code> と同等です。
<code>file</code> を省略すると、 デフォルト出力ファイルを閉じます。




<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>
<code>io.output():flush()</code> と同等です。




<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>
ファイル名を指定して呼ぶと、 その名前のファイルを (テキストモードで) 開き、
そのハンドルをデフォルト入力ファイルとして設定します。
ファイルハンドルを指定して呼ぶと、
単純にそのファイルハンドルをデフォルト入力ファイルとして設定します。
引数なしで呼ぶと、
現在のデフォルト入力ファイルを返します。


<p>
エラーの場合は、 エラーコードを返す代わりにエラーを発生させます。




<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename] &middot;&middot;&middot;)</code></a></h3>


<p>
指定したファイル名を読み込みモードで開き、
その開いたファイルに対して
<code>file:lines(&middot;&middot;&middot;)</code>
と同様に動作するイテレータ関数を返します。
イテレータ関数がファイルの終わりを検知すると、
(ループを終了するために) <b>nil</b> を返し、 自動的にそのファイルを閉じます。


<p>
<code>io.lines()</code> (ファイル名なし) の呼び出しは
<code>io.input():lines()</code> と同等です。
つまり、 デフォルト入力ファイルの各行を巡回します。
この場合はループ終了時にファイルを閉じません。


<p>
エラーの場合、
この関数はエラーコードを返す代わりにエラーを発生させます。




<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
文字列 <code>mode</code> で指定したモードでファイルを開きます。
新しいファイルハンドルを返します。
エラーの場合は <b>nil</b> およびエラーメッセージを返します。


<p>
<code>mode</code> 文字列は以下のいずれかを指定できます。

<ul>
<li><b>"<code>r</code>": </b> 読み込みモード (デフォルト)。</li>
<li><b>"<code>w</code>": </b> 書き込みモード。</li>
<li><b>"<code>a</code>": </b> 追記モード。</li>
<li><b>"<code>r+</code>": </b> 更新モード。 以前のデータは維持されます。</li>
<li><b>"<code>w+</code>": </b> 更新モード。 以前のデータは消去されます。</li>
<li><b>"<code>a+</code>": </b> 追記更新モード。 以前のデータは維持され、 ファイルの最後にのみ書き込みができます。</li>
</ul><p>
<code>mode</code> 文字列の最後に '<code>b</code>' を指定することもできます。
システムによってはバイナリモードでファイルを開く場合に必要になります。




<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
<a href="#pdf-io.input"><code>io.input</code></a> に似ていますが、
デフォルト出力ファイルを操作します。




<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
この関数はシステム依存であり、 すべてのプラットフォームで利用可能とは限りません。


<p>
別のプロセスでプログラム <code>prog</code> を開始し、
そのプログラムからデータを読み出す
(<code>mode</code> が <code>"r"</code> の場合、 デフォルト)
またはそのプログラムにデータを書き込む
(<code>mode</code> が <code>"w"</code> の場合)
ためのファイルハンドルを返します。




<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>


<p>
<code>io.input():read(&middot;&middot;&middot;)</code> と同等です。




<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
テンポラリファイルのハンドルを返します。
このファイルは更新モードで開かれ、 プログラム終了時に自動的に削除されます。




<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
<code>obj</code> が有効なファイルハンドルかどうかを調べます。
<code>obj</code> が開いているファイルハンドルの場合は文字列 <code>"file"</code> を返します。
<code>obj</code> が閉じたファイルハンドルの場合は <code>"closed file"</code> を返します。
<code>obj</code> がファイルハンドルでない場合は <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>
<code>io.output():write(&middot;&middot;&middot;)</code> と同等です。




<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
<code>file</code> を閉じます。
ファイルはハンドルがガベージコレクタに回収されると自動的に閉じられますが、
そうなるまでの時間は予測できないことに注意してください。


<p>
<a href="#pdf-io.popen"><code>io.popen</code></a> で作成したファイルハンドルを閉じた場合、
<a href="#pdf-file:close"><code>file:close</code></a> は
<a href="#pdf-os.execute"><code>os.execute</code></a> から返されるのと同じ値を返します。




<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
<code>file</code> に書き込んだデータをすべて保存します。




<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines (&middot;&middot;&middot;)</code></a></h3>


<p>
呼ばれるたびに指定した書式に従ってファイルを読み込むイテレータ関数を返します。
書式を指定しなかった場合はデフォルトとして "*l" が使われます。
例えば、 以下の文は

<pre>
     for c in file:lines(1) do <em>body</em> end
</pre><p>
そのファイルの現在の位置から始まるすべての文字を巡回します。
<a href="#pdf-io.lines"><code>io.lines</code></a> と異なり、
ループ終了時にファイルを閉じません。


<p>
エラーの場合、
この関数はエラーコードを返す代わりにエラーを発生させます。




<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>


<p>
指定した書式に従ってファイル <code>file</code> を読み込みます。
それぞれの書式について、 読み込んだ文字からなる文字列 (または数値) を返します。
指定した書式で読めなかった場合は <b>nil</b> を返します。
引数を指定せずに呼ぶと、 次の行を読むデフォルトの書式が使われます
(以下を参照)。


<p>
指定可能な書式は以下の通りです。

<ul>

<li><b>"<code>*n</code>": </b>
数値を読み込みます。
これは文字列の代わりに数値を返す唯一の書式です。
</li>

<li><b>"<code>*a</code>": </b>
現在の位置から始まって、 ファイル全体を読み込みます。
ファイルの終わりであれば、 空文字列を返します。
</li>

<li><b>"<code>*l</code>": </b>
次の行を読み込みます。
改行は飛ばします。
ファイルの終わりでは <b>nil</b> を返します。
これはデフォルトの書式です。
</li>

<li><b>"<code>*L</code>": </b>
次の行を読み込みます。
改行は保持します (もしあれば)。
ファイルの終わりでは <b>nil</b> を返します。
</li>

<li><b><em>数値</em>: </b>
指定した数値のバイト数 (最大) からなる文字列を読み込みます。
ファイルの終わりでは <b>nil</b> を返します。
数値がゼロの場合は、 何も読まずに空文字列を返します。
</li>

</ul>



<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
<code>offset</code> で指定した位置に文字列 <code>whence</code>
で指定した基準を足した位置にファイルの位置を設定し、
先頭から数えたファイルの位置を取得します。
<code>whence</code> は以下のいずれかです。

<ul>
<li><b>"<code>set</code>": </b> 基準は位置 0 (ファイルの先頭) です。</li>
<li><b>"<code>cur</code>": </b> 基準は現在の位置です。</li>
<li><b>"<code>end</code>": </b> 基準はファイルの終わりです。</li>
</ul><p>
成功した場合は、 最終的なファイル位置をファイルの先頭から数えたバイト数で返します。
失敗した場合は、 <b>nil</b> およびエラーを説明する文字列を返します。


<p>
<code>whence</code> のデフォルト値は <code>"cur"</code> で、
<code>offset</code> は 0 です。
そのため、 <code>file:seek()</code> は現在位置を変更せずに現在位置を返し、
<code>file:seek("set")</code> は位置をファイルの先頭に設定し (て 0 を返し)、
<code>file:seek("end")</code> は位置をファイルの終わりに設定してそのファイルのサイズを返します。




<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
出力ファイルのバッファリングモードを設定します。
以下の 3 つのモードが指定可能です。

<ul>

<li><b>"<code>no</code>": </b>
バッファリングなし。
すべての出力操作の結果はただちに反映されます。
</li>

<li><b>"<code>full</code>": </b>
完全バッファリング。
出力操作はバッファが満杯のとき、
または明示的にファイルを <code>flush</code> したときだけ行われます
(<a href="#pdf-io.flush"><code>io.flush</code></a> を参照)。
</li>

<li><b>"<code>line</code>": </b>
行バッファリング。
改行が出力されるか、 何らかのスペシャルファイル (端末装置など) からの入力があるまで、
出力はバッファリングされます。
</li>

</ul><p>
最後の 2 つの場合、 <code>size</code> はバッファのサイズをバイト数で指定します。
デフォルトのサイズは適当です。




<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>


<p>
各引数の値を <code>file</code> に書き込みます。
引数は文字列か数値でなければなりません。


<p>
成功した場合は <code>file</code> を返します。
失敗した場合は <b>nil</b> およびエラーを説明する文字列を返します。







<h2>6.9 &ndash; <a name="6.9">OS機能</a></h2>

<p>
このライブラリは <a name="pdf-os"><code>os</code></a> テーブルを通じて実装されています。


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
プログラムが使用した CPU 時間のおよその秒数を返します。




<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
<code>format</code> で指定した文字列に従って書式化された日付および時刻を表す文字列またはテーブルを返します。


<p>
<code>time</code> 引数を指定した場合は、 その時刻が書式化されます
(この値の説明は <a href="#pdf-os.time"><code>os.time</code></a> 関数を参照してください)。
省略した場合は現在の時刻が書式化されます。


<p>
<code>format</code> が '<code>!</code>' で始まる場合は、 日付は協定世界時で書式化されます。
この省略可能な文字に続いて、
<code>format</code> が文字列 "<code>*t</code>" であれば、 以下のフィールドを持つテーブルが返されます。
<ul>
<li><code>year</code> (4 桁)
<li><code>month</code> (1〜12)
<li><code>day</code> (1〜31)
<li><code>hour</code> (0〜23)
<li><code>min</code> (0〜59)
<li><code>sec</code> (0〜61)
<li><code>wday</code> (曜日、 日曜日=1)
<li><code>yday</code> (通日)
<li><code>isdst</code> (夏時間フラグ、 ブーリアン)
</ul>
<p>
夏時間の情報が利用可能でない場合は最後のフィールドは存在しません。


<p>
<code>format</code> が "<code>*t</code>" でなければ、
C の <code>strftime</code> 関数と同じルールに従って書式化した日付を文字列として返します。


<p>
引数なしで呼ぶと、 ホストシステムと現在のロケールに依存した適当な日付と時刻の表現を返します
(つまり <code>os.date()</code> は <code>os.date("%c")</code> と同等です)。


<p>
システムによってはこの関数はスレッドセーフではありません。




<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
時刻 <code>t1</code> から時刻 <code>t2</code> までの秒数を返します。
POSIX、 Windows、 その他いくつかのシステムでは、 この値は <code>t2</code><em>-</em><code>t1</code> です。




<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
C の <code>system</code> 関数と同等です。
オペレーティングシステムのシェルによって実行される <code>command</code> を指定します。
コマンドが正常終了した場合は最初の戻り値が <b>true</b> になり、
そうでなければ <b>nil</b> になります。
この最初の戻り値に続いて、 以下のような文字列と数値を返します。

<ul>

<li><b>"<code>exit</code>": </b>
コマンドは普通に終了しました。
後続の数値はコマンドの終了ステータスです。
</li>

<li><b>"<code>signal</code>": </b>
コマンドはシグナルによって終了しました。
後続の数値はコマンドを終了させたシグナルです。
</li>

</ul>

<p>
<code>command</code> を指定せずに呼ぶと、
シェルが利用可能かどうかを示すブーリアンを返します。




<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close])</code></a></h3>


<p>
C の <code>exit</code> 関数を呼び、 ホストプログラムを終了させます。
<code>code</code> が <b>true</b> であれば、 終了ステータスは <code>EXIT_SUCCESS</code> になります。
<code>code</code> が <b>false</b> であれば、 終了ステータスは <code>EXIT_FAILURE</code> になります。
<code>code</code> が数値であれば、 終了ステータスはその数値になります。
<code>code</code> のデフォルト値は <b>true</b> です。


<p>
省略可能な第 2 引数 <code>close</code> が真であれば、 終了する前に Lua ステートを閉じます。




<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
プロセスの環境変数 <code>varname</code> の値を返します。
その変数が定義されていない場合は <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
指定した名前のファイル (または POSIX システムでは、 空のディレクトリ) を削除します。
失敗した場合は <b>nil</b> およびエラーを説明する文字列を返します。




<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
ファイルまたはディレクトリ <code>oldname</code> を <code>newname</code> に改名します。
失敗した場合は <b>nil</b> およびエラーを説明する文字列を返します。




<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
プログラムの現在のロケールを設定します。
<code>locale</code> はロケールを指定するシステム依存の文字列です。
<code>category</code> は変更するカテゴリを指定する以下の文字列で、 省略可能です。
<ul>
<li><code>"all"</code>
<li><code>"collate"</code>
<li><code>"ctype"</code>
<li><code>"monetary"</code>
<li><code>"numeric"</code>
<li><code>"time"</code>
</ul>
<p>
デフォルトのカテゴリは <code>"all"</code> です。
戻り値は新しいロケールの名前です。
要求を実行できない場合は <b>nil</b> を返します。


<p>
<code>locale</code> が空文字列の場合は、 現在のロケールを実装依存のネイティブなロケールに設定します。
<code>locale</code> が文字列 "<code>C</code>" の場合は、 現在のロケールを標準 C のロケールに設定します。


<p>
第 1 引数に <b>nil</b> を指定して呼ぶと、 指定したカテゴリの現在のロケールの名前を単に返します。




<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
引数なしで呼ぶと、 現在の時刻を返します。
引数を指定すると、 そのテーブルで指定した日付と時刻を表現する時刻を返します。
このテーブルには以下のフィールドが必須です。
<ul>
<li><code>year</code>
<li><code>month</code>
<li><code>day</code>
</ul>
<p>
さらに以下のフィールドも指定できます。
<ul>
<li><code>hour</code> (デフォルトは 12)
<li><code>min</code> (デフォルトは 0)
<li><code>sec</code> (デフォルトは 0)
<li><code>isdst</code> (デフォルトは <b>nil</b>)
</ul>
<p>
これらのフィールドの説明は <a href="#pdf-os.date"><code>os.date</code></a> 関数を参照してください。


<p>
戻り値はシステム依存の意味を持つ数値です。
POSIX、 Windows、 その他いくつかのシステムでは、
この数値は、 ある特定の開始時刻 (「エポック」) からの経過秒数です。
それ以外のシステムでは、 その意味は決まっていません。
<code>time</code> の戻り値は <code>date</code> および <code>difftime</code> への引数としてのみ使うことができます。




<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
テンポラリファイルとして使うことのできるファイル名の文字列を返します。
このファイルは使う前に明示的に開かなければならず、 使い終わったときに明示的に削除しなければなりません。


<p>
POSIX システムでは、 セキュリティ上のリスクを避けるために、 この関数はその名前のファイルを作成します。
(名前を取得してからファイルを作成するまでの間に他の誰かがまずいパーミッションでそのファイルを作成する可能性があるためです。)
その場合でも使うときにはファイルを開かなければならず、
また (結局使わなかった場合でも) 削除する必要があります。


<p>
可能であれば <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a> を使う方が良いです。
プログラムの終了時に自動的にファイルを削除してくれます。







<h2>6.10 &ndash; <a name="6.10">デバッグライブラリ</a></h2>

<p>
このライブラリは Lua のプログラムにデバッグインタフェイス (<a href="#4.9">&sect;4.9</a>) の機能を提供します。
このライブラリを使うときは特に注意してください。
この関数のいくつかは Lua のコードに関する基本的な想定
(例えば、 ローカル変数は外側からアクセスできない、
ユーザーデータのメタテーブルは Lua のコードから変更できない、
Lua のプログラムはクラッシュしない、 など)
を破り、 安全なはずのコードを危険に晒します。
加えて、 このライブラリの関数は動作が遅い場合があります。


<p>
このライブラリのすべての関数は <a name="pdf-debug"><code>debug</code></a> テーブルに提供されます。
スレッドに対して操作をするすべての関数は省略可能な最初の引数として操作対象のスレッドを受け付けます。
デフォルトは常に現在のスレッドです。


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
ユーザーが入力した各文字列を実行する対話モードに入ります。
シンプルなコマンドとその他のデバッグ機能を使うことで、
ユーザーがグローバル変数やローカル変数を調査したり、
その値を変更したり、 式を評価したりできます。
単語 <code>cont</code> のみの行を入力すると、
この関数を終了し、 呼び出し元の実行が継続されます。


<p>
<code>debug.debug</code> で入力されるコマンドはいずれかの関数の内側にネストしているわけではないため、
ローカル変数へは直接アクセスできません。




<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
スレッドの現在のフック設定を、
現在のフック関数、 現在のフックマスク、 現在のフックカウントの 3 つの値として返します
(<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> 関数で設定されるものと同様です)。




<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
関数に関する情報を格納したテーブルを返します。
<code>f</code> の値として、 関数を直接渡すか、 数値を指定することができます。
数値は指定したスレッドのコールスタック上で実行中のレベル <code>f</code> の関数を表します。
レベル 0 は現在の関数 (<code>getinfo</code> 自身) で、
レベル 1 は <code>getinfo</code> を呼んだ関数で、
以下同様です (スタックにカウントされない末尾呼び出しを除きます)。
<code>f</code> がアクティブな関数の数よりも大きい数値の場合は <b>nil</b> を返します。


<p>
埋めるフィールドを指定する文字列 <code>what</code> を指定すると、
戻り値のテーブルは <a href="#lua_getinfo"><code>lua_getinfo</code></a> が返すフィールドをすべて持ちます。
<code>what</code> のデフォルトは、 有効な行番号のテーブルを除くすべての利用可能な情報を取得します。
オプション '<code>f</code>' を指定すると、 <code>func</code> という名前のフィールドにその関数自身を格納します。
オプション '<code>L</code>' を指定すると、 <code>activelines</code> という名前のフィールドに有効な行番号のテーブルを格納します。


<p>
例えば、 式 <code>debug.getinfo(1,"n").name</code> は、 現在の関数の名前
(適当な名前が見つかった場合)
を格納したテーブルを返します。
また式 <code>debug.getinfo(print)</code> は、
<a href="#pdf-print"><code>print</code></a> 関数に関するすべての利用可能な情報を格納したテーブルを返します。




<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
スタック上のレベル <code>f</code> の関数のインデックス <code>local</code> のローカル変数の名前と値を返します。
明示的なローカル変数だけでなく、 引数や一時変数などにもアクセスします。


<p>
最初の引数またはローカル変数はインデックス 1 で、 最後のアクティブな変数まで以下同様です。
負のインデックスを指定すると可変長引数を参照します。
-1 は最初の可変長引数です。
指定したインデックスの変数が存在しなければ <b>nil</b> を返し、
範囲外のレベルを指定した場合はエラーを発生します。
(レベルが有効かどうかを調べるには <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> を使ってください。)


<p>
'<code>(</code>' (開き括弧) で始まる変数名は内部の変数
(ループ制御変数、 一時変数、 可変長引数、 および C の関数のローカル変数)
を表します。


<p>
引数 <code>f</code> に関数を指定することもできます。
この場合は関数の引数の名前だけを返します。




<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
指定した <code>value</code> のメタテーブルを返します。
メタテーブルがなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
レジストリテーブルを返します (<a href="#4.5">&sect;4.5</a> を参照)。




<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
関数 <code>f</code> のインデックス <code>up</code> の上位値の名前と値を返します。
指定したインデックスの上位値がなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3>


<p>
<code>u</code> に関連付けられた Lua の値を返します。
<code>u</code> がユーザーデータでなければ <b>nil</b> を返します。




<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
指定した関数をフックとして設定します。
文字列 <code>mask</code> および数値 <code>count</code> はフックがいつ呼ばれるかを指定します。
文字列 mask には以下の文字を指定することができます。

<ul>
<li><b>'<code>c</code>': </b> 関数を呼ぶたびにフックが呼ばれます。</li>
<li><b>'<code>r</code>': </b> 関数から戻るたびにフックが呼ばれます。</li>
<li><b>'<code>l</code>': </b> コードの新しい行に入るたびにフックが呼ばれます。</li>
</ul><p>
また <code>count</code> がゼロでなければ、
<code>count</code> 個の命令を実行するたびにフックが呼ばれます。


<p>
引数を指定せずに呼ぶと、 フックを無効にします。


<p>
フックが呼ばれたとき、 第 1 引数にはその呼び出しの原因となったイベントを表す以下の文字列が渡されます。
<ul>
<li><code>"call"</code> (または <code>"tail call"</code>)
<li><code>"return"</code>
<li><code>"line"</code>
<li><code>"count"</code>
</ul>
<p>
line イベントでは、 第 2 引数に新しい行番号も渡されます。
フック内部で実行中の関数に関する情報を取得するにはレベル 2 を指定して
<code>getinfo</code>
を呼んでください
(レベル 0 は <code>getinfo</code> 関数で、 レベル 1 はフック関数です)。




<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
スタック上のレベル <code>level</code> の関数のインデックス <code>local</code> のローカル変数に値 <code>value</code> を代入します。
指定したインデックスのローカル変数が存在しなければ <b>nil</b> を返し、
範囲外の <code>level</code> を指定した場合はエラーを発生します。
(レベルが有効かどうかをチェックするには <code>getinfo</code> を呼んでください。)
それ以外の場合はそのローカル変数の名前を返します。


<p>
変数のインデックスと名前についてのさらなる情報は
<a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>
を参照してください。




<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
指定した <code>value</code> のメタテーブルを指定した <code>table</code> に設定します
(<code>table</code> は <b>nil</b> も指定できます)。
<code>value</code> を返します。




<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
関数 <code>f</code> のインデックス <code>up</code> の上位値に値 <code>value</code> を代入します。
指定したインデックスの上位値が存在しない場合は <b>nil</b> を返します。
そうでなければその上位値の名前を返します。




<p>
<hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3>


<p>
指定した <code>udata</code> に指定した <code>value</code> を関連付けます。
<code>value</code> はテーブルか <b>nil</b> でなければならず、
<code>udata</code> はフルユーザーデータでなければなりません。


<p>
<code>udata</code> を返します。




<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
<code>message</code> が文字列でも <b>nil</b> でもなければ、
それ以上の処理をせずに <code>message</code> を返します。
そうでなければ、 スタックトレースの文字列を返します。
省略可能な文字列 <code>message</code> がトレースの先頭に追加されます。
省略可能な数値 <code>level</code> はトレースを開始するレベルを指定します
(デフォルトは 1 で、 <code>traceback</code> を呼んだ関数です)。




<p>
<hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
指定した関数の <code>n</code> 番目の上位値を表す一意な識別子を (ライトユーザーデータとして) 返します。


<p>
この一意な識別子を使うと異なるクロージャが上位値を共有しているかどうかを調べることができます。
上位値を共有している
(つまり同じ外部ローカル変数にアクセスする)
Lua のクロージャは、 それらの上位値のインデックスに対して等しい識別子を返します。




<p>
<hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
Lua のクロージャ <code>f1</code> の <code>n1</code> 番目の上位値が
Lua のクロージャ <code>f2</code> の <code>n2</code> 番目の上位値を参照するようにします。







<h1>7 &ndash; <a name="7">スタンドアロンの Lua</a></h1>

<p>
Lua は C のホストプログラムに組み込まれる拡張言語として設計されていますが、 しばしばスタンドアロンの言語としても使われます。
スタンドアロンの言語としての Lua インタプリタはシンプルに <code>lua</code> と呼ばれ、 標準の配布物と共に提供されています。
スタンドアロンのインタプリタはすべての標準ライブラリ (デバッグライブラリも含む) を含んでいます。
使い方は以下の通りです。

<pre>
     lua [options] [script [args]]
</pre><p>
オプションは以下の通りです。

<ul>
<li><b><code>-e <em>stat</em></code>: </b> 文字列 <em>stat</em> を実行します。</li>
<li><b><code>-l <em>mod</em></code>: </b> モジュール <em>mod</em> を "require" します。</li>
<li><b><code>-i</code>: </b> <em>スクリプト</em> の実行後に対話モードに入ります。</li>
<li><b><code>-v</code>: </b> バージョン情報を表示します。</li>
<li><b><code>-E</code>: </b> 環境変数を無視します。</li>
<li><b><code>--</code>: </b> オプションの処理を停止します。</li>
<li><b><code>-</code>: </b> 標準入力をファイルとして実行し、 オプションの処理を停止します。</li>
</ul><p>
オプションを処理した後、 <code>lua</code> は指定された <em>args</em> を文字列引数として渡し、 指定された <em>script</em> を実行します。
引数なしで実行した場合、 標準入力が端末であれば <code>lua</code> は <code>lua -v -i</code> のように動作し、
そうでなければ <code>lua -</code> のように動作します。


<p>
<code>-E</code> を指定せずに呼ぶと、
どの引数も処理する前に環境変数 <a name="pdf-LUA_INIT_5_2"><code>LUA_INIT_5_2</code></a>
(もし定義されていなければ、 代わりに <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a>)
がチェックされます。
その変数の値が <code>@<em>filename</em></code> の形式であれば、 <code>lua</code> はそのファイルを実行します。
そうでなければ、 <code>lua</code> はその文字列自身を実行します。


<p>
オプション <code>-E</code> を指定して呼ぶと、
<code>LUA_INIT</code> に加えて
<code>LUA_PATH</code> および <code>LUA_CPATH</code> も無視し、
<code>luaconf.h</code> で定義されているデフォルトのパスを
<a href="#pdf-package.path"><code>package.path</code></a> および <a href="#pdf-package.cpath"><code>package.cpath</code></a>
に設定します。


<p>
<code>-i</code> および <code>-E</code> 以外のすべてのオプションは指定した順番で処理されます。
例えば、 以下のようなコマンドは

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
まず <code>a</code> に 1 を設定し、 次に <code>a</code> の値を表示し、
最後にファイル <code>script.lua</code> を引数なしで実行します。
(<code>$</code> はシェルプロンプトです。 これは使用している環境によって異なる場合があります。)


<p>
スクリプトの実行を開始する前に、
<code>lua</code> は <code>arg</code> と呼ばれるグローバルなテーブルにすべてのコマンドライン引数を集めます。
スクリプト名はインデックス 0 に格納され、
スクリプト名の後の最初の引数はインデックス 1 に格納され、 以下同様です。
スクリプト名の前の引数
(つまりインタプリタ名とインタプリタへのオプション)
は、 負のインデックスに格納されます。
例えば、

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
は、 まずファイル <code>a.lua</code> を実行し、 次に以下のようなテーブルを作成し、

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
最後にファイル <code>b.lua</code> を実行します。
スクリプトは
<code>arg[1]</code>、 <code>arg[2]</code>、 ...
を引数として呼ばれ、 可変長引数式 '<code>...</code>' でこれらの引数にアクセスすることもできます。


<p>
対話モードでは、 不完全な文を書くと、 異なるプロンプトを表示して文が完成するまで待ちます。


<p>
スクリプト中で保護されないエラーが発生した場合、
インタプリタは標準出力ストリームにエラーを報告します。
エラーオブジェクトが文字列であれば、 スタックトレースにそれが追加されます。
そうでなく、 エラーオブジェクトが <code>__tostring</code> メタメソッドを持っていれば、 最終的なメッセージを生成するためにそのメタメソッドが呼ばれます。
最後に、 エラーオブジェクトが <b>nil</b> の場合は、 エラーは報告されません。


<p>
正常終了すると、 インタプリタはメインの Lua ステートを閉じます
(see <a href="#lua_close"><code>lua_close</code></a> を参照)。
<a href="#pdf-os.exit"><code>os.exit</code></a> を読んで終了すると、 このステップを回避できます。


<p>
Unix システムで Lua をスクリプトインタプリタとして使えるように、
スタンドアロンのインタプリタはチャンクが <code>#</code> で始まっている場合、 1 行目をスキップします。
そのため、 <code>chmod +x</code> と <code>#!</code> 形式を使って、 Lua のスクリプトを実行可能プログラムにすることができます。

<pre>
     #!/usr/local/bin/lua
</pre><p>
(Lua インタプリタの場所は環境によって異なる場合があります。
<code>lua</code> が <code>PATH</code> の通っている場所にある場合は、

<pre>
     #!/usr/bin/env lua
</pre><p>
がより移植性の高い方法です。)



<h1>8 &ndash; <a name="8">前のバージョンと非互換な点</a></h1>

<p>
プログラムを Lua 5.1 から Lua 5.2 に移行するにあたって、 直面する可能性のある非互換な点の一覧を記載します。
適切なオプションを使って Lua をコンパイルすれば、 いくつかの非互換は回避できる場合があります (ファイル <code>luaconf.h</code> を参照)。
ただし、 これらの互換用オプションはすべて、 次のバージョンの Lua では削除される予定です。



<h2>8.1 &ndash; <a name="8.1">言語の変更</a></h2>
<ul>

<li>
<em>環境</em> の概念が変わりました。
Lua の関数のみが環境を持ちます。
Lua の関数の環境を設定するには、 変数 <code>_ENV</code> を使うか、 関数 <a href="#pdf-load"><code>load</code></a> を使います。


<p>
C の関数は環境を持たなくなりました。
いくつかの C の関数の間で共有の状態を持つ必要があれば、 上位値を使ってテーブルを共有してください。
(すべての関数で共通の上位値を共有する C のライブラリを開くために、
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> を使うのもよいでしょう。)


<p>
ユーザーデータの「環境」
(現在は user value と呼ばれています)
を操作する場合は、 新しい関数
<a href="#lua_getuservalue"><code>lua_getuservalue</code></a>
および
<a href="#lua_setuservalue"><code>lua_setuservalue</code></a>
を使ってください。
</li>

<li>
Lua の識別子にロケール依存の文字が使えなくなりました。
</li>

<li>
ガベージコレクションをステップ実行またはフル実行しても、 停止状態のガベージコレクタは再開しなくなりました。
</li>

<li>
弱参照キーを持つ弱参照テーブルは <em>短命テーブル</em> として動作するようになりました。
</li>

<li>
デバッグフックの <em>tail return</em> は削除されました。
代わりに、 末尾呼び出しは特別な新しいイベント
<em>tail call</em>
を生成するので、 デバッガは対応するリターンイベントが存在しないことを知ることができます。
</li>

<li>
関数値の等値比較が変更されました。
関数定義は新しい値を生成しない場合があるようになりました。
新しい関数との間に観測可能な差異が無ければ、 以前の値を再利用する場合があります。
</li>

</ul>




<h2>8.2 &ndash; <a name="8.2">ライブラリの変更</a></h2>
<ul>

<li>
関数 <code>module</code> は廃止されました。
通常の Lua のコードでモジュールをセットアップするのが簡単になりました。
モジュールはグローバル変数を設定すると期待されることはなくなりました。
</li>

<li>
関数 <code>setfenv</code> および <code>getfenv</code> は環境に関する変更によって削除されました。
</li>

<li>
関数 <code>math.log10</code> は廃止されました。
代わりに <a href="#pdf-math.log"><code>math.log</code></a> を使い、 第 2 引数に 10 を指定してください。
</li>

<li>
関数 <code>loadstring</code> は廃止されました。
代わりに <code>load</code> を使ってください。
この関数は文字列引数を受け取るようになり、 <code>loadstring</code> とまったく同等になりました。
</li>

<li>
関数 <code>table.maxn</code> は廃止されました。
本当に必要な場合は Lua で書いてください。
</li>

<li>
関数 <code>os.execute</code> はコマンドが正常終了した場合 <b>true</b> を返し、
それ以外の場合は <b>nil</b> とエラー情報を返すようになりました。
</li>

<li>
関数 <code>unpack</code> はテーブルライブラリに移動され、
そのため <a href="#pdf-table.unpack"><code>table.unpack</code></a> という名前になりました。
</li>

<li>
パターン中の <code>%z</code> 文字クラスは廃止され、
'<code>\0</code>' が通常の文字としてパターン中で使用できるようになりました。
</li>

<li>
テーブル <code>package.loaders</code> は <code>package.searchers</code> に改名されました。
</li>

<li>
Lua はバイトコードの検証を行わなくなりました。
そのため、 コードをロードするすべての関数
(<a href="#pdf-load"><code>load</code></a> および <a href="#pdf-loadfile"><code>loadfile</code></a>)
は、 信頼されていないバイナリデータを読み込む場合、 潜在的な危険があります。
(実際のところ、 これらの関数は検証アルゴリズムに欠陥があり、 元々危険でした。)
疑わしい場合は、 これらの関数の引数 <code>mode</code> を使って、
ロードするチャンクをテキスト形式に制限してください。
</li>

</ul>




<h2>8.3 &ndash; <a name="8.3">API の変更</a></h2>
<ul>

<li>
疑似インデックス <code>LUA_GLOBALSINDEX</code> は削除されました。
グローバル環境はレジストリから取得する必要があります
(<a href="#4.5">&sect;4.5</a> を参照)。
</li>

<li>
C の関数が環境を持たなくなったため、
疑似インデックス <code>LUA_ENVIRONINDEX</code> および関数 <code>lua_getfenv</code>/<code>lua_setfenv</code> は削除されました。
</li>

<li>
関数 <code>luaL_register</code> は廃止されました。
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a> を使ってください。
モジュールはグローバル変数を作らなくなります。
(モジュールにグローバル変数を設定すると期待されることはなくなりました。)
</li>

<li>
新しいブロックを作成するとき、
つまり <code>ptr</code> が <code>NULL</code> であるとき、
アロケーション関数の <code>osize</code> 引数がゼロであるとは限らなくなりました
(<a href="#lua_Alloc"><code>lua_Alloc</code></a> を参照)。
ブロックが新規かどうかをチェックするときは、
<code>ptr == NULL</code>
だけを使ってください。
</li>

<li>
ユーザーデータのファイナライザ
(<code>__gc</code> メタメソッド)
は、 作成された順番の逆ではなく、 ファイナライズ用にマークされた順番の逆で呼ばれるようになりました
(<a href="#2.5.1">&sect;2.5.1</a> を参照)。
(ほとんどのユーザーデータは作成直後にマークされます。)
また、 メタテーブルが設定されたときに <code>__gc</code> フィールドがセットされていなければ、
後でセットされても、 ファイナライザが呼ばれなくなりました。
</li>

<li>
<code>luaL_typerror</code> は削除されました。
必要なら自分で書いてください。
</li>

<li>
関数 <code>lua_cpcall</code> は廃止されました。
単純に <a href="#lua_pushcfunction"><code>lua_pushcfunction</code></a> で関数を積み、
<a href="#lua_pcall"><code>lua_pcall</code></a> で呼ぶことができます。
</li>

<li>
関数 <code>lua_equal</code> および <code>lua_lessthan</code> は廃止されました。
代わりに新しい <a href="#lua_compare"><code>lua_compare</code></a> を適切な引数で呼んでください。
</li>

<li>
関数 <code>lua_objlen</code> は <a href="#lua_rawlen"><code>lua_rawlen</code></a> に改名されました。
</li>

<li>
関数 <a href="#lua_load"><code>lua_load</code></a> に引数 <code>mode</code> が追加されました。
<code>NULL</code> を渡すと以前と同じ動作になります。
</li>

<li>
関数 <a href="#lua_resume"><code>lua_resume</code></a> に引数 <code>from</code> が追加されました。
<code>NULL</code> または呼び出しを実行しているスレッドを渡してください。
</li>

</ul>




<h1>9 &ndash; <a name="9">Lua の完全な構文</a></h1>

<p>
拡張 BNF 記法で記した Lua の完全な構文を掲載します。
(演算子の優先順位に関しては記述されていません。)




<pre>

	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  &lsquo;<b>;</b>&rsquo; |
		 varlist &lsquo;<b>=</b>&rsquo; explist |
		 functioncall |
		 label |
		 <b>break</b> |
		 <b>goto</b> Name |
		 <b>do</b> block <b>end</b> |
		 <b>while</b> exp <b>do</b> block <b>end</b> |
		 <b>repeat</b> block <b>until</b> exp |
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> |
		 <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b> |
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> |
		 <b>function</b> funcname funcbody |
		 <b>local</b> <b>function</b> Name funcbody |
		 <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]

	retstat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]

	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;

	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]

	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}

	var ::=  Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefixexp &lsquo;<b>.</b>&rsquo; Name

	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}

	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Number | String | &lsquo;<b>...</b>&rsquo; | functiondef |
		 prefixexp | tableconstructor | exp binop exp | unop exp

	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;

	functioncall ::=  prefixexp args | prefixexp &lsquo;<b>:</b>&rsquo; Name args

	args ::=  &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo; | tableconstructor | String

	functiondef ::= <b>function</b> funcbody

	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>

	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;

	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp

	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;

	binop ::= &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>%</b>&rsquo; | &lsquo;<b>..</b>&rsquo; |
		 &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo; | &lsquo;<b>~=</b>&rsquo; |
		 <b>and</b> | <b>or</b>

	unop ::= &lsquo;<b>-</b>&rsquo; | <b>not</b> | &lsquo;<b>#</b>&rsquo;

</pre>

</body></html>

